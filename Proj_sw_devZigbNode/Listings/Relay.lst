C51 COMPILER V9.54   RELAY                                                                 02/15/2019 15:28:06 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE RELAY
OBJECT MODULE PLACED IN .\Output\Relay.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Actuator\Relay.c OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\
                    -std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\Relay.lst) OBJECT(.\Output\Relay.obj)

line level    source

   1          #include "Relay.h"
   2          
   3          #include "string.h"
   4          #include "stdio.h"
   5          
   6          #include "Tips.h"
   7          #include "timerAct.h"
   8          #include "appTimer.h"
   9          #include "dataTrans.h"
  10          #include "dataManage.h"
  11          
  12          #include "eeprom.h"
  13          
  14          /**********************±¾µØÎÄ¼þ±äÁ¿¶¨ÒåÇø*****************************/
  15          status_ifSave   xdata relayStatus_ifSave = statusSave_disable;  //¿ª¹Ø¼ÇÒäÊ¹ÄÜ±äÁ¿
  16          u8                              xdata status_Relay               = 0;
  17          
  18          relay_Command   xdata swCommand_fromUsr  = {0, actionNull};
  19            
  20          u8                              xdata EACHCTRL_realesFLG = 0; //»¥¿Ø¶¯×÷¸üÐÂÊ¹ÄÜ±êÖ¾£¨·¢Âë£©±êÖ¾<bit0£ºÒ»Î»¿ª¹Ø»¥¿Ø¸üÐÂ; bit1£º¶þÎ»¿
             -ª¹Ø»¥¿Ø¸üÐÂ; bit2£ºÈýÎ»¿ª¹Ø»¥¿Ø¸üÐÂ;>
  21          bit                                       EACHCTRL_reportFLG = 0; //»¥¿Ø´¥·¢ºóÏòÍø¹ØÉÏ±¨×´Ì¬Ê¹ÄÜ
  22          
  23          relayStatus_PUSH xdata devActionPush_IF = {0};
  24          
  25          bit                             idata statusRelay_saveEn= 0; //¿ª¹ØÖµ±¾µØ´æ´¢Ê¹ÄÜ,Áé»îÊ¹ÓÃ,ÖØ¸´´æ´¢
  26          
  27          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              stt_Dimmer_attrFreq     xdata dimmer_freqParam          = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              stt_eleSocket_attrFreq xdata socket_eleDetParam = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
              stt_scenario_attrAct xdata scenario_ActParam = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
              stt_heater_attrAct xdata heater_ActParam = {0};
              #else
  36          stt_Curtain_motorAttr xdata curtainAct_Param = {0, CURTAIN_ORBITAL_PERIOD_INITTIME, cTact_stop}; //µ±Éè±¸¶
             -¨ÒåÎª´°Á±Ê±£¬¶ÔÓ¦¶¯×÷ÊôÐÔ£¬Ä¬ÈÏ¹ìµÀÊ±¼ä0s
  37          bit                               idata specialFlg_curtainEachctrlEn = 1;       //ÌØÊâ±êÊ¶Î»£¬´°Á±»¥¿ØÍ¬²½Ê¹ÄÜ£¬ÓÃÓÚÔÚ³¡¾°¿ØÖÆÏÂ½ûÖ¹´¥·¢
             -»¥¿Ø
  38          #endif
  39          
  40          /*¼ÌµçÆ÷×´Ì¬¸üÐÂ£¬Ó²¼þÖ´ÐÐ*/
  41          void relay_statusReales(void){
  42   1              
  43   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      switch(status_Relay){
                      
                              case 0:{
                              
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 0;
                              
                              }break;
                              
C51 COMPILER V9.54   RELAY                                                                 02/15/2019 15:28:06 PAGE 2   

                              case 1:{
                              
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 1;
                                      
                              }break;
                                      
                              case 2:{
                              
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 1;PIN_RELAY_3 = 0;
                                      
                              }break;
                                      
                              case 3:
                              default:{
                              
                                      PIN_RELAY_1 = 1;PIN_RELAY_2 = 0;PIN_RELAY_3 = 0;
                                      
                              }break;
                      }
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      (status_Relay)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      {
                              
                              bit scenarioTrigReserve_flg = 0;
                              
                              if((!scenario_ActParam.scenarioKeepTrig_timeCounter) || (scenario_ActParam.scenarioKeepTrig_timeCounter 
             -== COUNTER_DISENABLE_MASK_SPECIALVAL_U8)){ //²»Í¬³¡¾°´¥·¢Ç¿ÖÆ¼ä¸ôÊ±¼ä½áÊøºó²ÅÔÊÐí¶¯×÷
                              
                                      switch(status_Relay){
                                      
                                              case 1:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S1;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              case 2:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S2;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              case 4:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S3;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              default:{}break;
                                      }
                                      
                                      if(scenarioTrigReserve_flg){
                                      
                                              scenario_ActParam.scenarioKeepTrig_timeCounter = SCENARIOTRIG_KEEPTIME_PERIOD;
                                              scenario_ActParam.scenarioDataSend_FLG = 1;
C51 COMPILER V9.54   RELAY                                                                 02/15/2019 15:28:06 PAGE 3   

                                      }
                              }
                      }
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      switch(status_Relay){
              
                              case 0:{
                              
                                      PIN_RELAY_1 = PIN_RELAY_2 = 0;
                                      heater_ActParam.relayActDelay_counter = HEATER_RELAY_SYNCHRONIZATION_DELAYTIME; //´óÐ¡¼ÌµçÆ÷ÖÍºóÊ±¼äÉè¶
             -¨
                                      
                              }break;
                              
                              case 1:{
                              
                                      PIN_RELAY_1 = PIN_RELAY_2 = 1;
                                      heater_ActParam.relayActDelay_counter = HEATER_RELAY_SYNCHRONIZATION_DELAYTIME; //´óÐ¡¼ÌµçÆ÷ÖÍºóÊ±¼äÉè¶
             -¨
                              
                              }break;
                              
                              default:{
              
                                      
                              }break;
                      }
                      
              #else
 141   1              switch(SWITCH_TYPE){
 142   2                      
 143   2                      case SWITCH_TYPE_CURTAIN:{
 144   3                      
 145   3                              switch(status_Relay){
 146   4                              
 147   4                                      case 1:{
 148   5                                      
 149   5                                              PIN_RELAY_2 = 1;
 150   5                                              PIN_RELAY_1 = PIN_RELAY_3 = 0;
 151   5                                              curtainAct_Param.act = cTact_open;
 152   5                                              
 153   5                                      }break;
 154   4                                              
 155   4                                      case 4:{
 156   5                                      
 157   5                                              PIN_RELAY_1 = 1;
 158   5                                              PIN_RELAY_2 = PIN_RELAY_3 = 0;
 159   5                                              curtainAct_Param.act = cTact_close;
 160   5                                              
 161   5                                      }break;
 162   4                                              
 163   4                                      case 2:
 164   4                                      default:{
 165   5                                      
 166   5                                              PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
 167   5                                              curtainAct_Param.act = cTact_stop;
 168   5                                              
 169   5                                              if(curtainAct_Param.act != cTact_stop)coverEEPROM_write_n(EEPROM_ADDR_curtainOrbitalCnter, &(curtainA
             -ct_Param.act_counter), 1); //Ã¿´Î´°Á±ÔË¶¯Í£Ö¹Ê±£¬¼ÇÂ¼µ±Ç°Î»ÖÃ¶ÔÓ¦µÄ¹ìµÀÖÜÆÚ¼ÆÊ±Öµ
 170   5                                              
 171   5                                      }break;
C51 COMPILER V9.54   RELAY                                                                 02/15/2019 15:28:06 PAGE 4   

 172   4                              }
 173   3                      
 174   3                      }break;
 175   2              
 176   2                      case SWITCH_TYPE_SWBIT1:{ //¼ÌµçÆ÷Î»ÖÃµ÷Õû 2¶Ô1
 177   3                      
 178   3                              if(DEV_actReserve & 0x02)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 179   3                              
 180   3                      }break;
 181   2                      
 182   2                      case SWITCH_TYPE_SWBIT2:{ //¼ÌµçÆ÷Î»ÖÃµ÷Õû 3¶Ô2
 183   3                      
 184   3                              if(DEV_actReserve & 0x01)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 185   3                              if(DEV_actReserve & 0x04)(status_Relay & 0x02)?(PIN_RELAY_2 = 1):(PIN_RELAY_2 = 0);
 186   3                      
 187   3                      }break;
 188   2                      
 189   2                      case SWITCH_TYPE_SWBIT3:{ //¼ÌµçÆ÷Î»ÖÃ±£³Ö
 190   3                      
 191   3                              if(DEV_actReserve & 0x01)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 192   3                              if(DEV_actReserve & 0x02)(status_Relay & 0x02)?(PIN_RELAY_2 = 1):(PIN_RELAY_2 = 0);
 193   3                              if(DEV_actReserve & 0x04)(status_Relay & 0x04)?(PIN_RELAY_3 = 1):(PIN_RELAY_3 = 0);
 194   3                      
 195   3                      }break;
 196   2                      
 197   2                      default:break;
 198   2              }
 199   1      #endif  
 200   1              
 201   1              tips_statusChangeToNormal();
 202   1      }
 203          
 204          /*¿ª¹Ø³õÊ¼»¯*/
 205          void relay_pinInit(void){
 206   1              
 207   1              u8 idata statusTemp = 0;
 208   1              
 209   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      //ÍÆÍì
                      P3M1    &= ~0x30;
                      P3M0    |= 0x30;
                      PIN_RELAY_2 = PIN_PWM_OUT = 0;
                      
                      P3M1    |= 0x08;   //P33¹ý0ÖÐ¶Ï¼ì²â½Å
                      P3M0    &= ~0x08;
                  INT1 = 0;
                  IT1 = 1; 
                      PX1 = 0; //¸ßÓÅÏÈ¼¶
                  EX1 = 1;           
                      
                      statusRelay_saveEn = 1; //ÖØ¸´Ö÷¶¯¼ÇÒäµ±Ç°Æô¶¯Öµ£¬·ÀÖ¹¿ª¹ØÎ´²Ù×÷Çé¿öÏÂµÚÈý´ÎÉÏµçÆô¶¯Ê±¼ÇÒäÖµ¶ªÊ§
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      //ÍÆÍì
                      P3M1    &= ~0x38;
                      P3M0    |= 0x38;
                      PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      //ÍÆÍì
                      P3M1    &= ~0x08;
                      P3M0    |= 0x08;
C51 COMPILER V9.54   RELAY                                                                 02/15/2019 15:28:06 PAGE 5   

                      PIN_RELAY_1 = 0;
                      
                      //¸ß×èÈë
                      P3M1    |= 0xC0;
                      P3M0    &= ~0xC0;
                      INT_CLKO |=  (1 << 4); //Íâ²¿ÖÐ¶Ï2Ê¹ÄÜ
                      INT_CLKO |=  (1 << 5); //Íâ²¿ÖÐ¶Ï3Ê¹ÄÜ
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      //³¡¾°¿ª¹ØÃ»ÓÐ¼ÌµçÆ÷
                      //¼üÎ»°ó¶¨³¡¾°ºÅµôµç¼ÇÒä»Ö¸´
                      EEPROM_read_n(EEPROM_ADDR_swTypeForceScenario_scencarioNumKeyBind, scenario_ActParam.scenarioNum_record, 
             -3);
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      //ÍÆÍì
                      P3M1    &= ~0x38;
                      P3M0    |= 0x38;
                      PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
                      
              #elif(SWITCH_TYPE_FORCEDEF == 0)
 254   1              //ÍÆÍì
 255   1              P3M1    &= ~0x38;
 256   1              P3M0    |= 0x38;
 257   1              PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
 258   1              
 259   1              //´°Á±¹ìµÀÖÜÆÚ¼°Æä¶ÔÓ¦Î»ÖÃ¼ÆÊ±Öµ»Ö¸´
 260   1              EEPROM_read_n(EEPROM_ADDR_curtainOrbitalPeriod, &(curtainAct_Param.act_period), 1);
 261   1              if(curtainAct_Param.act_period == 0xff)curtainAct_Param.act_period = CURTAIN_ORBITAL_PERIOD_INITTIME; //Ö
             -µÏÞ¶¨        
 262   1              EEPROM_read_n(EEPROM_ADDR_curtainOrbitalCnter, &(curtainAct_Param.act_counter), 1);
 263   1              if(curtainAct_Param.act_counter == 0xff)curtainAct_Param.act_counter = 0; //ÖµÏÞ¶¨      
 264   1              
 265   1       #if(DEBUG_LOGOUT_EN == 1)
 266   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 267   2                      
 268   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 269   2                      sprintf(log_buf, ">>>curtain param recover orbitalPeriod:%d, placeCounter:%d\n", (int)curtainAct_Param.a
             -ct_period, (int)curtainAct_Param.act_counter);
 270   2                      PrintString1_logOut(log_buf);
 271   2              }                       
 272   1       #endif
 273   1      #else
                      
              #endif
 276   1              
 277   1              if(relayStatus_ifSave == statusSave_enable){
 278   2              
 279   2      #if(DATASAVE_INTLESS_ENABLEIF)
 280   2                      swCommand_fromUsr.objRelay = devDataRecovery_relayStatus();
 281   2      #else
                              EEPROM_read_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
                              swCommand_fromUsr.objRelay = statusTemp;
              #endif
 285   2                      swCommand_fromUsr.actMethod = relay_OnOff; //Ó²¼þ¼ÓÔØ
 286   2                      
 287   2              }else{
 288   2              
 289   2                      statusTemp = 0;
 290   2                      coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
 291   2                      relay_statusReales(); //Ó²¼þ¼ÓÔØ
 292   2              }
C51 COMPILER V9.54   RELAY                                                                 02/15/2019 15:28:06 PAGE 6   

 293   1      }
 294          
 295          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              void Ext_INT1 (void) interrupt INT1_VECTOR{
                      
                      dimmer_freqParam.periodBeat_cfm = dimmer_freqParam.periodBeat_counter;
                      dimmer_freqParam.periodBeat_counter = 0;
                      
                      dimmer_freqParam.pwm_actEN = 1;
              }
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              void Ext_INT2 (void) interrupt INT2_VECTOR{ //ÖÐ¶Ï2
                      
                      socket_eleDetParam.eleParamFun_powerPulseCount += 1.0F;
              }
              
              void Ext_INT3 (void) interrupt INT3_VECTOR{ //ÖÐ¶Ï3
                      
                      
              }
              #else
 314          #endif
 315          
 316          /*¿ª¹Ø¶¯×÷*/
 317          void relay_Act(relay_Command dats){
 318   1              
 319   1              u8 statusTemp = 0;
 320   1              
 321   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER) //ÈÎÒâÀàÐÍ¼ÓÔØ£¬²»Òª×Ô¶¯´æ´¢¼ÇÒä£¬ÒòÎª³¤°´°´¼üÁ¬Ðø¸ü¸ÄÁÁ¶È
             -Öµ¶¼½øÐÐ¼ÇÒäµÄ»°»°Ôì³ÉµÆ¹âÁÁ¶ÈÍ»±ä£¬³¤°´ÔÚ½áÊøÊ±½øÐÐ¼ÇÒä¼´¿É
                      status_Relay = dats.objRelay;
                      relay_statusReales();
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
                      dats = dats;
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      status_Relay = dats.objRelay;
                      relay_statusReales();
                      
              #else
 333   1              
 334   1              statusTemp = status_Relay; //µ±Ç°¿ª¹ØÖµÔÝ´æ
 335   1              
 336   1              switch(dats.actMethod){
 337   2              
 338   2                      case relay_flip:{ 
 339   3                              
 340   3                              if(dats.objRelay & 0x01)status_Relay ^= 1 << 0;
 341   3                              if(dats.objRelay & 0x02)status_Relay ^= 1 << 1;
 342   3                              if(dats.objRelay & 0x04)status_Relay ^= 1 << 2;
 343   3                                      
 344   3                      }break;
 345   2                      
 346   2                      case relay_OnOff:{
 347   3                              
 348   3                              (dats.objRelay & 0x01)?(status_Relay |= 1 << 0):(status_Relay &= ~(1 << 0));
 349   3                              (dats.objRelay & 0x02)?(status_Relay |= 1 << 1):(status_Relay &= ~(1 << 1));
 350   3                              (dats.objRelay & 0x04)?(status_Relay |= 1 << 2):(status_Relay &= ~(1 << 2));
 351   3                              
 352   3                      }break;
 353   2                      
C51 COMPILER V9.54   RELAY                                                                 02/15/2019 15:28:06 PAGE 7   

 354   2                      default:break;
 355   2                      
 356   2              }relay_statusReales(); //Ó²¼þ¼ÓÔØ
 357   1              
 358   1              devActionPush_IF.dats_Push = 0;
 359   1              devActionPush_IF.dats_Push |= (status_Relay & 0x07); //µ±Ç°¿ª¹ØÖµÎ»Ìî×°<µÍÈýÎ»>
 360   1              
 361   1      //      /*ÓÅÏÈ·½Ê½*/
 362   1      //      if(             (statusTemp & 0x01) != (status_Relay & 0x01))devActionPush_IF.dats_Push |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈý
             -Î»>µÚÒ»Î»
 363   1      //      else if((statusTemp & 0x02) != (status_Relay & 0x02))devActionPush_IF.dats_Push |= 0x40; //¸ü¸ÄÖµÌî×°<¸
             -ßÈýÎ»>µÚ¶þÎ»
 364   1      //      else if((statusTemp & 0x04) != (status_Relay & 0x04))devActionPush_IF.dats_Push |= 0x80; //¸ü¸ÄÖµÌî×°<¸
             -ßÈýÎ»>µÚÈýÎ»
 365   1              /*·ÇÓÅÏÈ·½Ê½*/
 366   1              if((statusTemp & 0x01) != (status_Relay & 0x01))devActionPush_IF.dats_Push |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÒ»Î»
 367   1              if((statusTemp & 0x02) != (status_Relay & 0x02))devActionPush_IF.dats_Push |= 0x40; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -Ú¶þÎ»
 368   1              if((statusTemp & 0x04) != (status_Relay & 0x04))devActionPush_IF.dats_Push |= 0x80; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÈýÎ»
 369   1              
 370   1              if(status_Relay)delayCnt_closeLoop = 0; //¿ª¹ØÒ»µ©´ò¿ªÁ¢¿Ì¸üÐÂÂÌÉ«Ä£Ê½Ê±¼ä¼ÆÊýÖµ
 371   1              
 372   1              if(relayStatus_ifSave == statusSave_enable){ /*Ã¿´Î¸ü¸Ä¿ª¹ØÖµÊ±¶¼½øÐÐ´æ´¢¼ÇÒä*///¿ª¹Ø×´Ì¬´æ´¢×Ô¶¯±»¶¯¼ÇÒä
 373   2              
 374   2       #if(DATASAVE_INTLESS_ENABLEIF)
 375   2                      devParamDtaaSave_relayStatusRealTime(status_Relay);
 376   2       #else
                              statusTemp = status_Relay;
                              coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
               #endif
 380   2              }
 381   1              
 382   1      #endif
 383   1      }
 384          
 385          /*¼ÌµçÆ÷Ö÷Ïß³Ì*/
 386          void thread_Relay(void){
 387   1              
 388   1              if(swCommand_fromUsr.actMethod != actionNull){ //ÇëÇóÏìÓ¦
 389   2              
 390   2                      relay_Act(swCommand_fromUsr);
 391   2                      
 392   2                      swCommand_fromUsr.actMethod = actionNull;
 393   2                      swCommand_fromUsr.objRelay = 0;
 394   2              }
 395   1              
 396   1              if(statusRelay_saveEn){ /*Ö÷¶¯¼ÇÒäÊ¹ÄÜÅÐ¶Ï*///¿ª¹Ø×´Ì¬´æ´¢Ö÷¶¯¼ÇÒä
 397   2              
 398   2                      u8 idata statusTemp = 0;
 399   2                      
 400   2                      statusRelay_saveEn = 0;
 401   2                      
 402   2      //#if(DEBUG_LOGOUT_EN == 1)
 403   2      //              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 404   2      //                      
 405   2      //                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 406   2      //                      sprintf(log_buf, ">>>statusVal save cmp.\n");
 407   2      //                      PrintString1_logOut(log_buf);
 408   2      //              }                       
 409   2      //#endif
C51 COMPILER V9.54   RELAY                                                                 02/15/2019 15:28:06 PAGE 8   

 410   2              
 411   2                      if(relayStatus_ifSave == statusSave_enable){ 
 412   3              
 413   3      #if(DATASAVE_INTLESS_ENABLEIF)
 414   3                              devParamDtaaSave_relayStatusRealTime(status_Relay);
 415   3      #else
                                      statusTemp = status_Relay;
                                      coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
              #endif
 419   3                      }
 420   2              }
 421   1              
 422   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      if(heater_ActParam.relayActDelay_actEn){ //Í¬²½´¥·¢±êÖ¾Î»ÏìÓ¦
                      
                              heater_ActParam.relayActDelay_actEn = 0;
                              PIN_RELAY_3 = PIN_RELAY_1; //ÈÈË®Æ÷¼ÌµçÆ÷µçÆ½Í¬²½¶¯×÷´¥·¢
                      }
                      
                      if(heater_ActParam.heater_currentActMode == heaterActMode_swClose){ //²¹³¥ÏìÓ¦£¬±ÜÃâÓÐÊ±ºòÖ¸Ê¾µÆÏìÓ¦ÁËµ«¼
             -ÌµçÆ÷Ã»ÏìÓ¦
                      
                              if((status_Relay & (1 << 0)) != 0){
                              
                                      swCommand_fromUsr.objRelay = 0;
                                      swCommand_fromUsr.actMethod = relay_OnOff; //¿ª¹Ø¶¯×÷
                              }
                      }
                      
              #else
 439   1      #endif
 440   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    665    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----       2
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
