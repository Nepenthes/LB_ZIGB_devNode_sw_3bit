C51 COMPILER V9.54   RELAY                                                                 01/11/2019 12:04:14 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE RELAY
OBJECT MODULE PLACED IN .\Output\Relay.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Actuator\Relay.c OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\
                    -std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\Relay.lst) OBJECT(.\Output\Relay.obj)

line level    source

   1          #include "Relay.h"
   2          
   3          #include "string.h"
   4          #include "stdio.h"
   5          
   6          #include "Tips.h"
   7          #include "timerAct.h"
   8          #include "appTimer.h"
   9          #include "dataTrans.h"
  10          #include "dataManage.h"
  11          
  12          #include "eeprom.h"
  13          
  14          /**********************±¾µØÎÄ¼þ±äÁ¿¶¨ÒåÇø*****************************/
  15          status_ifSave   xdata relayStatus_ifSave = statusSave_disable;  //¿ª¹Ø¼ÇÒäÊ¹ÄÜ±äÁ¿
  16          u8                              xdata status_Relay               = 0;
  17          
  18          relay_Command   xdata swCommand_fromUsr  = {0, actionNull};
  19            
  20          u8                              xdata EACHCTRL_realesFLG = 0; //»¥¿Ø¶¯×÷¸üÐÂÊ¹ÄÜ±êÖ¾£¨·¢Âë£©±êÖ¾<bit0£ºÒ»Î»¿ª¹Ø»¥¿Ø¸üÐÂ; bit1£º¶þÎ»¿
             -ª¹Ø»¥¿Ø¸üÐÂ; bit2£ºÈýÎ»¿ª¹Ø»¥¿Ø¸üÐÂ;>
  21          bit                                       EACHCTRL_reportFLG = 0; //»¥¿Ø´¥·¢ºóÏòÍø¹ØÉÏ±¨×´Ì¬Ê¹ÄÜ
  22          
  23          relayStatus_PUSH xdata devActionPush_IF = {0};
  24          
  25          bit                             idata statusRelay_saveEn= 0; //¿ª¹ØÖµ±¾µØ´æ´¢Ê¹ÄÜ,Áé»îÊ¹ÓÃ,ÖØ¸´´æ´¢
  26          
  27          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              stt_Dimmer_attrFreq     xdata dimmer_freqParam          = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              stt_eleSocket_attrFreq xdata socket_eleDetParam = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
              stt_scenario_attrAct xdata scenario_ActParam = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
              stt_heater_attrAct xdata heater_ActParam = {0};
              #else
  36          stt_Curtain_motorAttr xdata curtainAct_Param = {0, CURTAIN_ORBITAL_PERIOD_INITTIME, cTact_stop}; //µ±Éè±¸¶
             -¨ÒåÎª´°Á±Ê±£¬¶ÔÓ¦¶¯×÷ÊôÐÔ£¬Ä¬ÈÏ¹ìµÀÊ±¼ä0s
  37          #endif
  38          
  39          /*¼ÌµçÆ÷×´Ì¬¸üÐÂ£¬Ó²¼þÖ´ÐÐ*/
  40          void relay_statusReales(void){
  41   1              
  42   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      switch(status_Relay){
                      
                              case 0:{
                              
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 0;
                              
                              }break;
                              
                              case 1:{
                              
C51 COMPILER V9.54   RELAY                                                                 01/11/2019 12:04:14 PAGE 2   

                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 1;
                                      
                              }break;
                                      
                              case 2:{
                              
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 1;PIN_RELAY_3 = 0;
                                      
                              }break;
                                      
                              case 3:
                              default:{
                              
                                      PIN_RELAY_1 = 1;PIN_RELAY_2 = 0;PIN_RELAY_3 = 0;
                                      
                              }break;
                      }
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      (status_Relay)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      {
                              
                              bit scenarioTrigReserve_flg = 0;
                              
                              if((!scenario_ActParam.scenarioKeepTrig_timeCounter) || (scenario_ActParam.scenarioKeepTrig_timeCounter 
             -== COUNTER_DISENABLE_MASK_SPECIALVAL_U8)){ //²»Í¬³¡¾°´¥·¢Ç¿ÖÆ¼ä¸ôÊ±¼ä½áÊøºó²ÅÔÊÐí¶¯×÷
                              
                                      switch(status_Relay){
                                      
                                              case 1:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S1;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              case 2:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S2;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              case 4:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S3;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              default:{}break;
                                      }
                                      
                                      if(scenarioTrigReserve_flg){
                                      
                                              scenario_ActParam.scenarioKeepTrig_timeCounter = SCENARIOTRIG_KEEPTIME_PERIOD;
                                              scenario_ActParam.scenarioDataSend_FLG = 1;
                                      }
                              }
C51 COMPILER V9.54   RELAY                                                                 01/11/2019 12:04:14 PAGE 3   

                      }
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      switch(status_Relay){
              
                              case 0:{
                              
                                      PIN_RELAY_1 = 0;
                                      heater_ActParam.relayActDelay_counter = HEATER_RELAY_SYNCHRONIZATION_DELAYTIME; //´óÐ¡¼ÌµçÆ÷ÖÍºóÊ±¼äÉè¶
             -¨
                                      
                              }break;
                              
                              case 1:{
                              
                                      PIN_RELAY_1 = 1;
                                      heater_ActParam.relayActDelay_counter = HEATER_RELAY_SYNCHRONIZATION_DELAYTIME; //´óÐ¡¼ÌµçÆ÷ÖÍºóÊ±¼äÉè¶
             -¨
                              
                              }break;
                              
                              default:{
              
                                      
                              }break;
                      }
                      
                      PIN_RELAY_2 = 0;
                      
              #else
 142   1              switch(SWITCH_TYPE){
 143   2                      
 144   2                      case SWITCH_TYPE_CURTAIN:{
 145   3                      
 146   3                              switch(status_Relay){
 147   4                              
 148   4                                      case 1:{
 149   5                                      
 150   5                                              PIN_RELAY_2 = 1;
 151   5                                              PIN_RELAY_1 = PIN_RELAY_3 = 0;
 152   5                                              curtainAct_Param.act = cTact_open;
 153   5                                              
 154   5                                      }break;
 155   4                                              
 156   4                                      case 4:{
 157   5                                      
 158   5                                              PIN_RELAY_1 = 1;
 159   5                                              PIN_RELAY_2 = PIN_RELAY_3 = 0;
 160   5                                              curtainAct_Param.act = cTact_close;
 161   5                                              
 162   5                                      }break;
 163   4                                              
 164   4                                      case 2:
 165   4                                      default:{
 166   5                                      
 167   5                                              PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
 168   5                                              curtainAct_Param.act = cTact_stop;
 169   5                                              
 170   5                                              coverEEPROM_write_n(EEPROM_ADDR_curtainOrbitalCnter, &(curtainAct_Param.act_counter), 1); //Ã¿´Î´°Á±Ô
             -Ë¶¯Í£Ö¹Ê±£¬¼ÇÂ¼µ±Ç°Î»ÖÃ¶ÔÓ¦µÄ¹ìµÀÖÜÆÚ¼ÆÊ±Öµ
 171   5                                              
 172   5                                      }break;
C51 COMPILER V9.54   RELAY                                                                 01/11/2019 12:04:14 PAGE 4   

 173   4                              }
 174   3                      
 175   3                      }break;
 176   2              
 177   2                      case SWITCH_TYPE_SWBIT1:{ //¼ÌµçÆ÷Î»ÖÃµ÷Õû 2¶Ô1
 178   3                      
 179   3                              if(DEV_actReserve & 0x02)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 180   3                              
 181   3                      }break;
 182   2                      
 183   2                      case SWITCH_TYPE_SWBIT2:{ //¼ÌµçÆ÷Î»ÖÃµ÷Õû 3¶Ô2
 184   3                      
 185   3                              if(DEV_actReserve & 0x01)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 186   3                              if(DEV_actReserve & 0x04)(status_Relay & 0x02)?(PIN_RELAY_2 = 1):(PIN_RELAY_2 = 0);
 187   3                      
 188   3                      }break;
 189   2                      
 190   2                      case SWITCH_TYPE_SWBIT3:{ //¼ÌµçÆ÷Î»ÖÃ±£³Ö
 191   3                      
 192   3                              if(DEV_actReserve & 0x01)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 193   3                              if(DEV_actReserve & 0x02)(status_Relay & 0x02)?(PIN_RELAY_2 = 1):(PIN_RELAY_2 = 0);
 194   3                              if(DEV_actReserve & 0x04)(status_Relay & 0x04)?(PIN_RELAY_3 = 1):(PIN_RELAY_3 = 0);
 195   3                      
 196   3                      }break;
 197   2                      
 198   2                      default:break;
 199   2              }
 200   1      #endif  
 201   1              
 202   1              tips_statusChangeToNormal();
 203   1      }
 204          
 205          /*¿ª¹Ø³õÊ¼»¯*/
 206          void relay_pinInit(void){
 207   1              
 208   1              u8 idata statusTemp = 0;
 209   1              
 210   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      //ÍÆÍì
                      P3M1    &= ~0x30;
                      P3M0    |= 0x30;
                      PIN_RELAY_2 = PIN_PWM_OUT = 0;
                      
                      P3M1    |= 0x08;   //P33¹ý0ÖÐ¶Ï¼ì²â½Å
                      P3M0    &= ~0x08;
                  INT1 = 0;
                  IT1 = 1; 
                      PX1 = 0; //¸ßÓÅÏÈ¼¶
                  EX1 = 1;           
                      
                      statusRelay_saveEn = 1; //ÖØ¸´Ö÷¶¯¼ÇÒäµ±Ç°Æô¶¯Öµ£¬·ÀÖ¹¿ª¹ØÎ´²Ù×÷Çé¿öÏÂµÚÈý´ÎÉÏµçÆô¶¯Ê±¼ÇÒäÖµ¶ªÊ§
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      //ÍÆÍì
                      P3M1    &= ~0x08;
                      P3M0    |= 0x08;
                      PIN_RELAY_1 = 0;
                      
                      //¸ß×èÈë
                      P3M1    |= 0xC0;
                      P3M0    &= ~0xC0;
                      INT_CLKO |=  (1 << 4); //Íâ²¿ÖÐ¶Ï2Ê¹ÄÜ
C51 COMPILER V9.54   RELAY                                                                 01/11/2019 12:04:14 PAGE 5   

                      INT_CLKO |=  (1 << 5); //Íâ²¿ÖÐ¶Ï3Ê¹ÄÜ
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      //³¡¾°¿ª¹ØÃ»ÓÐ¼ÌµçÆ÷
                      //¼üÎ»°ó¶¨³¡¾°ºÅµôµç¼ÇÒä»Ö¸´
                      EEPROM_read_n(EEPROM_ADDR_swTypeForceScenario_scencarioNumKeyBind, scenario_ActParam.scenarioNum_record, 
             -3);
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      //ÍÆÍì
                      P3M1    &= ~0x38;
                      P3M0    |= 0x38;
                      PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
                      
              #elif(SWITCH_TYPE_FORCEDEF == 0)
 249   1              //ÍÆÍì
 250   1              P3M1    &= ~0x38;
 251   1              P3M0    |= 0x38;
 252   1              PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
 253   1              
 254   1              //´°Á±¹ìµÀÖÜÆÚ¼°Æä¶ÔÓ¦Î»ÖÃ¼ÆÊ±Öµ»Ö¸´
 255   1              EEPROM_read_n(EEPROM_ADDR_curtainOrbitalPeriod, &(curtainAct_Param.act_period), 1);
 256   1              if(curtainAct_Param.act_period == 0xff)curtainAct_Param.act_period = CURTAIN_ORBITAL_PERIOD_INITTIME; //Ö
             -µÏÞ¶¨        
 257   1              EEPROM_read_n(EEPROM_ADDR_curtainOrbitalCnter, &(curtainAct_Param.act_counter), 1);
 258   1              if(curtainAct_Param.act_counter == 0xff)curtainAct_Param.act_counter = 0; //ÖµÏÞ¶¨      
 259   1              
 260   1       #if(DEBUG_LOGOUT_EN == 1)
 261   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 262   2                      
 263   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 264   2                      sprintf(log_buf, ">>>curtain param recover orbitalPeriod:%d, placeCounter:%d\n", (int)curtainAct_Param.a
             -ct_period, (int)curtainAct_Param.act_counter);
 265   2                      PrintString1_logOut(log_buf);
 266   2              }                       
 267   1       #endif
 268   1      #else
                      
              #endif
 271   1              
 272   1              if(relayStatus_ifSave == statusSave_enable){
 273   2              
 274   2      #if(DATASAVE_INTLESS_ENABLEIF)
 275   2                      swCommand_fromUsr.objRelay = devDataRecovery_relayStatus();
 276   2      #else
                              EEPROM_read_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
                              swCommand_fromUsr.objRelay = statusTemp;
              #endif
 280   2                      swCommand_fromUsr.actMethod = relay_OnOff; //Ó²¼þ¼ÓÔØ
 281   2                      
 282   2              }else{
 283   2              
 284   2                      statusTemp = 0;
 285   2                      coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
 286   2                      relay_statusReales(); //Ó²¼þ¼ÓÔØ
 287   2              }
 288   1      }
 289          
 290          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              void Ext_INT1 (void) interrupt INT1_VECTOR{
                      
                      dimmer_freqParam.periodBeat_cfm = dimmer_freqParam.periodBeat_counter;
C51 COMPILER V9.54   RELAY                                                                 01/11/2019 12:04:14 PAGE 6   

                      dimmer_freqParam.periodBeat_counter = 0;
                      
                      dimmer_freqParam.pwm_actEN = 1;
              }
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              void Ext_INT2 (void) interrupt INT2_VECTOR{ //ÖÐ¶Ï2
                      
                      socket_eleDetParam.eleParamFun_powerPulseCount += 1.0F;
              }
              
              void Ext_INT3 (void) interrupt INT3_VECTOR{ //ÖÐ¶Ï3
                      
                      
              }
              #else
 309          #endif
 310          
 311          /*¿ª¹Ø¶¯×÷*/
 312          void relay_Act(relay_Command dats){
 313   1              
 314   1              u8 statusTemp = 0;
 315   1              
 316   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER) //ÈÎÒâÀàÐÍ¼ÓÔØ£¬²»Òª×Ô¶¯´æ´¢¼ÇÒä£¬ÒòÎª³¤°´°´¼üÁ¬Ðø¸ü¸ÄÁÁ¶È
             -Öµ¶¼½øÐÐ¼ÇÒäµÄ»°»°Ôì³ÉµÆ¹âÁÁ¶ÈÍ»±ä£¬³¤°´ÔÚ½áÊøÊ±½øÐÐ¼ÇÒä¼´¿É
                      status_Relay = dats.objRelay;
                      relay_statusReales();
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
                      dats = dats;
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      status_Relay = dats.objRelay;
                      relay_statusReales();
                      
              #else
 328   1              
 329   1              statusTemp = status_Relay; //µ±Ç°¿ª¹ØÖµÔÝ´æ
 330   1              
 331   1              switch(dats.actMethod){
 332   2              
 333   2                      case relay_flip:{ 
 334   3                              
 335   3                              if(dats.objRelay & 0x01)status_Relay ^= 1 << 0;
 336   3                              if(dats.objRelay & 0x02)status_Relay ^= 1 << 1;
 337   3                              if(dats.objRelay & 0x04)status_Relay ^= 1 << 2;
 338   3                                      
 339   3                      }break;
 340   2                      
 341   2                      case relay_OnOff:{
 342   3                              
 343   3                              (dats.objRelay & 0x01)?(status_Relay |= 1 << 0):(status_Relay &= ~(1 << 0));
 344   3                              (dats.objRelay & 0x02)?(status_Relay |= 1 << 1):(status_Relay &= ~(1 << 1));
 345   3                              (dats.objRelay & 0x04)?(status_Relay |= 1 << 2):(status_Relay &= ~(1 << 2));
 346   3                              
 347   3                      }break;
 348   2                      
 349   2                      default:break;
 350   2                      
 351   2              }relay_statusReales(); //Ó²¼þ¼ÓÔØ
 352   1              
 353   1              devActionPush_IF.dats_Push = 0;
 354   1              devActionPush_IF.dats_Push |= (status_Relay & 0x07); //µ±Ç°¿ª¹ØÖµÎ»Ìî×°<µÍÈýÎ»>
C51 COMPILER V9.54   RELAY                                                                 01/11/2019 12:04:14 PAGE 7   

 355   1              
 356   1      //      /*ÓÅÏÈ·½Ê½*/
 357   1      //      if(             (statusTemp & 0x01) != (status_Relay & 0x01))devActionPush_IF.dats_Push |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈý
             -Î»>µÚÒ»Î»
 358   1      //      else if((statusTemp & 0x02) != (status_Relay & 0x02))devActionPush_IF.dats_Push |= 0x40; //¸ü¸ÄÖµÌî×°<¸
             -ßÈýÎ»>µÚ¶þÎ»
 359   1      //      else if((statusTemp & 0x04) != (status_Relay & 0x04))devActionPush_IF.dats_Push |= 0x80; //¸ü¸ÄÖµÌî×°<¸
             -ßÈýÎ»>µÚÈýÎ»
 360   1              /*·ÇÓÅÏÈ·½Ê½*/
 361   1              if((statusTemp & 0x01) != (status_Relay & 0x01))devActionPush_IF.dats_Push |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÒ»Î»
 362   1              if((statusTemp & 0x02) != (status_Relay & 0x02))devActionPush_IF.dats_Push |= 0x40; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -Ú¶þÎ»
 363   1              if((statusTemp & 0x04) != (status_Relay & 0x04))devActionPush_IF.dats_Push |= 0x80; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÈýÎ»
 364   1              
 365   1              if(status_Relay)delayCnt_closeLoop = 0; //¿ª¹ØÒ»µ©´ò¿ªÁ¢¿Ì¸üÐÂÂÌÉ«Ä£Ê½Ê±¼ä¼ÆÊýÖµ
 366   1              
 367   1              if(relayStatus_ifSave == statusSave_enable){ /*Ã¿´Î¸ü¸Ä¿ª¹ØÖµÊ±¶¼½øÐÐ´æ´¢¼ÇÒä*///¿ª¹Ø×´Ì¬´æ´¢×Ô¶¯±»¶¯¼ÇÒä
 368   2              
 369   2       #if(DATASAVE_INTLESS_ENABLEIF)
 370   2                      devParamDtaaSave_relayStatusRealTime(status_Relay);
 371   2       #else
                              statusTemp = status_Relay;
                              coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
               #endif
 375   2              }
 376   1              
 377   1      #endif
 378   1      }
 379          
 380          /*¼ÌµçÆ÷Ö÷Ïß³Ì*/
 381          void thread_Relay(void){
 382   1              
 383   1              if(swCommand_fromUsr.actMethod != actionNull){ //ÇëÇóÏìÓ¦
 384   2              
 385   2                      relay_Act(swCommand_fromUsr);
 386   2                      
 387   2                      swCommand_fromUsr.actMethod = actionNull;
 388   2                      swCommand_fromUsr.objRelay = 0;
 389   2              }
 390   1              
 391   1              if(statusRelay_saveEn){ /*Ö÷¶¯¼ÇÒäÊ¹ÄÜÅÐ¶Ï*///¿ª¹Ø×´Ì¬´æ´¢Ö÷¶¯¼ÇÒä
 392   2              
 393   2                      u8 idata statusTemp = 0;
 394   2                      
 395   2                      statusRelay_saveEn = 0;
 396   2                      
 397   2      //#if(DEBUG_LOGOUT_EN == 1)
 398   2      //              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 399   2      //                      
 400   2      //                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 401   2      //                      sprintf(log_buf, ">>>statusVal save cmp.\n");
 402   2      //                      PrintString1_logOut(log_buf);
 403   2      //              }                       
 404   2      //#endif
 405   2              
 406   2                      if(relayStatus_ifSave == statusSave_enable){ 
 407   3              
 408   3      #if(DATASAVE_INTLESS_ENABLEIF)
 409   3                              devParamDtaaSave_relayStatusRealTime(status_Relay);
 410   3      #else
C51 COMPILER V9.54   RELAY                                                                 01/11/2019 12:04:14 PAGE 8   

                                      statusTemp = status_Relay;
                                      coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
              #endif
 414   3                      }
 415   2              }
 416   1              
 417   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      if(heater_ActParam.relayActDelay_actEn){
                      
                              heater_ActParam.relayActDelay_actEn = 0;
                              PIN_RELAY_3 = PIN_RELAY_1; //ÈÈË®Æ÷¼ÌµçÆ÷µçÆ½Í¬²½¶¯×÷´¥·¢
                      }
                      
              #else
 425   1      #endif
 426   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    660    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----       2
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
