C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE RELAY
OBJECT MODULE PLACED IN .\Output\Relay.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Actuator\Relay.c OMF2 OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Usr;.\Usr_lib;.\s
                    -td_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\Relay.lst) OBJECT(.\Output\Relay.obj)

line level    source

   1          #include "Relay.h"
   2          
   3          #include "string.h"
   4          #include "stdio.h"
   5          
   6          #include "Tips.h"
   7          #include "timerAct.h"
   8          #include "appTimer.h"
   9          #include "dataTrans.h"
  10          #include "dataManage.h"
  11          
  12          #include "eeprom.h"
  13          
  14          /**********************±¾µØÎÄ¼þ±äÁ¿¶¨ÒåÇø*****************************/
  15          status_ifSave   xdata relayStatus_ifSave = statusSave_disable;  //¿ª¹Ø¼ÇÒäÊ¹ÄÜ±äÁ¿
  16          u8                              xdata status_Relay               = 0;
  17          
  18          relay_Command   xdata swCommand_fromUsr  = {0, actionNull};
  19            
  20          u8                              xdata EACHCTRL_realesFLG = 0; //»¥¿Ø¶¯×÷¸üÐÂÊ¹ÄÜ±êÖ¾£¨·¢Âë£©±êÖ¾<bit0£ºÒ»Î»¿ª¹Ø»¥¿Ø¸üÐÂ; bit1£º¶þÎ»¿
             -ª¹Ø»¥¿Ø¸üÐÂ; bit2£ºÈýÎ»¿ª¹Ø»¥¿Ø¸üÐÂ;>
  21          bit                                       EACHCTRL_reportFLG = 0; //»¥¿Ø´¥·¢ºóÏòÍø¹ØÉÏ±¨×´Ì¬Ê¹ÄÜ
  22          
  23          relayStatus_PUSH xdata devActionPush_IF = {0};
  24          
  25          bit                             idata statusRelay_saveEn= 0; //¿ª¹ØÖµ±¾µØ´æ´¢Ê¹ÄÜ,Áé»îÊ¹ÓÃ,ÖØ¸´´æ´¢
  26          
  27          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              stt_Dimmer_attrFreq     xdata dimmer_freqParam          = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
               #if(SWITCHFANS_SPECIAL_VERSION_IMPACT == 1)                    
                u16 xdata fansInpactTimeCounter = COUNTER_DISENABLE_MASK_SPECIALVAL_U16;
               #endif
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              stt_eleSocket_attrFreq xdata socket_eleDetParam = {0};
               #if(SWITCH_TYPE_SOCKETS_SPECIFICATION == SOCKETS_SPECIFICATION_BRITISH)
                float xdata pinFP_stdby_powerCNT = 1.0F; //¹¦ÂÊÂö³åÔ¤²â¼ÆÊýÖµ
                float xdata pinFP_powerStdby = 1.0F;  //¹¦ÂÊ Ô¤¼ì²âÆµÂÊÖµ 1ÃëÖÜÆÚ
               #endif
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
              stt_scenario_attrAct xdata scenario_ActParam = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
              stt_heater_attrAct xdata heater_ActParam = {0};
              #else
  44          stt_Curtain_motorAttr xdata curtainAct_Param = {0, CURTAIN_ORBITAL_PERIOD_INITTIME, cTact_stop}; //µ±Éè±¸¶
             -¨ÒåÎª´°Á±Ê±£¬¶ÔÓ¦¶¯×÷ÊôÐÔ£¬Ä¬ÈÏ¹ìµÀÊ±¼ä0s
  45          bit                               idata specialFlg_curtainEachctrlEn = 1;       //ÌØÊâ±êÊ¶Î»£¬´°Á±»¥¿ØÍ¬²½Ê¹ÄÜ£¬ÓÃÓÚÔÚ³¡¾°¿ØÖÆÏÂ½ûÖ¹´¥·¢
             -»¥¿Ø
  46          #endif
  47          
  48          /*¼ÌµçÆ÷×´Ì¬¸üÐÂ£¬Ó²¼þÖ´ÐÐ*/
  49          void relay_statusReales(void){
  50   1              
  51   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 2   

                      switch(status_Relay){
                      
                              case 0:{
              
               #if(SWITCHFANS_SPECIAL_VERSION_IMPACT == 1)                    
                                      fansInpactTimeCounter = COUNTER_DISENABLE_MASK_SPECIALVAL_U16; //Ê¹ÑÓÊ±²Ù×÷Ê§Ð§
               #endif
                                      
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 0;
                              
                              }break;
                              
                              case 1:{
              
               #if(SWITCHFANS_SPECIAL_VERSION_IMPACT == 1)
                                      if((!PIN_RELAY_1) && !(PIN_RELAY_2)){
                                              
                                              PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 1;
                                      
                                              PIN_RELAY_1 = 1;
                                              fansInpactTimeCounter = 1500;  //Ò»µµ½øÐÐ¸ßµµÎ»³å»÷£¬³å»÷Ê±¼äÉè¶¨
                                              
                                      }
                                      else
                                      {
                                              fansInpactTimeCounter = COUNTER_DISENABLE_MASK_SPECIALVAL_U16; //Ê¹ÑÓÊ±²Ù×÷Ê§Ð§
                                              
                                              PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 1;
                                      }
                                      
               #else  
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 1;
                                      
               #endif
                                      
                              }break;
                                      
                              case 2:{
                      
               #if(SWITCHFANS_SPECIAL_VERSION_IMPACT == 1)                                            
                                      fansInpactTimeCounter = COUNTER_DISENABLE_MASK_SPECIALVAL_U16; //Ê¹ÑÓÊ±²Ù×÷Ê§Ð§
               #endif 
                                      
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 1;PIN_RELAY_3 = 0;
                                      
                              }break;
                                      
                              case 3:
                              default:{
                      
               #if(SWITCHFANS_SPECIAL_VERSION_IMPACT == 1)                                            
                                      fansInpactTimeCounter = COUNTER_DISENABLE_MASK_SPECIALVAL_U16; //Ê¹ÑÓÊ±²Ù×÷Ê§Ð§
               #endif 
                                      
                                      PIN_RELAY_1 = 1;PIN_RELAY_2 = 0;PIN_RELAY_3 = 0;
                                      
                              }break;
                      }
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      (status_Relay)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 3   

               #if(SWITCH_TYPE_SOCKETS_SPECIFICATION == SOCKETS_SPECIFICATION_BRITISH)
                      if(status_Relay){ //segÌáÊ¾µÆ
                      
                              dev_segTips = segMode_touchOpen;
                              tipsSeg_INTFLG = 1;
                              
                      }else{
                      
                              dev_segTips = segMode_touchClose;
                              tipsSeg_INTFLG = 1;
                      }
               #endif
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      {
                              
                              bit scenarioTrigReserve_flg = 0;
                              
                              if((!scenario_ActParam.scenarioKeepTrig_timeCounter) || (scenario_ActParam.scenarioKeepTrig_timeCounter 
             -== COUNTER_DISENABLE_MASK_SPECIALVAL_U8)){ //²»Í¬³¡¾°´¥·¢Ç¿ÖÆ¼ä¸ôÊ±¼ä½áÊøºó²ÅÔÊÐí¶¯×÷
                              
                                      switch(status_Relay){
                                      
                                              case 1:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S1;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              case 2:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S2;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              case 4:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S3;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              default:{}break;
                                      }
                                      
                                      if(scenarioTrigReserve_flg){
                                      
                                              scenario_ActParam.scenarioKeepTrig_timeCounter = SCENARIOTRIG_KEEPTIME_PERIOD;
                                              scenario_ActParam.scenarioDataSend_FLG = 1;
                                      }
                              }
                      }
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      switch(status_Relay){
              
                              case 0:{
                              
                                      PIN_RELAY_1 = PIN_RELAY_2 = 0;
                                      heater_ActParam.relayActDelay_counter = HEATER_RELAY_SYNCHRONIZATION_DELAYTIME; //´óÐ¡¼ÌµçÆ÷ÖÍºóÊ±¼äÉè¶
C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 4   

             -¨
                                      
                              }break;
                              
                              case 1:{
                              
                                      PIN_RELAY_1 = PIN_RELAY_2 = 1;
                                      heater_ActParam.relayActDelay_counter = HEATER_RELAY_SYNCHRONIZATION_DELAYTIME; //´óÐ¡¼ÌµçÆ÷ÖÍºóÊ±¼äÉè¶
             -¨
                              
                              }break;
                              
                              default:{
              
                                      
                              }break;
                      }
                      
              #else
 192   1              switch(SWITCH_TYPE){
 193   2                      
 194   2                      case SWITCH_TYPE_CURTAIN:{
 195   3                      
 196   3                              switch(status_Relay){
 197   4                              
 198   4                                      case 1:{
 199   5                                              
 200   5                                                      PIN_RELAY_2 = 1;
 201   5                                                      PIN_RELAY_1 = PIN_RELAY_3 = 0;
 202   5                                                      curtainAct_Param.act = cTact_open;
 203   5                                      }break;
 204   4                                              
 205   4                                      case 4:{
 206   5                              
 207   5                                                      PIN_RELAY_1 = 1;
 208   5                                                      PIN_RELAY_2 = PIN_RELAY_3 = 0;
 209   5                                                      curtainAct_Param.act = cTact_close;
 210   5                                      }break;
 211   4                                              
 212   4                                      case 2:
 213   4                                      default:{
 214   5                                              
 215   5                                              static u8 xdata curtainActCounter_record = 0;
 216   5                                      
 217   5                                              PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
 218   5                                              if(curtainAct_Param.act != cTact_stop)curtainAct_Param.act = cTact_stop;
 219   5                                              
 220   5                                              if(curtainActCounter_record != curtainAct_Param.act_counter){ //±ÜÃâÖØ¸´¼ÇÒäµ¼ÖÂµÆ¹âÉÁË¸
 221   6                                              
 222   6                                                      curtainActCounter_record = curtainAct_Param.act_counter;
 223   6                                                      
 224   6                                                      coverEEPROM_write_n(EEPROM_ADDR_curtainOrbitalCnter, &(curtainAct_Param.act_counter), 1); //Ã¿´Î´°Á±
             -ÔË¶¯Í£Ö¹Ê±£¬¼ÇÂ¼µ±Ç°Î»ÖÃ¶ÔÓ¦µÄ¹ìµÀÖÜÆÚ¼ÆÊ±Öµ
 225   6                                              }
 226   5                                              
 227   5      //#if(DEBUG_LOGOUT_EN == 1)
 228   5      //                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 229   5      //                                              
 230   5      //                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 231   5      //                                              sprintf(log_buf, ">>>curtain obtCnt count:%d.\n", (int)curtainAct_Param.act_counter);
 232   5      //                                              PrintString1_logOut(log_buf);
 233   5      //                                      }                       
C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 5   

 234   5      //#endif                                        
 235   5                                      }break;
 236   4                              }
 237   3                      
 238   3                      }break;
 239   2              
 240   2                      case SWITCH_TYPE_SWBIT1:{ //¼ÌµçÆ÷Î»ÖÃµ÷Õû 2¶Ô1
 241   3                      
 242   3                              if(DEV_actReserve & 0x02)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 243   3                              
 244   3                      }break;
 245   2                      
 246   2                      case SWITCH_TYPE_SWBIT2:{ //¼ÌµçÆ÷Î»ÖÃµ÷Õû 3¶Ô2
 247   3                      
 248   3                              if(DEV_actReserve & 0x01)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 249   3                              if(DEV_actReserve & 0x04)(status_Relay & 0x02)?(PIN_RELAY_2 = 1):(PIN_RELAY_2 = 0);
 250   3                      
 251   3                      }break;
 252   2                      
 253   2                      case SWITCH_TYPE_SWBIT3:{ //¼ÌµçÆ÷Î»ÖÃ±£³Ö
 254   3                      
 255   3                              if(DEV_actReserve & 0x01)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 256   3                              if(DEV_actReserve & 0x02)(status_Relay & 0x02)?(PIN_RELAY_2 = 1):(PIN_RELAY_2 = 0);
 257   3                              if(DEV_actReserve & 0x04)(status_Relay & 0x04)?(PIN_RELAY_3 = 1):(PIN_RELAY_3 = 0);
 258   3                      
 259   3                      }break;
 260   2                      
 261   2                      default:break;
 262   2              }
 263   1      #endif  
 264   1              
 265   1              tips_statusChangeToNormal();
 266   1      }
 267          
 268          /*¿ª¹Ø³õÊ¼»¯*/
 269          void relay_pinInit(void){
 270   1              
 271   1              u8 idata statusTemp = 0;
 272   1              
 273   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      //ÍÆÍì
                      P3M1    &= ~0x30;
                      P3M0    |= 0x30;
                      PIN_RELAY_2 = PIN_PWM_OUT = 0;
                      
                      P3M1    |= 0x08;   //P33¹ý0ÖÐ¶Ï¼ì²â½Å
                      P3M0    &= ~0x08;
                  INT1 = 0;
                  IT1 = 1; 
                      PX1 = 0; //¸ßÓÅÏÈ¼¶
                  EX1 = 1;           
                      
                      statusRelay_saveEn = 1; //ÖØ¸´Ö÷¶¯¼ÇÒäµ±Ç°Æô¶¯Öµ£¬·ÀÖ¹¿ª¹ØÎ´²Ù×÷Çé¿öÏÂµÚÈý´ÎÉÏµçÆô¶¯Ê±¼ÇÒäÖµ¶ªÊ§
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      //ÍÆÍì
                      P3M1    &= ~0x38;
                      P3M0    |= 0x38;
                      PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      //ÍÆÍì
C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 6   

                      P3M1    &= ~0x08;
                      P3M0    |= 0x08;
                      PIN_RELAY_1 = 0;
                      
                      //¸ß×èÈë
                      P3M1    |= 0xC0;
                      P3M0    &= ~0xC0;
                      INT_CLKO |=  (1 << 4); //Íâ²¿ÖÐ¶Ï2Ê¹ÄÜ
                      INT_CLKO |=  (1 << 5); //Íâ²¿ÖÐ¶Ï3Ê¹ÄÜ
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      //³¡¾°¿ª¹ØÃ»ÓÐ¼ÌµçÆ÷
                      //¼üÎ»°ó¶¨³¡¾°ºÅµôµç¼ÇÒä»Ö¸´
                      EEPROM_read_n(EEPROM_ADDR_swTypeForceScenario_scencarioNumKeyBind, scenario_ActParam.scenarioNum_record, 
             -3);
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      //ÍÆÍì
                      P3M1    &= ~0x38;
                      P3M0    |= 0x38;
                      PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
                      
              #elif(SWITCH_TYPE_FORCEDEF == 0)
 318   1              //ÍÆÍì
 319   1              P3M1    &= ~0x38;
 320   1              P3M0    |= 0x38;
 321   1              PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
 322   1              
 323   1              //´°Á±¹ìµÀÖÜÆÚ¼°Æä¶ÔÓ¦Î»ÖÃ¼ÆÊ±Öµ»Ö¸´
 324   1              EEPROM_read_n(EEPROM_ADDR_curtainOrbitalPeriod, &(curtainAct_Param.act_period), 1);
 325   1              if(curtainAct_Param.act_period == 0xff)curtainAct_Param.act_period = CURTAIN_ORBITAL_PERIOD_INITTIME; //Ö
             -µÏÞ¶¨        
 326   1              EEPROM_read_n(EEPROM_ADDR_curtainOrbitalCnter, &(curtainAct_Param.act_counter), 1);
 327   1              if(curtainAct_Param.act_counter == 0xff)curtainAct_Param.act_counter = 0; //ÖµÏÞ¶¨      
 328   1              
 329   1       #if(DEBUG_LOGOUT_EN == 1)
                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
                              
                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                              sprintf(log_buf, ">>>curtain param recover orbitalPeriod:%d, placeCounter:%d\n", (int)curtainAct_Param.a
             -ct_period, (int)curtainAct_Param.act_counter);
                              PrintString1_logOut(log_buf);
                      }                       
               #endif
 337   1      #else
                      
              #endif
 340   1              
 341   1              if(relayStatus_ifSave == statusSave_enable){
 342   2              
 343   2      #if(DATASAVE_INTLESS_ENABLEIF)
 344   2                      swCommand_fromUsr.objRelay = devDataRecovery_relayStatus();
 345   2      #else
                              EEPROM_read_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
                              swCommand_fromUsr.objRelay = statusTemp;
              #endif
 349   2                      swCommand_fromUsr.actMethod = relay_OnOff; //Ó²¼þ¼ÓÔØ
 350   2                      
 351   2              }else{
 352   2              
 353   2                      statusTemp = 0;
 354   2                      coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 7   

 355   2                      relay_statusReales(); //Ó²¼þ¼ÓÔØ
 356   2              }
 357   1      }
 358          
 359          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              void Ext_INT1 (void) interrupt INT1_VECTOR{
                      
                      dimmer_freqParam.periodBeat_cfm = dimmer_freqParam.periodBeat_counter;
                      dimmer_freqParam.periodBeat_counter = 0;
                      
                      dimmer_freqParam.pwm_actEN = 1;
              }
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              void Ext_INT2 (void) interrupt INT2_VECTOR{ //ÖÐ¶Ï2
                      
                      socket_eleDetParam.eleParamFun_powerPulseCount += 1.0F;
               #if(SWITCH_TYPE_SOCKETS_SPECIFICATION == SOCKETS_SPECIFICATION_BRITISH)
                      pinFP_stdby_powerCNT += 1.0F;
               #endif
              }
              
              void Ext_INT3 (void) interrupt INT3_VECTOR{ //ÖÐ¶Ï3
                      
                      
              }
              #else
 381          #endif
 382          
 383          /*¿ª¹Ø¶¯×÷*/
 384          void relay_Act(relay_Command dats){
 385   1              
 386   1              u8 statusTemp = 0;
 387   1              
 388   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER) //ÈÎÒâÀàÐÍ¼ÓÔØ£¬²»Òª×Ô¶¯´æ´¢¼ÇÒä£¬ÒòÎª³¤°´°´¼üÁ¬Ðø¸ü¸ÄÁÁ¶È
             -Öµ¶¼½øÐÐ¼ÇÒäµÄ»°»°Ôì³ÉµÆ¹âÁÁ¶ÈÍ»±ä£¬³¤°´ÔÚ½áÊøÊ±½øÐÐ¼ÇÒä¼´¿É
                      status_Relay = dats.objRelay;
                      relay_statusReales();
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
                      dats = dats;
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      status_Relay = dats.objRelay;
                      relay_statusReales();
                      
              #else
 400   1              
 401   1              statusTemp = status_Relay; //µ±Ç°¿ª¹ØÖµÔÝ´æ
 402   1              
 403   1              switch(dats.actMethod){
 404   2              
 405   2                      case relay_flip:{ 
 406   3                              
 407   3                              if(dats.objRelay & 0x01)status_Relay ^= 1 << 0;
 408   3                              if(dats.objRelay & 0x02)status_Relay ^= 1 << 1;
 409   3                              if(dats.objRelay & 0x04)status_Relay ^= 1 << 2;
 410   3                                      
 411   3                      }break;
 412   2                      
 413   2                      case relay_OnOff:{
 414   3                              
 415   3                              (dats.objRelay & 0x01)?(status_Relay |= 1 << 0):(status_Relay &= ~(1 << 0));
C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 8   

 416   3                              (dats.objRelay & 0x02)?(status_Relay |= 1 << 1):(status_Relay &= ~(1 << 1));
 417   3                              (dats.objRelay & 0x04)?(status_Relay |= 1 << 2):(status_Relay &= ~(1 << 2));
 418   3                              
 419   3                      }break;
 420   2                      
 421   2                      default:break;
 422   2                      
 423   2              }relay_statusReales(); //Ó²¼þ¼ÓÔØ
 424   1              
 425   1              devActionPush_IF.dats_Push = 0;
 426   1              devActionPush_IF.dats_Push |= (status_Relay & 0x07); //µ±Ç°¿ª¹ØÖµÎ»Ìî×°<µÍÈýÎ»>
 427   1              
 428   1      //      /*ÓÅÏÈ·½Ê½*/
 429   1      //      if(             (statusTemp & 0x01) != (status_Relay & 0x01))devActionPush_IF.dats_Push |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈý
             -Î»>µÚÒ»Î»
 430   1      //      else if((statusTemp & 0x02) != (status_Relay & 0x02))devActionPush_IF.dats_Push |= 0x40; //¸ü¸ÄÖµÌî×°<¸
             -ßÈýÎ»>µÚ¶þÎ»
 431   1      //      else if((statusTemp & 0x04) != (status_Relay & 0x04))devActionPush_IF.dats_Push |= 0x80; //¸ü¸ÄÖµÌî×°<¸
             -ßÈýÎ»>µÚÈýÎ»
 432   1              /*·ÇÓÅÏÈ·½Ê½*/
 433   1              if((statusTemp & 0x01) != (status_Relay & 0x01))devActionPush_IF.dats_Push |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÒ»Î»
 434   1              if((statusTemp & 0x02) != (status_Relay & 0x02))devActionPush_IF.dats_Push |= 0x40; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -Ú¶þÎ»
 435   1              if((statusTemp & 0x04) != (status_Relay & 0x04))devActionPush_IF.dats_Push |= 0x80; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÈýÎ»
 436   1              
 437   1              if(status_Relay)delayCnt_closeLoop = 0; //¿ª¹ØÒ»µ©´ò¿ªÁ¢¿Ì¸üÐÂÂÌÉ«Ä£Ê½Ê±¼ä¼ÆÊýÖµ
 438   1              
 439   1              if(relayStatus_ifSave == statusSave_enable){ /*Ã¿´Î¸ü¸Ä¿ª¹ØÖµÊ±¶¼½øÐÐ´æ´¢¼ÇÒä*///¿ª¹Ø×´Ì¬´æ´¢×Ô¶¯±»¶¯¼ÇÒä
 440   2              
 441   2       #if(DATASAVE_INTLESS_ENABLEIF)
 442   2                      devParamDtaaSave_relayStatusRealTime(status_Relay);
 443   2       #else
                              statusTemp = status_Relay;
                              coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
               #endif
 447   2              }
 448   1              
 449   1      #endif
 450   1      }
 451          
 452          /*¼ÌµçÆ÷Ö÷Ïß³Ì*/
 453          void thread_Relay(void){
 454   1              
 455   1              if(swCommand_fromUsr.actMethod != actionNull){ //ÇëÇóÏìÓ¦
 456   2              
 457   2                      relay_Act(swCommand_fromUsr);
 458   2                      
 459   2                      swCommand_fromUsr.actMethod = actionNull;
 460   2                      swCommand_fromUsr.objRelay = 0;
 461   2              }
 462   1              
 463   1              if(statusRelay_saveEn){ /*Ö÷¶¯¼ÇÒäÊ¹ÄÜÅÐ¶Ï*///¿ª¹Ø×´Ì¬´æ´¢Ö÷¶¯¼ÇÒä
 464   2              
 465   2                      u8 idata statusTemp = 0;
 466   2                      
 467   2                      statusRelay_saveEn = 0;
 468   2                      
 469   2      //#if(DEBUG_LOGOUT_EN == 1)
 470   2      //              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 471   2      //                      
C51 COMPILER V9.54   RELAY                                                                 05/13/2019 08:24:11 PAGE 9   

 472   2      //                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 473   2      //                      sprintf(log_buf, ">>>statusVal save cmp.\n");
 474   2      //                      PrintString1_logOut(log_buf);
 475   2      //              }                       
 476   2      //#endif
 477   2              
 478   2                      if(relayStatus_ifSave == statusSave_enable){ 
 479   3              
 480   3      #if(DATASAVE_INTLESS_ENABLEIF)
 481   3                              devParamDtaaSave_relayStatusRealTime(status_Relay);
 482   3      #else
                                      statusTemp = status_Relay;
                                      coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
              #endif
 486   3                      }
 487   2              }
 488   1              
 489   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      if(heater_ActParam.relayActDelay_actEn){ //Í¬²½´¥·¢±êÖ¾Î»ÏìÓ¦
                      
                              heater_ActParam.relayActDelay_actEn = 0;
                              PIN_RELAY_3 = PIN_RELAY_1; //ÈÈË®Æ÷¼ÌµçÆ÷µçÆ½Í¬²½¶¯×÷´¥·¢
                      }
                      
                      if(heater_ActParam.heater_currentActMode == heaterActMode_swClose){ //²¹³¥ÏìÓ¦£¬±ÜÃâÓÐÊ±ºòÖ¸Ê¾µÆÏìÓ¦ÁËµ«¼
             -ÌµçÆ÷Ã»ÏìÓ¦
                      
                              if((status_Relay & (1 << 0)) != 0){
                              
                                      swCommand_fromUsr.objRelay = 0;
                                      swCommand_fromUsr.actMethod = relay_OnOff; //¿ª¹Ø¶¯×÷
                              }
                      }
                      
              #else
 506   1      #endif
 507   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    627    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----       2
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
