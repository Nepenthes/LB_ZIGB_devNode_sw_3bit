C51 COMPILER V9.54   RELAY                                                                 01/23/2019 16:32:40 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE RELAY
OBJECT MODULE PLACED IN .\Output\Relay.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Actuator\Relay.c OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\
                    -std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\Relay.lst) OBJECT(.\Output\Relay.obj)

line level    source

   1          #include "Relay.h"
   2          
   3          #include "string.h"
   4          #include "stdio.h"
   5          
   6          #include "Tips.h"
   7          #include "timerAct.h"
   8          #include "appTimer.h"
   9          #include "dataTrans.h"
  10          #include "dataManage.h"
  11          
  12          #include "eeprom.h"
  13          
  14          /**********************±¾µØÎÄ¼þ±äÁ¿¶¨ÒåÇø*****************************/
  15          status_ifSave   xdata relayStatus_ifSave = statusSave_disable;  //¿ª¹Ø¼ÇÒäÊ¹ÄÜ±äÁ¿
  16          u8                              xdata status_Relay               = 0;
  17          
  18          relay_Command   xdata swCommand_fromUsr  = {0, actionNull};
  19            
  20          u8                              xdata EACHCTRL_realesFLG = 0; //»¥¿Ø¶¯×÷¸üÐÂÊ¹ÄÜ±êÖ¾£¨·¢Âë£©±êÖ¾<bit0£ºÒ»Î»¿ª¹Ø»¥¿Ø¸üÐÂ; bit1£º¶þÎ»¿
             -ª¹Ø»¥¿Ø¸üÐÂ; bit2£ºÈýÎ»¿ª¹Ø»¥¿Ø¸üÐÂ;>
  21          bit                                       EACHCTRL_reportFLG = 0; //»¥¿Ø´¥·¢ºóÏòÍø¹ØÉÏ±¨×´Ì¬Ê¹ÄÜ
  22          
  23          relayStatus_PUSH xdata devActionPush_IF = {0};
  24          
  25          bit                             idata statusRelay_saveEn= 0; //¿ª¹ØÖµ±¾µØ´æ´¢Ê¹ÄÜ,Áé»îÊ¹ÓÃ,ÖØ¸´´æ´¢
  26          
  27          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              stt_Dimmer_attrFreq     xdata dimmer_freqParam          = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              stt_eleSocket_attrFreq xdata socket_eleDetParam = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
              stt_scenario_attrAct xdata scenario_ActParam = {0};
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
              stt_heater_attrAct xdata heater_ActParam = {0};
              #else
  36          stt_Curtain_motorAttr xdata curtainAct_Param = {0, CURTAIN_ORBITAL_PERIOD_INITTIME, cTact_stop}; //µ±Éè±¸¶
             -¨ÒåÎª´°Á±Ê±£¬¶ÔÓ¦¶¯×÷ÊôÐÔ£¬Ä¬ÈÏ¹ìµÀÊ±¼ä0s
  37          #endif
  38          
  39          /*¼ÌµçÆ÷×´Ì¬¸üÐÂ£¬Ó²¼þÖ´ÐÐ*/
  40          void relay_statusReales(void){
  41   1              
  42   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      switch(status_Relay){
                      
                              case 0:{
                              
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 0;
                              
                              }break;
                              
                              case 1:{
                              
C51 COMPILER V9.54   RELAY                                                                 01/23/2019 16:32:40 PAGE 2   

                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 0;PIN_RELAY_3 = 1;
                                      
                              }break;
                                      
                              case 2:{
                              
                                      PIN_RELAY_1 = 0;PIN_RELAY_2 = 1;PIN_RELAY_3 = 0;
                                      
                              }break;
                                      
                              case 3:
                              default:{
                              
                                      PIN_RELAY_1 = 1;PIN_RELAY_2 = 0;PIN_RELAY_3 = 0;
                                      
                              }break;
                      }
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      (status_Relay)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      {
                              
                              bit scenarioTrigReserve_flg = 0;
                              
                              if((!scenario_ActParam.scenarioKeepTrig_timeCounter) || (scenario_ActParam.scenarioKeepTrig_timeCounter 
             -== COUNTER_DISENABLE_MASK_SPECIALVAL_U8)){ //²»Í¬³¡¾°´¥·¢Ç¿ÖÆ¼ä¸ôÊ±¼ä½áÊøºó²ÅÔÊÐí¶¯×÷
                              
                                      switch(status_Relay){
                                      
                                              case 1:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S1;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              case 2:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S2;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              case 4:{
                                              
                                                      scenario_ActParam.scenarioKey_currentTrig = scenarioKey_current_S3;
                                                      scenarioTrigReserve_flg = 1;
                                              
                                              }break;
                                                      
                                              default:{}break;
                                      }
                                      
                                      if(scenarioTrigReserve_flg){
                                      
                                              scenario_ActParam.scenarioKeepTrig_timeCounter = SCENARIOTRIG_KEEPTIME_PERIOD;
                                              scenario_ActParam.scenarioDataSend_FLG = 1;
                                      }
                              }
C51 COMPILER V9.54   RELAY                                                                 01/23/2019 16:32:40 PAGE 3   

                      }
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      switch(status_Relay){
              
                              case 0:{
                              
                                      PIN_RELAY_1 = 0;
                                      heater_ActParam.relayActDelay_counter = HEATER_RELAY_SYNCHRONIZATION_DELAYTIME; //´óÐ¡¼ÌµçÆ÷ÖÍºóÊ±¼äÉè¶
             -¨
                                      
                              }break;
                              
                              case 1:{
                              
                                      PIN_RELAY_1 = 1;
                                      heater_ActParam.relayActDelay_counter = HEATER_RELAY_SYNCHRONIZATION_DELAYTIME; //´óÐ¡¼ÌµçÆ÷ÖÍºóÊ±¼äÉè¶
             -¨
                              
                              }break;
                              
                              default:{
              
                                      
                              }break;
                      }
                      
                      PIN_RELAY_3 = 0;
                      
              #else
 142   1              switch(SWITCH_TYPE){
 143   2                      
 144   2                      case SWITCH_TYPE_CURTAIN:{
 145   3                      
 146   3                              switch(status_Relay){
 147   4                              
 148   4                                      case 1:{
 149   5                                      
 150   5                                              PIN_RELAY_2 = 1;
 151   5                                              PIN_RELAY_1 = PIN_RELAY_3 = 0;
 152   5                                              curtainAct_Param.act = cTact_open;
 153   5                                              
 154   5                                      }break;
 155   4                                              
 156   4                                      case 4:{
 157   5                                      
 158   5                                              PIN_RELAY_1 = 1;
 159   5                                              PIN_RELAY_2 = PIN_RELAY_3 = 0;
 160   5                                              curtainAct_Param.act = cTact_close;
 161   5                                              
 162   5                                      }break;
 163   4                                              
 164   4                                      case 2:
 165   4                                      default:{
 166   5                                      
 167   5                                              PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
 168   5                                              curtainAct_Param.act = cTact_stop;
 169   5                                              
 170   5                                              if(curtainAct_Param.act != cTact_stop)coverEEPROM_write_n(EEPROM_ADDR_curtainOrbitalCnter, &(curtainA
             -ct_Param.act_counter), 1); //Ã¿´Î´°Á±ÔË¶¯Í£Ö¹Ê±£¬¼ÇÂ¼µ±Ç°Î»ÖÃ¶ÔÓ¦µÄ¹ìµÀÖÜÆÚ¼ÆÊ±Öµ
 171   5                                              
 172   5                                      }break;
C51 COMPILER V9.54   RELAY                                                                 01/23/2019 16:32:40 PAGE 4   

 173   4                              }
 174   3                      
 175   3                      }break;
 176   2              
 177   2                      case SWITCH_TYPE_SWBIT1:{ //¼ÌµçÆ÷Î»ÖÃµ÷Õû 2¶Ô1
 178   3                      
 179   3                              if(DEV_actReserve & 0x02)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 180   3                              
 181   3                      }break;
 182   2                      
 183   2                      case SWITCH_TYPE_SWBIT2:{ //¼ÌµçÆ÷Î»ÖÃµ÷Õû 3¶Ô2
 184   3                      
 185   3                              if(DEV_actReserve & 0x01)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 186   3                              if(DEV_actReserve & 0x04)(status_Relay & 0x02)?(PIN_RELAY_2 = 1):(PIN_RELAY_2 = 0);
 187   3                      
 188   3                      }break;
 189   2                      
 190   2                      case SWITCH_TYPE_SWBIT3:{ //¼ÌµçÆ÷Î»ÖÃ±£³Ö
 191   3                      
 192   3                              if(DEV_actReserve & 0x01)(status_Relay & 0x01)?(PIN_RELAY_1 = 1):(PIN_RELAY_1 = 0);
 193   3                              if(DEV_actReserve & 0x02)(status_Relay & 0x02)?(PIN_RELAY_2 = 1):(PIN_RELAY_2 = 0);
 194   3                              if(DEV_actReserve & 0x04)(status_Relay & 0x04)?(PIN_RELAY_3 = 1):(PIN_RELAY_3 = 0);
 195   3                      
 196   3                      }break;
 197   2                      
 198   2                      default:break;
 199   2              }
 200   1      #endif  
 201   1              
 202   1              tips_statusChangeToNormal();
 203   1      }
 204          
 205          /*¿ª¹Ø³õÊ¼»¯*/
 206          void relay_pinInit(void){
 207   1              
 208   1              u8 idata statusTemp = 0;
 209   1              
 210   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      //ÍÆÍì
                      P3M1    &= ~0x30;
                      P3M0    |= 0x30;
                      PIN_RELAY_2 = PIN_PWM_OUT = 0;
                      
                      P3M1    |= 0x08;   //P33¹ý0ÖÐ¶Ï¼ì²â½Å
                      P3M0    &= ~0x08;
                  INT1 = 0;
                  IT1 = 1; 
                      PX1 = 0; //¸ßÓÅÏÈ¼¶
                  EX1 = 1;           
                      
                      statusRelay_saveEn = 1; //ÖØ¸´Ö÷¶¯¼ÇÒäµ±Ç°Æô¶¯Öµ£¬·ÀÖ¹¿ª¹ØÎ´²Ù×÷Çé¿öÏÂµÚÈý´ÎÉÏµçÆô¶¯Ê±¼ÇÒäÖµ¶ªÊ§
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      //ÍÆÍì
                      P3M1    &= ~0x38;
                      P3M0    |= 0x38;
                      PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      //ÍÆÍì
                      P3M1    &= ~0x08;
                      P3M0    |= 0x08;
C51 COMPILER V9.54   RELAY                                                                 01/23/2019 16:32:40 PAGE 5   

                      PIN_RELAY_1 = 0;
                      
                      //¸ß×èÈë
                      P3M1    |= 0xC0;
                      P3M0    &= ~0xC0;
                      INT_CLKO |=  (1 << 4); //Íâ²¿ÖÐ¶Ï2Ê¹ÄÜ
                      INT_CLKO |=  (1 << 5); //Íâ²¿ÖÐ¶Ï3Ê¹ÄÜ
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      //³¡¾°¿ª¹ØÃ»ÓÐ¼ÌµçÆ÷
                      //¼üÎ»°ó¶¨³¡¾°ºÅµôµç¼ÇÒä»Ö¸´
                      EEPROM_read_n(EEPROM_ADDR_swTypeForceScenario_scencarioNumKeyBind, scenario_ActParam.scenarioNum_record, 
             -3);
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      //ÍÆÍì
                      P3M1    &= ~0x38;
                      P3M0    |= 0x38;
                      PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
                      
              #elif(SWITCH_TYPE_FORCEDEF == 0)
 255   1              //ÍÆÍì
 256   1              P3M1    &= ~0x38;
 257   1              P3M0    |= 0x38;
 258   1              PIN_RELAY_1 = PIN_RELAY_2 = PIN_RELAY_3 = 0;
 259   1              
 260   1              //´°Á±¹ìµÀÖÜÆÚ¼°Æä¶ÔÓ¦Î»ÖÃ¼ÆÊ±Öµ»Ö¸´
 261   1              EEPROM_read_n(EEPROM_ADDR_curtainOrbitalPeriod, &(curtainAct_Param.act_period), 1);
 262   1              if(curtainAct_Param.act_period == 0xff)curtainAct_Param.act_period = CURTAIN_ORBITAL_PERIOD_INITTIME; //Ö
             -µÏÞ¶¨        
 263   1              EEPROM_read_n(EEPROM_ADDR_curtainOrbitalCnter, &(curtainAct_Param.act_counter), 1);
 264   1              if(curtainAct_Param.act_counter == 0xff)curtainAct_Param.act_counter = 0; //ÖµÏÞ¶¨      
 265   1              
 266   1       #if(DEBUG_LOGOUT_EN == 1)
 267   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 268   2                      
 269   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 270   2                      sprintf(log_buf, ">>>curtain param recover orbitalPeriod:%d, placeCounter:%d\n", (int)curtainAct_Param.a
             -ct_period, (int)curtainAct_Param.act_counter);
 271   2                      PrintString1_logOut(log_buf);
 272   2              }                       
 273   1       #endif
 274   1      #else
                      
              #endif
 277   1              
 278   1              if(relayStatus_ifSave == statusSave_enable){
 279   2              
 280   2      #if(DATASAVE_INTLESS_ENABLEIF)
 281   2                      swCommand_fromUsr.objRelay = devDataRecovery_relayStatus();
 282   2      #else
                              EEPROM_read_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
                              swCommand_fromUsr.objRelay = statusTemp;
              #endif
 286   2                      swCommand_fromUsr.actMethod = relay_OnOff; //Ó²¼þ¼ÓÔØ
 287   2                      
 288   2              }else{
 289   2              
 290   2                      statusTemp = 0;
 291   2                      coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
 292   2                      relay_statusReales(); //Ó²¼þ¼ÓÔØ
 293   2              }
C51 COMPILER V9.54   RELAY                                                                 01/23/2019 16:32:40 PAGE 6   

 294   1      }
 295          
 296          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              void Ext_INT1 (void) interrupt INT1_VECTOR{
                      
                      dimmer_freqParam.periodBeat_cfm = dimmer_freqParam.periodBeat_counter;
                      dimmer_freqParam.periodBeat_counter = 0;
                      
                      dimmer_freqParam.pwm_actEN = 1;
              }
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              void Ext_INT2 (void) interrupt INT2_VECTOR{ //ÖÐ¶Ï2
                      
                      socket_eleDetParam.eleParamFun_powerPulseCount += 1.0F;
              }
              
              void Ext_INT3 (void) interrupt INT3_VECTOR{ //ÖÐ¶Ï3
                      
                      
              }
              #else
 315          #endif
 316          
 317          /*¿ª¹Ø¶¯×÷*/
 318          void relay_Act(relay_Command dats){
 319   1              
 320   1              u8 statusTemp = 0;
 321   1              
 322   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER) //ÈÎÒâÀàÐÍ¼ÓÔØ£¬²»Òª×Ô¶¯´æ´¢¼ÇÒä£¬ÒòÎª³¤°´°´¼üÁ¬Ðø¸ü¸ÄÁÁ¶È
             -Öµ¶¼½øÐÐ¼ÇÒäµÄ»°»°Ôì³ÉµÆ¹âÁÁ¶ÈÍ»±ä£¬³¤°´ÔÚ½áÊøÊ±½øÐÐ¼ÇÒä¼´¿É
                      status_Relay = dats.objRelay;
                      relay_statusReales();
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
                      dats = dats;
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      status_Relay = dats.objRelay;
                      relay_statusReales();
                      
              #else
 334   1              
 335   1              statusTemp = status_Relay; //µ±Ç°¿ª¹ØÖµÔÝ´æ
 336   1              
 337   1              switch(dats.actMethod){
 338   2              
 339   2                      case relay_flip:{ 
 340   3                              
 341   3                              if(dats.objRelay & 0x01)status_Relay ^= 1 << 0;
 342   3                              if(dats.objRelay & 0x02)status_Relay ^= 1 << 1;
 343   3                              if(dats.objRelay & 0x04)status_Relay ^= 1 << 2;
 344   3                                      
 345   3                      }break;
 346   2                      
 347   2                      case relay_OnOff:{
 348   3                              
 349   3                              (dats.objRelay & 0x01)?(status_Relay |= 1 << 0):(status_Relay &= ~(1 << 0));
 350   3                              (dats.objRelay & 0x02)?(status_Relay |= 1 << 1):(status_Relay &= ~(1 << 1));
 351   3                              (dats.objRelay & 0x04)?(status_Relay |= 1 << 2):(status_Relay &= ~(1 << 2));
 352   3                              
 353   3                      }break;
 354   2                      
C51 COMPILER V9.54   RELAY                                                                 01/23/2019 16:32:40 PAGE 7   

 355   2                      default:break;
 356   2                      
 357   2              }relay_statusReales(); //Ó²¼þ¼ÓÔØ
 358   1              
 359   1              devActionPush_IF.dats_Push = 0;
 360   1              devActionPush_IF.dats_Push |= (status_Relay & 0x07); //µ±Ç°¿ª¹ØÖµÎ»Ìî×°<µÍÈýÎ»>
 361   1              
 362   1      //      /*ÓÅÏÈ·½Ê½*/
 363   1      //      if(             (statusTemp & 0x01) != (status_Relay & 0x01))devActionPush_IF.dats_Push |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈý
             -Î»>µÚÒ»Î»
 364   1      //      else if((statusTemp & 0x02) != (status_Relay & 0x02))devActionPush_IF.dats_Push |= 0x40; //¸ü¸ÄÖµÌî×°<¸
             -ßÈýÎ»>µÚ¶þÎ»
 365   1      //      else if((statusTemp & 0x04) != (status_Relay & 0x04))devActionPush_IF.dats_Push |= 0x80; //¸ü¸ÄÖµÌî×°<¸
             -ßÈýÎ»>µÚÈýÎ»
 366   1              /*·ÇÓÅÏÈ·½Ê½*/
 367   1              if((statusTemp & 0x01) != (status_Relay & 0x01))devActionPush_IF.dats_Push |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÒ»Î»
 368   1              if((statusTemp & 0x02) != (status_Relay & 0x02))devActionPush_IF.dats_Push |= 0x40; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -Ú¶þÎ»
 369   1              if((statusTemp & 0x04) != (status_Relay & 0x04))devActionPush_IF.dats_Push |= 0x80; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÈýÎ»
 370   1              
 371   1              if(status_Relay)delayCnt_closeLoop = 0; //¿ª¹ØÒ»µ©´ò¿ªÁ¢¿Ì¸üÐÂÂÌÉ«Ä£Ê½Ê±¼ä¼ÆÊýÖµ
 372   1              
 373   1              if(relayStatus_ifSave == statusSave_enable){ /*Ã¿´Î¸ü¸Ä¿ª¹ØÖµÊ±¶¼½øÐÐ´æ´¢¼ÇÒä*///¿ª¹Ø×´Ì¬´æ´¢×Ô¶¯±»¶¯¼ÇÒä
 374   2              
 375   2       #if(DATASAVE_INTLESS_ENABLEIF)
 376   2                      devParamDtaaSave_relayStatusRealTime(status_Relay);
 377   2       #else
                              statusTemp = status_Relay;
                              coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
               #endif
 381   2              }
 382   1              
 383   1      #endif
 384   1      }
 385          
 386          /*¼ÌµçÆ÷Ö÷Ïß³Ì*/
 387          void thread_Relay(void){
 388   1              
 389   1              if(swCommand_fromUsr.actMethod != actionNull){ //ÇëÇóÏìÓ¦
 390   2              
 391   2                      relay_Act(swCommand_fromUsr);
 392   2                      
 393   2                      swCommand_fromUsr.actMethod = actionNull;
 394   2                      swCommand_fromUsr.objRelay = 0;
 395   2              }
 396   1              
 397   1              if(statusRelay_saveEn){ /*Ö÷¶¯¼ÇÒäÊ¹ÄÜÅÐ¶Ï*///¿ª¹Ø×´Ì¬´æ´¢Ö÷¶¯¼ÇÒä
 398   2              
 399   2                      u8 idata statusTemp = 0;
 400   2                      
 401   2                      statusRelay_saveEn = 0;
 402   2                      
 403   2      //#if(DEBUG_LOGOUT_EN == 1)
 404   2      //              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 405   2      //                      
 406   2      //                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 407   2      //                      sprintf(log_buf, ">>>statusVal save cmp.\n");
 408   2      //                      PrintString1_logOut(log_buf);
 409   2      //              }                       
 410   2      //#endif
C51 COMPILER V9.54   RELAY                                                                 01/23/2019 16:32:40 PAGE 8   

 411   2              
 412   2                      if(relayStatus_ifSave == statusSave_enable){ 
 413   3              
 414   3      #if(DATASAVE_INTLESS_ENABLEIF)
 415   3                              devParamDtaaSave_relayStatusRealTime(status_Relay);
 416   3      #else
                                      statusTemp = status_Relay;
                                      coverEEPROM_write_n(EEPROM_ADDR_relayStatus, &statusTemp, 1);
              #endif
 420   3                      }
 421   2              }
 422   1              
 423   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      if(heater_ActParam.relayActDelay_actEn){
                      
                              heater_ActParam.relayActDelay_actEn = 0;
                              PIN_RELAY_2 = PIN_RELAY_1; //ÈÈË®Æ÷¼ÌµçÆ÷µçÆ½Í¬²½¶¯×÷´¥·¢
                      }
                      
              #else
 431   1      #endif
 432   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    665    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----       2
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
