C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE APPTIMER
OBJECT MODULE PLACED IN .\Output\appTimer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Usr\appTimer.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\st
                    -d_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\appTimer.lst) OBJECT(.\Output\appTimer.obj)

line level    source

   1          #include "appTimer.h"
   2          
   3          #include "STC15Fxxxx.H"
   4          
   5          #include "stdio.h"
   6          #include "string.h"
   7          
   8          #include "USART.h"
   9          
  10          #include "Relay.h"
  11          #include "timerAct.h"
  12          #include "touchPad.h"
  13          #include "dataTrans.h"
  14          #include "Tips.h"
  15          #include "usrKin.h"
  16          #include "dataManage.h"
  17          
  18          #include "devlopeDebug.h"
  19          
  20          //***************数据传输变量引用区***************************/
  21          extern bit                              rxTout_count_EN;        
  22          extern u8                               rxTout_count;   //串口接收超时计数
  23          extern bit                              uartRX_toutFLG;
  24          extern u8                               datsRcv_length;
  25          extern uartTout_datsRcv xdata datsRcv_ZIGB;
  26          
  27          extern u16 xdata                zigbNwkAction_counter; //zigb网络重连专用动作时间计数
  28          
  29          extern u16 xdata                dtReqEx_counter; //扩展型数据发送间隔计时值
  30          
  31          extern bit                              heartBeatCycle_FLG;     //心跳周期触发标志
  32          extern u8 xdata                 heartBeatCount; //心跳计数
  33          extern u8 xdata                 heartBeatPeriod; //心跳周期
  34          extern u8 xdata                 heartBeatHang_timeCnt;
  35          
  36          extern u8 xdata                 colonyCtrlGet_queryCounter; 
  37          extern u8 xdata                 colonyCtrlGetHang_timeCnt;
  38          
  39          //***************按键输入变量引用区***************************/
  40          extern bit                              usrKeyCount_EN;
  41          extern u16                              usrKeyCount;
  42          
  43          extern u16 xdata                touchPadActCounter;
  44          extern u16 xdata                touchPadContinueCnt;
  45          
  46          extern u16 xdata                combinationFunFLG_3S5S_cancel_counter;
  47          
  48          //***************Tips变量引用区***************************/
  49          extern u16 xdata                counter_tipsAct;
  50          
  51          /*-----------------------------------------------------------------------------------------------*/
  52          void appTimer0_Init(void){      //50us 中断@24.000M
  53   1      
  54   1              AUXR |= 0x80;           
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 2   

  55   1              TMOD &= 0xF0;           
  56   1              TL0   = 0x50;           
  57   1              TH0   = 0xFB;   
  58   1              TF0   = 0;      
  59   1              ET0       = 1;  //开中断
  60   1              PT0   = 1;      
  61   1              
  62   1              TR0   = 1;              
  63   1      }
  64          
  65          void appTimer4_Init(void){      //50us 中断@24.000M
  66   1              
  67   1              T4T3M   |= 0x20;                
  68   1              T4L     = 0x50;         
  69   1              T4H     = 0xFB;         
  70   1              T4T3M   |= 0x80;        
  71   1      
  72   1              IE2     |= 0x40;
  73   1      }
  74          
  75          void timer0_Rountine (void) interrupt TIMER0_VECTOR{
  76   1              
  77   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      {
                              
                              u8 xdata freq_periodBeatHalf = dimmer_freqParam.periodBeat_cfm / 2;
              
                              dimmer_freqParam.periodBeat_counter ++; //电源频率单周期节拍数更新
                              
                              if(dimmer_freqParam.pwm_actEN){         
                              
                                      dimmer_freqParam.pwm_actCounter ++;
                                      
                                      if(dimmer_freqParam.pwm_actCounter <= status_Relay && dimmer_freqParam.pwm_actCounter < freq_periodBeat
             -Half){ //前半周
                                              
                                              PIN_PWM_OUT = 1;
                                              
                                      }else{
                                      
                                              dimmer_freqParam.pwm_actCounter = 0;
                                              dimmer_freqParam.pwm_actEN = 0;
                                              PIN_PWM_OUT = 0;
                                      }
                                      
              //                      if(dimmer_freqParam.pwm_actCounter <= freq_periodBeatHalf){
              //                      
              //                              if(dimmer_freqParam.pwm_actCounter < status_Relay){
              //                                      
              //                                      PIN_PWM_OUT = 1;
              //                                      
              //                              }else{
              //                              
              //                                      PIN_PWM_OUT = 0;
              //                              }
              //                              
              ////                            PIN_PWM_OUT = 0;
              //                      
              //                      }else
              //                      if(dimmer_freqParam.pwm_actCounter > freq_periodBeatHalf && dimmer_freqParam.pwm_actCounter <= dimmer
             -_freqParam.periodBeat_cfm){
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 3   

              //                              
              ////                            if((dimmer_freqParam.pwm_actCounter - freq_periodBeatHalf) < status_Relay){
              ////                                    
              ////                                    PIN_PWM_OUT = 1;
              ////                                    
              ////                            }else{
              ////                            
              ////                                    PIN_PWM_OUT = 0;
              ////                            }
              //                              
              //                              PIN_PWM_OUT = 0;
              
              //                      }else{
              //                      
              //                              dimmer_freqParam.pwm_actCounter = 0;
              //                              dimmer_freqParam.pwm_actEN = 0;
              //                              PIN_PWM_OUT = 0;
              //                      }
                                      
                              }else{
                              
                                      PIN_PWM_OUT = 0;
                              }
                      }
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      u16 code period_1second = 20000;
                      static u16 counter_1second = 0; 
                      u8 code period_1second_x5 = 5;
                      static u8 counter_1second_x5 = 0; 
                      
                      if(counter_1second < period_1second)counter_1second ++; //1s
                      else{
                      
                              counter_1second = 0;
                              
                              if(counter_1second_x5 < period_1second_x5)counter_1second_x5 ++; //5s
                              else{
                              
                                      counter_1second_x5 = 0;
                                      
              //                      /*浮点数传输测试*/
              //                      socket_eleDetParam.eleParamFun_powerFreqVal     = 111.12345F;
              //                      socket_eleDetParam.eleParam_power                               = 122.12345F;
              //                      socket_eleDetParam.ele_Consum                                   = 253.11111F;
                                      
                                      socket_eleDetParam.eleParamFun_powerFreqVal = socket_eleDetParam.eleParamFun_powerPulseCount / 5.0F; //
             -频率
                                      socket_eleDetParam.eleParam_power = socket_eleDetParam.eleParamFun_powerFreqVal * (COEFFICIENT_POW - (C
             -OEFFICIENT_COMPENSATION_POW * socket_eleDetParam.eleParamFun_powerFreqVal)); //功率
                                      
                                      if(socket_eleDetParam.eleParamFun_powerFreqVal < 0.00001F)socket_eleDetParam.eleParamFun_powerFreqVal =
             - 0.00001F; //最小值限定
                                      socket_eleDetParam.ele_Consum   += 1.00F * (socket_eleDetParam.eleParamFun_powerPulseCount * socket_eleDe
             -tParam.eleParam_power / (1000.00F * 3600.00F * socket_eleDetParam.eleParamFun_powerFreqVal)); //用电量
                                      
                                      socket_eleDetParam.eleParamFun_powerPulseCount = 0.0F; //脉冲计数清零
                              }
                      }
              #else
 170   1      #endif
 171   1      }
 172          
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 4   

 173          void timer4_Rountine (void) interrupt TIMER4_VECTOR{
 174   1              
 175   1              u16 code period_1second = 20000;
 176   1              static u16 counter_1second = 0; 
 177   1              
 178   1              u8 code period_1ms              = 20;
 179   1              static u8 counter_1ms   = 0; 
 180   1              
 181   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              #else
 185   1              u16 code period_100ms   = 4000;
 186   1              static u16 counter_100ms = 0; 
 187   1              u8 code period5_200ms   = 5;
 188   1              static u8 counter5_200ms = 0; 
 189   1      #endif
 190   1              
 191   1              u8 code period_tipsColor = COLORGRAY_MAX * 3;
 192   1              static u8 counter_tipsColor = 0; 
 193   1              static color_Attr xdata cnt_relay1_Tips = {0};
 194   1              static color_Attr xdata cnt_relay2_Tips = {0};
 195   1              static color_Attr xdata cnt_relay3_Tips = {0};
 196   1              static color_Attr xdata cnt_zigbNwk_Tips = {0};
 197   1              
 198   1              static u8 xdata period_beep = 3;                //beep专用
 199   1              static u8 xdata count_beep      = 0;
 200   1               
 201   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              #else
 205   1              //****************100ms特殊**********************************************/
 206   1              if(counter_100ms < period_100ms)counter_100ms ++;
 207   1              else{
 208   2                      
 209   2                      counter_100ms = 0;
 210   2                      counter5_200ms ++;
 211   2              
 212   2                      /*窗帘逻辑业务，按照轨道时间动作*/
 213   2                      if(SWITCH_TYPE == SWITCH_TYPE_CURTAIN){
 214   3                      
 215   3                              switch(curtainAct_Param.act){
 216   4                              
 217   4                                      case cTact_open:{
 218   5                                      
 219   5                                              if(curtainAct_Param.act_counter < curtainAct_Param.act_period){
 220   6                                              
 221   6                                                      if(counter5_200ms >= period5_200ms)curtainAct_Param.act_counter ++;
 222   6                                                      
 223   6                                              }else{
 224   6                                              
 225   6                                                      curtainAct_Param.act = cTact_stop;
 226   6                                              }
 227   5                                              
 228   5                                      }break;
 229   4                                              
 230   4                                      case cTact_close:{
 231   5                                      
 232   5                                              if(curtainAct_Param.act_counter > 0){
 233   6                                              
 234   6                                                      if(counter5_200ms >= period5_200ms)curtainAct_Param.act_counter --;
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 5   

 235   6                                                      
 236   6                                              }else{
 237   6                                              
 238   6                                                      curtainAct_Param.act = cTact_stop;
 239   6                                              }
 240   5                                      
 241   5                                      }break;
 242   4                                              
 243   4                                      case cTact_stop:{
 244   5                                      
 245   5                                              if(status_Relay != 2){
 246   6                                              
 247   6                                                      swCommand_fromUsr.objRelay = 2;
 248   6                                                      swCommand_fromUsr.actMethod = relay_OnOff;
 249   6                                                      devActionPush_IF.push_IF = 1; //推送使能
 250   6                                              }
 251   5                                              
 252   5                                      }break;
 253   4                                              
 254   4                                      default:{}break;
 255   4                              }
 256   3                      }
 257   2                      
 258   2                      if(counter5_200ms >= period5_200ms)counter5_200ms = 0;
 259   2              }
 260   1      #endif
 261   1              
 262   1              //****************1ms专用**********************************************/
 263   1              if(counter_1ms < period_1ms)counter_1ms ++;
 264   1              else{
 265   2              
 266   2                      counter_1ms = 0;
 267   2                      
 268   2                      /*zigb专用动作时间计数*/
 269   2                      if(zigbNwkAction_counter)zigbNwkAction_counter --;
 270   2                      
 271   2                      /*用户按键动作专用时间计数*/
 272   2                      if(usrKeyCount_EN)usrKeyCount ++;
 273   2                      else usrKeyCount = 0;
 274   2                      
 275   2                      /*触摸按键动作专用时间计数*/
 276   2                      if(touchPadActCounter)touchPadActCounter --;
 277   2                      
 278   2                      /*触摸按键连按专用时间计数*/
 279   2                      if(touchPadContinueCnt)touchPadContinueCnt --;
 280   2                      
 281   2                      /*Tips动作专用时间计数*/
 282   2                      if(counter_tipsAct)counter_tipsAct --;
 283   2                      
 284   2                      /*扩展性(持续性)数据发送动作间隔时间计数*/
 285   2                      if(dtReqEx_counter)dtReqEx_counter --;
 286   2                      
 287   2                      /*特殊组合动作按键触发 预标志衔接时间计数*/
 288   2                      if(combinationFunFLG_3S5S_cancel_counter)combinationFunFLG_3S5S_cancel_counter --;
 289   2              }
 290   1              
 291   1              //****************1s专用**********************************************/
 292   1              if(counter_1second < period_1second)counter_1second ++;
 293   1              else{
 294   2              
 295   2                      counter_1second = 0;
 296   2                      
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 6   

 297   2      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              //              /*电源频率单周期节拍数统计*/
              //              /*>>>usr_debug<<<*/
              //              //usr_debug数据填装
              //              dev_debugInfoLog.debugInfoData.dimmerInfo.soureFreq = dimmer_freqParam.periodBeat_cfm;
              //              //usr_debug打印类型填装填装
              //              dev_debugInfoLog.debugInfoType = infoType_dimmerFreq;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              #else
 307   2      #endif
 308   2                      /*心跳包计时计数业务*/
 309   2                      if(!heartBeatCycle_FLG){
 310   3                      
 311   3                              if(heartBeatCount < heartBeatPeriod)heartBeatCount ++;
 312   3                              else{
 313   4                              
 314   4                                      heartBeatCount = 0;
 315   4                                      heartBeatCycle_FLG = 1;
 316   4                              }
 317   3                      }
 318   2                      
 319   2                      /*延时计时业务，到点动作*/
 320   2                      if(ifDelay_sw_running_FLAG & (1 << 1)){
 321   3                      
 322   3                              if(delayCnt_onoff < ((u16)delayPeriod_onoff * 60))delayCnt_onoff ++;
 323   3                              else{
 324   4                              
 325   4                                      delayPeriod_onoff = delayCnt_onoff = 0; 
 326   4                                      
 327   4                                      ifDelay_sw_running_FLAG &= ~(1 << 1);   //一次性标志清除
 328   4                                      
 329   4                                      swCommand_fromUsr.actMethod = relay_OnOff; //开关动作
 330   4                                      swCommand_fromUsr.objRelay = delayUp_act;
 331   4                                      devActionPush_IF.push_IF = 1; //推送使能
 332   4                                      dev_agingCmd_sndInitative.agingCmd_delaySetOpreat = 1; //对应主动上传时效占位置一
 333   4                                      
 334   4                                      /*>>>usr_debug<<<*/
 335   4                                      //usr_debug数据填装
 336   4                                      dev_debugInfoLog.debugInfoData.delayActInfo.delayAct_Up = 1;
 337   4                                      //usr_debug打印类型填装填装
 338   4                                      dev_debugInfoLog.debugInfoType = infoType_delayUp;
 339   4                              }
 340   3                      }
 341   2                      
 342   2                      /*绿色模式计时业务，循环关闭*/
 343   2                      if((ifDelay_sw_running_FLAG & (1 << 0)) && status_Relay){
 344   3                      
 345   3                              if(delayCnt_closeLoop < ((u16)delayPeriod_closeLoop * 60))delayCnt_closeLoop ++;
 346   3                              else{
 347   4                                      
 348   4                                      delayCnt_closeLoop = 0;
 349   4                              
 350   4                                      swCommand_fromUsr.actMethod = relay_OnOff; //开关动作
 351   4                                      swCommand_fromUsr.objRelay = 0;
 352   4                                      devActionPush_IF.push_IF = 1; //推送使能
 353   4                                      dev_agingCmd_sndInitative.agingCmd_greenModeSetOpreat = 1; //对应主动上传时效占位置一
 354   4                              }
 355   3                      }
 356   2                      
 357   2                      /*场景周期询查挂起计时值更新*///挂起作用<<
 358   2                      if(heartBeatHang_timeCnt)heartBeatHang_timeCnt --;
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 7   

 359   2                      
 360   2                      /*心跳挂起计时值更新*///挂起作用<<
 361   2                      if(colonyCtrlGetHang_timeCnt)colonyCtrlGetHang_timeCnt --;
 362   2                      
 363   2                      /*系统时间本地维持计数值更新*/
 364   2                      sysTimeKeep_counter ++;
 365   2                      
 366   2                      /*tips空闲释放计时计数业务*/
 367   2                      if(counter_ifTipsFree && countEN_ifTipsFree)counter_ifTipsFree --;
 368   2                      
 369   2                      /*系统时间周期新更新计时计数业务*/
 370   2                      if(sysTimeReales_counter)sysTimeReales_counter --;
 371   2                      
 372   2                      /*zigb网络开放倒计时*/
 373   2                      if(tipsTimeCount_zigNwkOpen)tipsTimeCount_zigNwkOpen --;
 374   2                      
 375   2                      /*设备网络挂起时间倒计时*///挂起作用<<
 376   2                      if(devNwkHoldTime_Param.devHoldTime_counter)devNwkHoldTime_Param.devHoldTime_counter --;
 377   2                      
 378   2                      /*集群受控状态周期性轮询周期计时*/
 379   2                      if(colonyCtrlGet_queryCounter)colonyCtrlGet_queryCounter --;
 380   2                      
 381   2                      /*触摸IC复位时间倒计时*/
 382   2                      if(touchPad_resetTimeCount)touchPad_resetTimeCount --;
 383   2                      
 384   2                      /*触摸IC复位Tips倒计时*/
 385   2                      if(tipsTimeCount_touchReset)tipsTimeCount_touchReset --;
 386   2                      
 387   2                      /*恢复预置动作倒计时*/
 388   2                      if(factoryRecover_HoldTimeCount)factoryRecover_HoldTimeCount --;
 389   2                      
 390   2                      /*恢复出厂Tips倒计时*/
 391   2                      if(tipsTimeCount_factoryRecover)tipsTimeCount_factoryRecover --;
 392   2                      
 393   2                      /*协调器失联/丢失 确认倒计时*/
 394   2                      if(timeCounter_coordinatorLost_detecting)timeCounter_coordinatorLost_detecting --;
 395   2              }
 396   1      
 397   1              //***************串口接收超时时长计数*******************************//
 398   1              if(rxTout_count_EN){ //接收超时计时使能判断
 399   2              
 400   2                      if(rxTout_count < TimeOutSet1)rxTout_count ++;
 401   2                      else{
 402   3                              
 403   3                              if(!uartRX_toutFLG && datsRcv_length >= 5){ //超时时间判断及最小帧长判断
 404   4                              
 405   4                                      uartRX_toutFLG = 1;
 406   4                              
 407   4                                      memset(datsRcv_ZIGB.rcvDats, 0xff, sizeof(char) * COM_RX1_Lenth);
 408   4                                      memcpy(datsRcv_ZIGB.rcvDats, RX1_Buffer, COM_RX1_Lenth);
 409   4                                      datsRcv_ZIGB.rcvDatsLen = datsRcv_length;
 410   4                                      
 411   4                                      /*>>>usr_debug<<<*/
 412   4                                      if(datsRcv_length != (datsRcv_ZIGB.rcvDats[1] + 5)){  //标的帧长判断，是否超长
 413   5                                      
 414   5                                              //usr_debug数据填装
 415   5                                              dev_debugInfoLog.debugInfoData.frameInfo.frameIllegal_FLG = 1;
 416   5                                              dev_debugInfoLog.debugInfoData.frameInfo.frame_aLength = RX1_Buffer[1];
 417   5                                              dev_debugInfoLog.debugInfoData.frameInfo.frame_rLength = datsRcv_length;
 418   5                                              //usr_debug打印类型填装填装
 419   5                                              dev_debugInfoLog.debugInfoType = infoType_frameUart;
 420   5                                              
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 8   

 421   5                                      }else{
 422   5                                      
 423   5      
 424   5                                      }
 425   4                              }
 426   3                              rxTout_count_EN = 0;
 427   3                      }
 428   2              }
 429   1              
 430   1              //*******************beep计时计数业务**************************/
 431   1              if(count_beep < period_beep)count_beep ++;
 432   1              else{
 433   2                      
 434   2                      static u16 xdata        tips_Period = 20 * 50 / 2;
 435   2                      static u16 xdata        tips_Count      = 0;
 436   2                      static u8 xdata         tips_Loop       = 2 * 4;
 437   2                      static bit                      beeps_en        = 1;
 438   2              
 439   2                      count_beep = 0;
 440   2      
 441   2                      switch(dev_statusBeeps){ //状态机
 442   3                              
 443   3                              case beepsMode_standBy:{
 444   4                                      
 445   4                                      period_beep = devTips_beep.tips_Period;
 446   4                                      tips_Period = 20 * devTips_beep.tips_time / period_beep;
 447   4                                      tips_Loop       = 2 * devTips_beep.tips_loop;
 448   4                                      tips_Count      = 0;
 449   4                                      beeps_en        = 1;
 450   4                                      dev_statusBeeps = beepsWorking;
 451   4              
 452   4                              }break;
 453   3                              
 454   3                              case beepsWorking:{
 455   4                              
 456   4                                      if(tips_Loop){
 457   5                                      
 458   5                                              if(tips_Count < tips_Period){
 459   6                                              
 460   6                                                      tips_Count ++;
 461   6                                                      (beeps_en)?(PIN_BEEP = !PIN_BEEP):(PIN_BEEP = !BEEP_OPEN_LEVEL);
 462   6                                                      
 463   6                                              }else{
 464   6                                              
 465   6                                                      tips_Count = 0;
 466   6                                                      beeps_en = !beeps_en;
 467   6                                                      tips_Loop --;
 468   6                                              }
 469   5                                              
 470   5                                      }else{
 471   5                                      
 472   5                                              dev_statusBeeps = beepsComplete;
 473   5                                      }
 474   4                              
 475   4                              }break;
 476   3                              
 477   3                              case beepsComplete:{
 478   4                              
 479   4                                      tips_Count = 0;
 480   4                                      beeps_en = 1;
 481   4                                      PIN_BEEP = !BEEP_OPEN_LEVEL;
 482   4                                      dev_statusBeeps = beepsMode_null;
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 9   

 483   4                                      
 484   4                              }break;
 485   3                      
 486   3                              default:{
 487   4                              
 488   4                                      PIN_BEEP = !BEEP_OPEN_LEVEL;
 489   4                                      
 490   4                              }break;
 491   3                      }
 492   2              }
 493   1              
 494   1              //***************tips_Led 刷新业务*******************************//
 495   1              if(counter_tipsColor > period_tipsColor){       //灰度值值加载
 496   2              
 497   2                      counter_tipsColor = 0;
 498   2                      
 499   2                      cnt_relay1_Tips.colorGray_R = relay1_Tips.colorGray_R;
 500   2                      cnt_relay1_Tips.colorGray_G = relay1_Tips.colorGray_G;
 501   2                      cnt_relay1_Tips.colorGray_B = relay1_Tips.colorGray_B;
 502   2                      
 503   2                      cnt_relay2_Tips.colorGray_R = relay2_Tips.colorGray_R;
 504   2                      cnt_relay2_Tips.colorGray_G = relay2_Tips.colorGray_G;
 505   2                      cnt_relay2_Tips.colorGray_B = relay2_Tips.colorGray_B;
 506   2                      
 507   2                      cnt_relay3_Tips.colorGray_R = relay3_Tips.colorGray_R;
 508   2                      cnt_relay3_Tips.colorGray_G = relay3_Tips.colorGray_G;
 509   2                      cnt_relay3_Tips.colorGray_B = relay3_Tips.colorGray_B;
 510   2                      
 511   2                      cnt_zigbNwk_Tips.colorGray_R = zigbNwk_Tips.colorGray_R;
 512   2                      cnt_zigbNwk_Tips.colorGray_G = zigbNwk_Tips.colorGray_G;
 513   2                      cnt_zigbNwk_Tips.colorGray_B = zigbNwk_Tips.colorGray_B;
 514   2              }
 515   1              else{ //pwm执行
 516   2              
 517   2                      counter_tipsColor ++;
 518   2                      
 519   2      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                              
                              if((counter_tipsColor > 0) && (counter_tipsColor <= (COLORGRAY_MAX * 1))){
                                      
                                       //指示可用核准
                                      if(cnt_relay1_Tips.colorGray_R && (DEV_actReserve & 0x01)){cnt_relay1_Tips.colorGray_R --; PIN_TIPS_REL
             -AY1_R = 0;}
                                      else PIN_TIPS_RELAY1_R = 1;
                                      
                              }else
                              if((counter_tipsColor > (COLORGRAY_MAX * 2)) && (counter_tipsColor <= (COLORGRAY_MAX * 3))){
                              
                                       //指示可用核准
                                      if(cnt_relay1_Tips.colorGray_B && (DEV_actReserve & 0x01)){cnt_relay1_Tips.colorGray_B --; PIN_TIPS_REL
             -AY1_B = 0;}
                                      else PIN_TIPS_RELAY1_B = 1;
                              }               
              #else
 535   2                      
 536   2                      if((counter_tipsColor > 0) && (counter_tipsColor <= (COLORGRAY_MAX * 1))){
 537   3                              
 538   3                               //指示可用核准
 539   3                              if(cnt_relay1_Tips.colorGray_R && (DEV_actReserve & 0x01)){cnt_relay1_Tips.colorGray_R --; PIN_TIPS_REL
             -AY1_R = 0;}
 540   3                              else PIN_TIPS_RELAY1_R = 1;
 541   3                              if(cnt_relay2_Tips.colorGray_R && (DEV_actReserve & 0x02)){cnt_relay2_Tips.colorGray_R --; PIN_TIPS_REL
C51 COMPILER V9.54   APPTIMER                                                              12/20/2018 14:37:17 PAGE 10  

             -AY2_R = 0;}
 542   3                              else PIN_TIPS_RELAY2_R = 1;
 543   3                              if(cnt_relay3_Tips.colorGray_R && (DEV_actReserve & 0x04)){cnt_relay3_Tips.colorGray_R --; PIN_TIPS_REL
             -AY3_R = 0;}
 544   3                              else PIN_TIPS_RELAY3_R = 1;
 545   3                              if(cnt_zigbNwk_Tips.colorGray_R){cnt_zigbNwk_Tips.colorGray_R --; PIN_TIPS_ZIGBNWK_R = 0;}
 546   3                              else PIN_TIPS_ZIGBNWK_R = 1;
 547   3                              
 548   3                      }else
 549   2                      if((counter_tipsColor > (COLORGRAY_MAX * 1)) && (counter_tipsColor <= (COLORGRAY_MAX * 2))){
 550   3                      
 551   3                               //指示可用核准
 552   3                              if(cnt_relay1_Tips.colorGray_G && (DEV_actReserve & 0x01)){cnt_relay1_Tips.colorGray_G --; PIN_TIPS_REL
             -AY1_G = 0;}
 553   3                              else PIN_TIPS_RELAY1_G = 1;
 554   3                              if(cnt_relay2_Tips.colorGray_G && (DEV_actReserve & 0x02)){cnt_relay2_Tips.colorGray_G --; PIN_TIPS_REL
             -AY2_G = 0;}
 555   3                              else PIN_TIPS_RELAY2_G = 1;
 556   3                              if(cnt_relay3_Tips.colorGray_G && (DEV_actReserve & 0x04)){cnt_relay3_Tips.colorGray_G --; PIN_TIPS_REL
             -AY3_G = 0;}
 557   3                              else PIN_TIPS_RELAY3_G = 1;
 558   3                              if(cnt_zigbNwk_Tips.colorGray_G){cnt_zigbNwk_Tips.colorGray_G --; PIN_TIPS_ZIGBNWK_G = 0;}
 559   3                              else PIN_TIPS_ZIGBNWK_G = 1;
 560   3                              
 561   3                      }else
 562   2                      if((counter_tipsColor > (COLORGRAY_MAX * 2)) && (counter_tipsColor <= (COLORGRAY_MAX * 3))){
 563   3                      
 564   3                               //指示可用核准
 565   3                              if(cnt_relay1_Tips.colorGray_B && (DEV_actReserve & 0x01)){cnt_relay1_Tips.colorGray_B --; PIN_TIPS_REL
             -AY1_B = 0;}
 566   3                              else PIN_TIPS_RELAY1_B = 1;
 567   3                              if(cnt_relay2_Tips.colorGray_B && (DEV_actReserve & 0x02)){cnt_relay2_Tips.colorGray_B --; PIN_TIPS_REL
             -AY2_B = 0;}
 568   3                              else PIN_TIPS_RELAY2_B = 1;
 569   3                              if(cnt_relay3_Tips.colorGray_B && (DEV_actReserve & 0x04)){cnt_relay3_Tips.colorGray_B --; PIN_TIPS_REL
             -AY3_B = 0;}
 570   3                              else PIN_TIPS_RELAY3_B = 1;
 571   3                              if(cnt_zigbNwk_Tips.colorGray_B){cnt_zigbNwk_Tips.colorGray_B --; PIN_TIPS_ZIGBNWK_B = 0;}
 572   3                              else PIN_TIPS_ZIGBNWK_B = 1;
 573   3                      }
 574   2      #endif
 575   2              }
 576   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1689    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
