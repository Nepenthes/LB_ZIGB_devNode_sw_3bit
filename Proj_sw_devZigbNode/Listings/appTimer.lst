C51 COMPILER V9.54   APPTIMER                                                              09/02/2018 12:30:12 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE APPTIMER
OBJECT MODULE PLACED IN .\Output\appTimer.obj
COMPILER INVOKED BY: E:\KEIL\MDK_5.18&C51_v9.54a\Software\C51\BIN\C51.EXE Usr\appTimer.c OMF2 ROM(COMPACT) OPTIMIZE(8,SP
                    -EED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\appTimer
                    -.lst) OBJECT(.\Output\appTimer.obj)

line level    source

   1          #include "appTimer.h"
   2          
   3          #include "STC15Fxxxx.H"
   4          
   5          #include "stdio.h"
   6          #include "string.h"
   7          
   8          #include "USART.h"
   9          
  10          #include "Relay.h"
  11          #include "timerAct.h"
  12          #include "dataTrans.h"
  13          #include "Tips.h"
  14          
  15          //***************数据传输变量引用区***************************/
  16          extern bit                              rxTout_count_EN;        
  17          extern u8                               rxTout_count;   //串口接收超时计数
  18          extern bit                              uartRX_toutFLG;
  19          extern u8                               datsRcv_length;
  20          extern uartTout_datsRcv xdata datsRcv_ZIGB;
  21          
  22          extern u16 xdata                zigbNwkAction_counter; //zigb网络重连专用动作时间计数
  23          
  24          extern bit                              heartBeatCycle_FLG;     //心跳周期触发标志
  25          extern u8                               heartBeatCount; //心跳计数
  26          
  27          //***************按键输入变量引用区***************************/
  28          extern bit                              usrKeyCount_EN;
  29          extern u16                              usrKeyCount;
  30          
  31          extern u16 xdata                touchPadActCounter;
  32          extern u16 xdata                touchPadContinueCnt;
  33          
  34          //***************Tips变量引用区***************************/
  35          extern u8 xdata                 counter_tipsAct;
  36          
  37          /*-----------------------------------------------------------------------------------------------*/
  38          void appTimer0_Init(void){      //50us 中断@24.000M
  39   1      
  40   1              AUXR |= 0x80;           
  41   1              TMOD &= 0xF0;           
  42   1              TL0   = 0x50;           
  43   1              TH0   = 0xFB;   
  44   1              TF0   = 0;      
  45   1              ET0       = 1;  //开中断
  46   1              PT0   = 0;      //高优先级中断
  47   1              
  48   1              TR0   = 1;              
  49   1      }
  50          
  51          void timer0_Rountine (void) interrupt TIMER0_VECTOR{
  52   1              
  53   1              u16 code period_1second = 20000;
C51 COMPILER V9.54   APPTIMER                                                              09/02/2018 12:30:12 PAGE 2   

  54   1              static u16 counter_1second = 0; 
  55   1              
  56   1              u8 code period_1ms              = 20;
  57   1              static u8 counter_1ms   = 0; 
  58   1              
  59   1              u8 code period_tipsColor = COLORGRAY_MAX * 3;
  60   1              static u8 counter_tipsColor = 0; 
  61   1              static color_Attr xdata cnt_relay1_Tips = {0};
  62   1              static color_Attr xdata cnt_relay2_Tips = {0};
  63   1              static color_Attr xdata cnt_relay3_Tips = {0};
  64   1              static color_Attr xdata cnt_zigbNwk_Tips = {0};
  65   1              
  66   1              static u8 xdata period_beep = 3;                //beep专用
  67   1              static u8 xdata count_beep      = 0;
  68   1              
  69   1              //****************1ms专用**********************************************/
  70   1              if(counter_1ms < period_1ms)counter_1ms ++;
  71   1              else{
  72   2              
  73   2                      counter_1ms = 0;
  74   2                      
  75   2                      /*zigb专用动作时间计数*/
  76   2                      if(zigbNwkAction_counter)zigbNwkAction_counter --;
  77   2                      
  78   2                      /*用户按键动作专用时间计数*/
  79   2                      if(usrKeyCount_EN)usrKeyCount ++;
  80   2                      else usrKeyCount = 0;
  81   2                      
  82   2                      /*触摸按键动作专用时间计数*/
  83   2                      if(touchPadActCounter)touchPadActCounter --;
  84   2                      
  85   2                      /*触摸按键连按专用时间计数*/
  86   2                      if(touchPadContinueCnt)touchPadContinueCnt --;
  87   2                      
  88   2                      /*Tips动作专用时间计数*/
  89   2                      if(counter_tipsAct)counter_tipsAct --;
  90   2              }
  91   1              
  92   1              //****************1s专用**********************************************/
  93   1              if(counter_1second < period_1second)counter_1second ++;
  94   1              else{
  95   2              
  96   2                      counter_1second = 0;
  97   2                      
  98   2                      /*心跳包计时计数业务*/
  99   2                      if(!heartBeatCycle_FLG){
 100   3                      
 101   3                              if(heartBeatCount < PERIOD_HEARTBEAT)heartBeatCount ++;
 102   3                              else{
 103   4                              
 104   4                                      heartBeatCount = 0;
 105   4                                      heartBeatCycle_FLG = 1;
 106   4                              }
 107   3                      }
 108   2                      
 109   2                      /*延时计时业务，到点动作*/
 110   2                      if(ifDelay_sw_running_FLAG & (1 << 1)){
 111   3                      
 112   3                              if(delayCnt_onoff < ((u16)delayPeriod_onoff * 60))delayCnt_onoff ++;
 113   3                              else{
 114   4                              
 115   4                                      delayCnt_onoff = 0;
C51 COMPILER V9.54   APPTIMER                                                              09/02/2018 12:30:12 PAGE 3   

 116   4                                      
 117   4                                      ifDelay_sw_running_FLAG &= ~(1 << 1);   //一次性标志清除
 118   4                                      
 119   4                                      swCommand_fromUsr.actMethod = relay_OnOff; //开关动作
 120   4                                      swCommand_fromUsr.objRelay = delayUp_act;
 121   4                              }
 122   3                      }
 123   2                      
 124   2                      /*绿色模式计时业务，循环关闭*/
 125   2                      if((ifDelay_sw_running_FLAG & (1 << 0)) && status_Relay){
 126   3                      
 127   3                              if(delayCnt_closeLoop < ((u16)delayPeriod_closeLoop * 60))delayCnt_closeLoop ++;
 128   3                              else{
 129   4                                      
 130   4                                      delayCnt_closeLoop = 0;
 131   4                              
 132   4                                      swCommand_fromUsr.actMethod = relay_OnOff; //开关动作
 133   4                                      swCommand_fromUsr.objRelay = 0;
 134   4                              }
 135   3                      }
 136   2                      
 137   2                      /*系统时间本地维持计数值更新*/
 138   2                      sysTimeKeep_counter ++;
 139   2                      
 140   2                      /*tips空闲释放计时计数业务*/
 141   2                      if(counter_ifTipsFree)counter_ifTipsFree --;
 142   2                      
 143   2                      /*系统时间周期新更新计时计数业务*/
 144   2                      if(sysTimeReales_counter)sysTimeReales_counter --;
 145   2              }
 146   1      
 147   1              //***************串口接收超时时长计数*******************************//
 148   1              if(rxTout_count_EN){
 149   2              
 150   2                      if(rxTout_count < TimeOutSet1)rxTout_count ++;
 151   2                      else{
 152   3                              
 153   3                              if(!uartRX_toutFLG){
 154   4                              
 155   4                                      uartRX_toutFLG = 1;
 156   4                                      
 157   4                                      memset(datsRcv_ZIGB.rcvDats, 0xff, sizeof(char) * COM_RX1_Lenth);
 158   4                                      memcpy(datsRcv_ZIGB.rcvDats, RX1_Buffer, COM_RX1_Lenth);
 159   4                                      datsRcv_ZIGB.rcvDatsLen = datsRcv_length;
 160   4                              }
 161   3                              rxTout_count_EN = 0;
 162   3                      }
 163   2              }
 164   1              
 165   1              //*******************beep计时计数业务**************************/
 166   1              if(count_beep < period_beep)count_beep ++;
 167   1              else{
 168   2                      
 169   2                      static u16 xdata        tips_Period = 20 * 50 / 2;
 170   2                      static u16 xdata        tips_Count      = 0;
 171   2                      static u8 xdata         tips_Loop       = 2 * 4;
 172   2                      static bit                      beeps_en        = 1;
 173   2              
 174   2                      count_beep = 0;
 175   2      
 176   2                      switch(dev_statusBeeps){ //状态机
 177   3                              
C51 COMPILER V9.54   APPTIMER                                                              09/02/2018 12:30:12 PAGE 4   

 178   3                              case beepsMode_standBy:{
 179   4                                      
 180   4                                      period_beep = devTips_beep.tips_Period;
 181   4                                      tips_Period = 20 * devTips_beep.tips_time / period_beep;
 182   4                                      tips_Loop       = 2 * devTips_beep.tips_loop;
 183   4                                      tips_Count      = 0;
 184   4                                      beeps_en        = 1;
 185   4                                      dev_statusBeeps = beepsWorking;
 186   4              
 187   4                              }break;
 188   3                              
 189   3                              case beepsWorking:{
 190   4                              
 191   4                                      if(tips_Loop){
 192   5                                      
 193   5                                              if(tips_Count < tips_Period){
 194   6                                              
 195   6                                                      tips_Count ++;
 196   6                                                      (beeps_en)?(PIN_BEEP = !PIN_BEEP):(PIN_BEEP = 1);
 197   6                                                      
 198   6                                              }else{
 199   6                                              
 200   6                                                      tips_Count = 0;
 201   6                                                      beeps_en = !beeps_en;
 202   6                                                      tips_Loop --;
 203   6                                              }
 204   5                                              
 205   5                                      }else{
 206   5                                      
 207   5                                              dev_statusBeeps = beepsComplete;
 208   5                                      }
 209   4                              
 210   4                              }break;
 211   3                              
 212   3                              case beepsComplete:{
 213   4                              
 214   4                                      tips_Count = 0;
 215   4                                      beeps_en = 1;
 216   4                                      PIN_BEEP = 1;
 217   4                                      dev_statusBeeps = beepsMode_null;
 218   4                                      
 219   4                              }break;
 220   3                      
 221   3                              default:{
 222   4                              
 223   4                                      PIN_BEEP = 1;
 224   4                                      
 225   4                              }break;
 226   3                      }
 227   2              }
 228   1              
 229   1              //***************tips_Led 刷新业务*******************************//
 230   1              if(counter_tipsColor > period_tipsColor){       //灰度值值加载
 231   2              
 232   2                      counter_tipsColor = 0;
 233   2                      
 234   2                      cnt_relay1_Tips.colorGray_R = relay1_Tips.colorGray_R;
 235   2                      cnt_relay1_Tips.colorGray_G = relay1_Tips.colorGray_G;
 236   2                      cnt_relay1_Tips.colorGray_B = relay1_Tips.colorGray_B;
 237   2                      
 238   2                      cnt_relay2_Tips.colorGray_R = relay2_Tips.colorGray_R;
 239   2                      cnt_relay2_Tips.colorGray_G = relay2_Tips.colorGray_G;
C51 COMPILER V9.54   APPTIMER                                                              09/02/2018 12:30:12 PAGE 5   

 240   2                      cnt_relay2_Tips.colorGray_B = relay2_Tips.colorGray_B;
 241   2                      
 242   2                      cnt_relay3_Tips.colorGray_R = relay3_Tips.colorGray_R;
 243   2                      cnt_relay3_Tips.colorGray_G = relay3_Tips.colorGray_G;
 244   2                      cnt_relay3_Tips.colorGray_B = relay3_Tips.colorGray_B;
 245   2                      
 246   2                      cnt_zigbNwk_Tips.colorGray_R = zigbNwk_Tips.colorGray_R;
 247   2                      cnt_zigbNwk_Tips.colorGray_G = zigbNwk_Tips.colorGray_G;
 248   2                      cnt_zigbNwk_Tips.colorGray_B = zigbNwk_Tips.colorGray_B;
 249   2              }
 250   1              else{
 251   2              
 252   2                      counter_tipsColor ++;
 253   2                      
 254   2                      if((counter_tipsColor > 0) && (counter_tipsColor <= (COLORGRAY_MAX * 1))){
 255   3                              
 256   3                              if(cnt_relay1_Tips.colorGray_R){cnt_relay1_Tips.colorGray_R --; PIN_TIPS_RELAY1_R = 0;}
 257   3                              else PIN_TIPS_RELAY1_R = 1;
 258   3                              if(cnt_relay2_Tips.colorGray_R){cnt_relay2_Tips.colorGray_R --; PIN_TIPS_RELAY2_R = 0;}
 259   3                              else PIN_TIPS_RELAY2_R = 1;
 260   3                              if(cnt_relay3_Tips.colorGray_R){cnt_relay3_Tips.colorGray_R --; PIN_TIPS_RELAY3_R = 0;}
 261   3                              else PIN_TIPS_RELAY3_R = 1;
 262   3                              if(cnt_zigbNwk_Tips.colorGray_R){cnt_zigbNwk_Tips.colorGray_R --; PIN_TIPS_ZIGBNWK_R = 0;}
 263   3                              else PIN_TIPS_ZIGBNWK_R = 1;
 264   3                              
 265   3                      }else
 266   2                      if((counter_tipsColor > (COLORGRAY_MAX * 1)) && (counter_tipsColor <= (COLORGRAY_MAX * 2))){
 267   3                      
 268   3                              if(cnt_relay1_Tips.colorGray_G){cnt_relay1_Tips.colorGray_G --; PIN_TIPS_RELAY1_G = 0;}
 269   3                              else PIN_TIPS_RELAY1_G = 1;
 270   3                              if(cnt_relay2_Tips.colorGray_G){cnt_relay2_Tips.colorGray_G --; PIN_TIPS_RELAY2_G = 0;}
 271   3                              else PIN_TIPS_RELAY2_G = 1;
 272   3                              if(cnt_relay3_Tips.colorGray_G){cnt_relay3_Tips.colorGray_G --; PIN_TIPS_RELAY3_G = 0;}
 273   3                              else PIN_TIPS_RELAY3_G = 1;
 274   3                              if(cnt_zigbNwk_Tips.colorGray_G){cnt_zigbNwk_Tips.colorGray_G --; PIN_TIPS_ZIGBNWK_G = 0;}
 275   3                              else PIN_TIPS_ZIGBNWK_G = 1;
 276   3                              
 277   3                      }else
 278   2                      if((counter_tipsColor > (COLORGRAY_MAX * 2)) && (counter_tipsColor <= (COLORGRAY_MAX * 3))){
 279   3                      
 280   3                              if(cnt_relay1_Tips.colorGray_B){cnt_relay1_Tips.colorGray_B --; PIN_TIPS_RELAY1_B = 0;}
 281   3                              else PIN_TIPS_RELAY1_B = 1;
 282   3                              if(cnt_relay2_Tips.colorGray_B){cnt_relay2_Tips.colorGray_B --; PIN_TIPS_RELAY2_B = 0;}
 283   3                              else PIN_TIPS_RELAY2_B = 1;
 284   3                              if(cnt_relay3_Tips.colorGray_B){cnt_relay3_Tips.colorGray_B --; PIN_TIPS_RELAY3_B = 0;}
 285   3                              else PIN_TIPS_RELAY3_B = 1;
 286   3                              if(cnt_zigbNwk_Tips.colorGray_B){cnt_zigbNwk_Tips.colorGray_B --; PIN_TIPS_ZIGBNWK_B = 0;}
 287   3                              else PIN_TIPS_ZIGBNWK_B = 1;
 288   3                      }
 289   2              }
 290   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1191    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.54   APPTIMER                                                              09/02/2018 12:30:12 PAGE 6   

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
