C51 COMPILER V9.54   APPTIMER                                                              09/30/2018 16:43:38 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE APPTIMER
OBJECT MODULE PLACED IN .\Output\appTimer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Usr\appTimer.c OMF2 ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr;.
                    -\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\appTimer.lst) OBJECT(.\Output\appT
                    -imer.obj)

line level    source

   1          #include "appTimer.h"
   2          
   3          #include "STC15Fxxxx.H"
   4          
   5          #include "stdio.h"
   6          #include "string.h"
   7          
   8          #include "USART.h"
   9          
  10          #include "Relay.h"
  11          #include "timerAct.h"
  12          #include "dataTrans.h"
  13          #include "Tips.h"
  14          
  15          //***************数据传输变量引用区***************************/
  16          extern bit                              rxTout_count_EN;        
  17          extern u8                               rxTout_count;   //串口接收超时计数
  18          extern bit                              uartRX_toutFLG;
  19          extern u8                               datsRcv_length;
  20          extern uartTout_datsRcv xdata datsRcv_ZIGB;
  21          
  22          extern u16 xdata                zigbNwkAction_counter; //zigb网络重连专用动作时间计数
  23          
  24          extern bit                              heartBeatCycle_FLG;     //心跳周期触发标志
  25          extern u8                               heartBeatCount; //心跳计数
  26          
  27          extern u8       xdata           colonyCtrlGet_queryCounter; 
  28          
  29          //***************按键输入变量引用区***************************/
  30          extern bit                              usrKeyCount_EN;
  31          extern u16                              usrKeyCount;
  32          
  33          extern u16 xdata                touchPadActCounter;
  34          extern u16 xdata                touchPadContinueCnt;
  35          
  36          //***************Tips变量引用区***************************/
  37          extern u16 xdata                counter_tipsAct;
  38          
  39          /*-----------------------------------------------------------------------------------------------*/
  40          void appTimer0_Init(void){      //50us 中断@24.000M
  41   1      
  42   1              AUXR |= 0x80;           
  43   1              TMOD &= 0xF0;           
  44   1              TL0   = 0x50;           
  45   1              TH0   = 0xFB;   
  46   1              TF0   = 0;      
  47   1              ET0       = 1;  //开中断
  48   1              PT0   = 0;      //高优先级中断
  49   1              
  50   1              TR0   = 1;              
  51   1      }
  52          
  53          void timer0_Rountine (void) interrupt TIMER0_VECTOR{
C51 COMPILER V9.54   APPTIMER                                                              09/30/2018 16:43:38 PAGE 2   

  54   1              
  55   1              u16 code period_1second = 20000;
  56   1              static u16 counter_1second = 0; 
  57   1              
  58   1              u8 code period_1ms              = 20;
  59   1              static u8 counter_1ms   = 0; 
  60   1              
  61   1              u8 code period_tipsColor = COLORGRAY_MAX * 3;
  62   1              static u8 counter_tipsColor = 0; 
  63   1              static color_Attr xdata cnt_relay1_Tips = {0};
  64   1              static color_Attr xdata cnt_relay2_Tips = {0};
  65   1              static color_Attr xdata cnt_relay3_Tips = {0};
  66   1              static color_Attr xdata cnt_zigbNwk_Tips = {0};
  67   1              
  68   1              static u8 xdata period_beep = 3;                //beep专用
  69   1              static u8 xdata count_beep      = 0;
  70   1              
  71   1              //****************1ms专用**********************************************/
  72   1              if(counter_1ms < period_1ms)counter_1ms ++;
  73   1              else{
  74   2              
  75   2                      counter_1ms = 0;
  76   2                      
  77   2                      /*zigb专用动作时间计数*/
  78   2                      if(zigbNwkAction_counter)zigbNwkAction_counter --;
  79   2                      
  80   2                      /*用户按键动作专用时间计数*/
  81   2                      if(usrKeyCount_EN)usrKeyCount ++;
  82   2                      else usrKeyCount = 0;
  83   2                      
  84   2                      /*触摸按键动作专用时间计数*/
  85   2                      if(touchPadActCounter)touchPadActCounter --;
  86   2                      
  87   2                      /*触摸按键连按专用时间计数*/
  88   2                      if(touchPadContinueCnt)touchPadContinueCnt --;
  89   2                      
  90   2                      /*Tips动作专用时间计数*/
  91   2                      if(counter_tipsAct)counter_tipsAct --;
  92   2              }
  93   1              
  94   1              //****************1s专用**********************************************/
  95   1              if(counter_1second < period_1second)counter_1second ++;
  96   1              else{
  97   2              
  98   2                      counter_1second = 0;
  99   2                      
 100   2                      /*心跳包计时计数业务*/
 101   2                      if(!heartBeatCycle_FLG){
 102   3                      
 103   3                              if(heartBeatCount < PERIOD_HEARTBEAT)heartBeatCount ++;
 104   3                              else{
 105   4                              
 106   4                                      heartBeatCount = 0;
 107   4                                      heartBeatCycle_FLG = 1;
 108   4                              }
 109   3                      }
 110   2                      
 111   2                      /*延时计时业务，到点动作*/
 112   2                      if(ifDelay_sw_running_FLAG & (1 << 1)){
 113   3                      
 114   3                              if(delayCnt_onoff < ((u16)delayPeriod_onoff * 60))delayCnt_onoff ++;
 115   3                              else{
C51 COMPILER V9.54   APPTIMER                                                              09/30/2018 16:43:38 PAGE 3   

 116   4                              
 117   4                                      delayCnt_onoff = 0;
 118   4                                      
 119   4                                      ifDelay_sw_running_FLAG &= ~(1 << 1);   //一次性标志清除
 120   4                                      
 121   4                                      swCommand_fromUsr.actMethod = relay_OnOff; //开关动作
 122   4                                      swCommand_fromUsr.objRelay = delayUp_act;
 123   4                                      devActionPush_IF.push_IF = 1; //推送使能
 124   4                              }
 125   3                      }
 126   2                      
 127   2                      /*绿色模式计时业务，循环关闭*/
 128   2                      if((ifDelay_sw_running_FLAG & (1 << 0)) && status_Relay){
 129   3                      
 130   3                              if(delayCnt_closeLoop < ((u16)delayPeriod_closeLoop * 60))delayCnt_closeLoop ++;
 131   3                              else{
 132   4                                      
 133   4                                      delayCnt_closeLoop = 0;
 134   4                              
 135   4                                      swCommand_fromUsr.actMethod = relay_OnOff; //开关动作
 136   4                                      swCommand_fromUsr.objRelay = 0;
 137   4                                      devActionPush_IF.push_IF = 1; //推送使能
 138   4                              }
 139   3                      }
 140   2                      
 141   2                      /*系统时间本地维持计数值更新*/
 142   2                      sysTimeKeep_counter ++;
 143   2                      
 144   2                      /*tips空闲释放计时计数业务*/
 145   2                      if(counter_ifTipsFree)counter_ifTipsFree --;
 146   2                      
 147   2                      /*系统时间周期新更新计时计数业务*/
 148   2                      if(sysTimeReales_counter)sysTimeReales_counter --;
 149   2                      
 150   2                      /*zigb网络开放倒计时*/
 151   2                      if(timeCount_zigNwkOpen)timeCount_zigNwkOpen --;
 152   2                      
 153   2                      /*设备网络挂起时间倒计时*/
 154   2                      if(devNwkHoldTime_Param.devHoldTime_counter)devNwkHoldTime_Param.devHoldTime_counter --;
 155   2                      
 156   2                      /*集群受控状态周期性轮询周期计时*/
 157   2                      if(colonyCtrlGet_queryCounter)colonyCtrlGet_queryCounter --;
 158   2              }
 159   1      
 160   1              //***************串口接收超时时长计数*******************************//
 161   1              if(rxTout_count_EN){
 162   2              
 163   2                      if(rxTout_count < TimeOutSet1)rxTout_count ++;
 164   2                      else{
 165   3                              
 166   3                              if(!uartRX_toutFLG){
 167   4                              
 168   4                                      uartRX_toutFLG = 1;
 169   4                                      
 170   4                                      memset(datsRcv_ZIGB.rcvDats, 0xff, sizeof(char) * COM_RX1_Lenth);
 171   4                                      memcpy(datsRcv_ZIGB.rcvDats, RX1_Buffer, COM_RX1_Lenth);
 172   4                                      datsRcv_ZIGB.rcvDatsLen = datsRcv_length;
 173   4                              }
 174   3                              rxTout_count_EN = 0;
 175   3                      }
 176   2              }
 177   1              
C51 COMPILER V9.54   APPTIMER                                                              09/30/2018 16:43:38 PAGE 4   

 178   1              //*******************beep计时计数业务**************************/
 179   1              if(count_beep < period_beep)count_beep ++;
 180   1              else{
 181   2                      
 182   2                      static u16 xdata        tips_Period = 20 * 50 / 2;
 183   2                      static u16 xdata        tips_Count      = 0;
 184   2                      static u8 xdata         tips_Loop       = 2 * 4;
 185   2                      static bit                      beeps_en        = 1;
 186   2              
 187   2                      count_beep = 0;
 188   2      
 189   2                      switch(dev_statusBeeps){ //状态机
 190   3                              
 191   3                              case beepsMode_standBy:{
 192   4                                      
 193   4                                      period_beep = devTips_beep.tips_Period;
 194   4                                      tips_Period = 20 * devTips_beep.tips_time / period_beep;
 195   4                                      tips_Loop       = 2 * devTips_beep.tips_loop;
 196   4                                      tips_Count      = 0;
 197   4                                      beeps_en        = 1;
 198   4                                      dev_statusBeeps = beepsWorking;
 199   4              
 200   4                              }break;
 201   3                              
 202   3                              case beepsWorking:{
 203   4                              
 204   4                                      if(tips_Loop){
 205   5                                      
 206   5                                              if(tips_Count < tips_Period){
 207   6                                              
 208   6                                                      tips_Count ++;
 209   6                                                      (beeps_en)?(PIN_BEEP = !PIN_BEEP):(PIN_BEEP = 1);
 210   6                                                      
 211   6                                              }else{
 212   6                                              
 213   6                                                      tips_Count = 0;
 214   6                                                      beeps_en = !beeps_en;
 215   6                                                      tips_Loop --;
 216   6                                              }
 217   5                                              
 218   5                                      }else{
 219   5                                      
 220   5                                              dev_statusBeeps = beepsComplete;
 221   5                                      }
 222   4                              
 223   4                              }break;
 224   3                              
 225   3                              case beepsComplete:{
 226   4                              
 227   4                                      tips_Count = 0;
 228   4                                      beeps_en = 1;
 229   4                                      PIN_BEEP = 1;
 230   4                                      dev_statusBeeps = beepsMode_null;
 231   4                                      
 232   4                              }break;
 233   3                      
 234   3                              default:{
 235   4                              
 236   4                                      PIN_BEEP = 1;
 237   4                                      
 238   4                              }break;
 239   3                      }
C51 COMPILER V9.54   APPTIMER                                                              09/30/2018 16:43:38 PAGE 5   

 240   2              }
 241   1              
 242   1              //***************tips_Led 刷新业务*******************************//
 243   1              if(counter_tipsColor > period_tipsColor){       //灰度值值加载
 244   2              
 245   2                      counter_tipsColor = 0;
 246   2                      
 247   2                      cnt_relay1_Tips.colorGray_R = relay1_Tips.colorGray_R;
 248   2                      cnt_relay1_Tips.colorGray_G = relay1_Tips.colorGray_G;
 249   2                      cnt_relay1_Tips.colorGray_B = relay1_Tips.colorGray_B;
 250   2                      
 251   2                      cnt_relay2_Tips.colorGray_R = relay2_Tips.colorGray_R;
 252   2                      cnt_relay2_Tips.colorGray_G = relay2_Tips.colorGray_G;
 253   2                      cnt_relay2_Tips.colorGray_B = relay2_Tips.colorGray_B;
 254   2                      
 255   2                      cnt_relay3_Tips.colorGray_R = relay3_Tips.colorGray_R;
 256   2                      cnt_relay3_Tips.colorGray_G = relay3_Tips.colorGray_G;
 257   2                      cnt_relay3_Tips.colorGray_B = relay3_Tips.colorGray_B;
 258   2                      
 259   2                      cnt_zigbNwk_Tips.colorGray_R = zigbNwk_Tips.colorGray_R;
 260   2                      cnt_zigbNwk_Tips.colorGray_G = zigbNwk_Tips.colorGray_G;
 261   2                      cnt_zigbNwk_Tips.colorGray_B = zigbNwk_Tips.colorGray_B;
 262   2              }
 263   1              else{
 264   2              
 265   2                      counter_tipsColor ++;
 266   2                      
 267   2                      if((counter_tipsColor > 0) && (counter_tipsColor <= (COLORGRAY_MAX * 1))){
 268   3                              
 269   3                              if(cnt_relay1_Tips.colorGray_R){cnt_relay1_Tips.colorGray_R --; PIN_TIPS_RELAY1_R = 0;}
 270   3                              else PIN_TIPS_RELAY1_R = 1;
 271   3                              if(cnt_relay2_Tips.colorGray_R){cnt_relay2_Tips.colorGray_R --; PIN_TIPS_RELAY2_R = 0;}
 272   3                              else PIN_TIPS_RELAY2_R = 1;
 273   3                              if(cnt_relay3_Tips.colorGray_R){cnt_relay3_Tips.colorGray_R --; PIN_TIPS_RELAY3_R = 0;}
 274   3                              else PIN_TIPS_RELAY3_R = 1;
 275   3                              if(cnt_zigbNwk_Tips.colorGray_R){cnt_zigbNwk_Tips.colorGray_R --; PIN_TIPS_ZIGBNWK_R = 0;}
 276   3                              else PIN_TIPS_ZIGBNWK_R = 1;
 277   3                              
 278   3                      }else
 279   2                      if((counter_tipsColor > (COLORGRAY_MAX * 1)) && (counter_tipsColor <= (COLORGRAY_MAX * 2))){
 280   3                      
 281   3                              if(cnt_relay1_Tips.colorGray_G){cnt_relay1_Tips.colorGray_G --; PIN_TIPS_RELAY1_G = 0;}
 282   3                              else PIN_TIPS_RELAY1_G = 1;
 283   3                              if(cnt_relay2_Tips.colorGray_G){cnt_relay2_Tips.colorGray_G --; PIN_TIPS_RELAY2_G = 0;}
 284   3                              else PIN_TIPS_RELAY2_G = 1;
 285   3                              if(cnt_relay3_Tips.colorGray_G){cnt_relay3_Tips.colorGray_G --; PIN_TIPS_RELAY3_G = 0;}
 286   3                              else PIN_TIPS_RELAY3_G = 1;
 287   3                              if(cnt_zigbNwk_Tips.colorGray_G){cnt_zigbNwk_Tips.colorGray_G --; PIN_TIPS_ZIGBNWK_G = 0;}
 288   3                              else PIN_TIPS_ZIGBNWK_G = 1;
 289   3                              
 290   3                      }else
 291   2                      if((counter_tipsColor > (COLORGRAY_MAX * 2)) && (counter_tipsColor <= (COLORGRAY_MAX * 3))){
 292   3                      
 293   3                              if(cnt_relay1_Tips.colorGray_B){cnt_relay1_Tips.colorGray_B --; PIN_TIPS_RELAY1_B = 0;}
 294   3                              else PIN_TIPS_RELAY1_B = 1;
 295   3                              if(cnt_relay2_Tips.colorGray_B){cnt_relay2_Tips.colorGray_B --; PIN_TIPS_RELAY2_B = 0;}
 296   3                              else PIN_TIPS_RELAY2_B = 1;
 297   3                              if(cnt_relay3_Tips.colorGray_B){cnt_relay3_Tips.colorGray_B --; PIN_TIPS_RELAY3_B = 0;}
 298   3                              else PIN_TIPS_RELAY3_B = 1;
 299   3                              if(cnt_zigbNwk_Tips.colorGray_B){cnt_zigbNwk_Tips.colorGray_B --; PIN_TIPS_ZIGBNWK_B = 0;}
 300   3                              else PIN_TIPS_ZIGBNWK_B = 1;
 301   3                      }
C51 COMPILER V9.54   APPTIMER                                                              09/30/2018 16:43:38 PAGE 6   

 302   2              }
 303   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1257    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
