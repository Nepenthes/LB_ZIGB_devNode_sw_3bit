C51 COMPILER V9.54   DATAMANAGE                                                            09/07/2018 18:15:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DATAMANAGE
OBJECT MODULE PLACED IN .\Output\dataManage.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Usr\dataManage.c OMF2 ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr
                    -;.\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\dataManage.lst) OBJECT(.\Output\
                    -dataManage.obj)

line level    source

   1          #include "dataManage.h"
   2          
   3          #include "STC15Fxxxx.H"
   4          
   5          #include "eeprom.h"
   6          #include "delay.h"
   7          
   8          #include "stdio.h"
   9          #include "string.h"
  10          
  11          u8 SWITCH_TYPE = SWITCH_TYPE_SWBIT3;
  12          u8 DEV_actReserve = 0x01;
  13          
  14          //u8 CTRLEATHER_PORT[clusterNum_usr] = {0x1A, 0x1B, 0x1C};
  15          u8 CTRLEATHER_PORT[clusterNum_usr] = {0, 0, 0};
  16          
  17          /********************本地文件变量创建区******************/
  18          unsigned char xdata MAC_ID[6]           = {0}; 
  19          unsigned char xdata MAC_ID_DST[6]       = {0}; 
  20          
  21          //设备锁标志
  22          bit     deviceLock_flag = false;
  23          
  24          /*MAC更新*/
  25          void MAC_ID_Relaes(void){
  26   1              
  27   1              u8 code *id_ptr = ROMADDR_ROM_STC_ID;
  28   1      
  29   1              memcpy(MAC_ID, id_ptr - 6, 6); //顺序向前，往前读，只取后六位
  30   1      
  31   1      //      memcpy(MAC_ID, id_ptr - 6, 6); 
  32   1      //      memcpy(MAC_ID, MACID_test, 6); 
  33   1      }
  34          
  35          void portCtrlEachOther_Reales(void){
  36   1      
  37   1              EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther, CTRLEATHER_PORT, 3);
  38   1      }
  39          
  40          void devLockInfo_Reales(void){
  41   1      
  42   1              u8 xdata deviceLock_IF = 0;
  43   1      
  44   1              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
  45   1              
  46   1              (deviceLock_IF)?(deviceLock_flag = 1):(deviceLock_flag = 0);
  47   1      }
  48          
  49          /*获取当前开关类型对应有效操作位*/
  50          u8 switchTypeReserve_GET(void){
  51   1      
  52   1              u8 act_Reserve = 0x07;
  53   1      
C51 COMPILER V9.54   DATAMANAGE                                                            09/07/2018 18:15:39 PAGE 2   

  54   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT3){
  55   2                      
  56   2                      act_Reserve = 0x07;
  57   2                      
  58   2              }else
  59   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT2){
  60   2                      
  61   2                      act_Reserve = 0x03;
  62   2              
  63   2              }else
  64   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1){
  65   2              
  66   2                      act_Reserve = 0x01;
  67   2              }
  68   1              
  69   1              return act_Reserve;
  70   1      }
  71          
  72          /*场景号对应EEPROM存储索引号查找*/
  73          u8 swScenarioNum_findFromEEPROM(bit vacancyFind_IF, u8 scenarioNum){ //是否为空位查找 否则指定场景号查找
  74   1      
  75   1              u8 loop = 0;
  76   1              u8 xdata datsTemp[SW_SCENCRAIO_LEN] = {0};
  77   1              
  78   1              EEPROM_read_n(EEPROM_ADDR_swScenarioNum, datsTemp, SW_SCENCRAIO_LEN);
  79   1              for(loop = 0; loop < SW_SCENCRAIO_LEN; loop ++){
  80   2              
  81   2                      if(vacancyFind_IF){ //查找空位
  82   3                      
  83   3                              if(0 == datsTemp[loop] || 0xff == datsTemp[loop])break;
  84   3                      
  85   3                      }else{  //查找指定场景编号
  86   3                      
  87   3                              if(scenarioNum == datsTemp[loop])break;
  88   3                      }
  89   2              }
  90   1              
  91   1              if(loop < SW_SCENCRAIO_LEN){
  92   2              
  93   2                      return loop; //索引可查 返回索引
  94   2                      
  95   2              }else{
  96   2              
  97   2                      return SW_SCENCRAIO_INSERTINVALID; //索引不可查 返回无效值
  98   2              }
  99   1      }
 100          
 101          /*场景存储*/
 102          bit swScenario_oprateSave(u8 scenarioNum, u8 swAct){
 103   1      
 104   1              u8 datsTemp = 0;
 105   1              u8 insert = 0;
 106   1              
 107   1              insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 108   1              if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则更改对应响应状态
 109   2              
 110   2                      datsTemp = swAct;
 111   2                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 112   2                      
 113   2              }else{ //场景编号不可查到则新增
 114   2                      
 115   2                      insert = swScenarioNum_findFromEEPROM(1, 0); //查空位
C51 COMPILER V9.54   DATAMANAGE                                                            09/07/2018 18:15:39 PAGE 3   

 116   2                      if(SW_SCENCRAIO_INSERTINVALID != insert){ //有空位则新增
 117   3                      
 118   3                              datsTemp = swAct;
 119   3                              coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 120   3                              datsTemp = scenarioNum;
 121   3                              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 122   3                      
 123   3                      }else{ //无空位返回失败
 124   3                      
 125   3                              return 0;
 126   3                      }
 127   2              }
 128   1              
 129   1              return 1;
 130   1      }
 131          
 132          /*场景删除*/
 133          bit swScenario_oprateDele(u8 scenarioNum){
 134   1      
 135   1              u8 datsTemp = 0;
 136   1              u8 insert = 0;
 137   1              
 138   1              insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 139   1              
 140   1              if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则执行删除
 141   2              
 142   2                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 143   2                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 144   2                      
 145   2                      return 1;
 146   2                      
 147   2              }else{
 148   2              
 149   2                      return 0;
 150   2              }
 151   1      }
 152          
 153          /*场景对应响应动作查询*/
 154          u8 swScenario_oprateCheck(u8 scenarioNum){
 155   1      
 156   1              u8 datsTemp = 0;
 157   1              u8 insert = 0;
 158   1              
 159   1              insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 160   1              
 161   1              if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则执行删除
 162   2                      
 163   2                      EEPROM_read_n(EEPROM_ADDR_swScenarioAct, &datsTemp, 1); //读取场景对应动作并返回
 164   2                      return datsTemp;
 165   2                      
 166   2              }else{
 167   2              
 168   2                      return SW_SCENCRAIO_ACTINVALID; //场景号无效不可查 返回无效响应动作值
 169   2              }
 170   1      }
 171          
 172          void Factory_recover(void){
 173   1              
 174   1              u8 xdata datsTemp[EEPROM_USE_OF_NUMBER] = {0};
 175   1              
 176   1              coverEEPROM_write_n(EEPROM_ADDR_START, datsTemp, EEPROM_USE_OF_NUMBER); //首次启动EEPROM擦除
 177   1              datsTemp[0] = BIRTHDAY_FLAG;
C51 COMPILER V9.54   DATAMANAGE                                                            09/07/2018 18:15:39 PAGE 4   

 178   1              coverEEPROM_write_n(EEPROM_ADDR_BirthdayMark, &datsTemp[0], 1); 
 179   1              
 180   1              delayMs(10);
 181   1              
 182   1      //      ((void(code *)(void))0x0000)();
 183   1      }
 184          
 185          void birthDay_Judge(void){
 186   1      
 187   1              u8 xdata datsTemp = 0;
 188   1              
 189   1              EEPROM_read_n(EEPROM_ADDR_BirthdayMark, &datsTemp, 1);
 190   1              if(datsTemp != BIRTHDAY_FLAG){
 191   2              
 192   2                      Factory_recover();//首次启动EEPROM擦除
 193   2              }
 194   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    511    ----
   CONSTANT SIZE    =    159    ----
   XDATA SIZE       =     12     161
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
