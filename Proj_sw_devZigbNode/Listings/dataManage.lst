C51 COMPILER V9.54   DATAMANAGE                                                            09/30/2018 16:43:38 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DATAMANAGE
OBJECT MODULE PLACED IN .\Output\dataManage.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Usr\dataManage.c OMF2 ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr
                    -;.\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\dataManage.lst) OBJECT(.\Output\
                    -dataManage.obj)

line level    source

   1          #include "dataManage.h"
   2          
   3          #include "STC15Fxxxx.H"
   4          
   5          #include "eeprom.h"
   6          #include "delay.h"
   7          
   8          #include "stdio.h"
   9          #include "string.h"
  10          
  11          #include "Tips.h"
  12          
  13          u8 SWITCH_TYPE = SWITCH_TYPE_SWBIT3;
  14          u8 DEV_actReserve = 0x01;
  15          
  16          //u8 CTRLEATHER_PORT[clusterNum_usr] = {0x1A, 0x1B, 0x1C};
  17          u8 CTRLEATHER_PORT[clusterNum_usr] = {0, 0, 0};
  18          
  19          /********************本地文件变量创建区******************/
  20          unsigned char xdata MAC_ID[6]           = {0}; 
  21          unsigned char xdata MAC_ID_DST[6]       = {1,1,1,1,1,1};  //远端MAC地址默认全是1，全是0的话影响服务器解析
  22          
  23          //设备锁标志
  24          bit     deviceLock_flag = false;
  25          
  26          /*MAC更新*/
  27          void MAC_ID_Relaes(void){
  28   1              
  29   1              u8 code *id_ptr = ROMADDR_ROM_STC_ID;
  30   1      
  31   1              memcpy(MAC_ID, id_ptr - 6, 6); //顺序向前，往前读，只取后六位
  32   1      
  33   1      //      memcpy(MAC_ID, id_ptr - 6, 6); 
  34   1      //      memcpy(MAC_ID, MACID_test, 6); 
  35   1      }
  36          
  37          void portCtrlEachOther_Reales(void){
  38   1      
  39   1              EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther, CTRLEATHER_PORT, 3);
  40   1      }
  41          
  42          void devLockInfo_Reales(void){
  43   1      
  44   1              u8 xdata deviceLock_IF = 0;
  45   1      
  46   1              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
  47   1              
  48   1              (deviceLock_IF)?(deviceLock_flag = 1):(deviceLock_flag = 0);
  49   1      }
  50          
  51          /*获取当前开关类型对应有效操作位*/
  52          u8 switchTypeReserve_GET(void){
  53   1      
C51 COMPILER V9.54   DATAMANAGE                                                            09/30/2018 16:43:38 PAGE 2   

  54   1              u8 act_Reserve = 0x07;
  55   1      
  56   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT3){
  57   2                      
  58   2                      act_Reserve = 0x07;
  59   2                      
  60   2              }else
  61   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT2){
  62   2                      
  63   2                      act_Reserve = 0x03;
  64   2              
  65   2              }else
  66   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1){
  67   2              
  68   2                      act_Reserve = 0x01;
  69   2              }
  70   1              
  71   1              return act_Reserve;
  72   1      }
  73          
  74          ///*场景号对应EEPROM存储索引号查找*/
  75          //u8 swScenarioNum_findFromEEPROM(bit vacancyFind_IF, u8 scenarioNum){ //是否为空位查找 否则指定场景号查找
  76          
  77          //      u8 loop = 0;
  78          //      u8 xdata datsTemp[SW_SCENCRAIO_LEN] = {0};
  79          //      
  80          //      EEPROM_read_n(EEPROM_ADDR_swScenarioNum, datsTemp, SW_SCENCRAIO_LEN);
  81          //      for(loop = 0; loop < SW_SCENCRAIO_LEN; loop ++){
  82          //      
  83          //              if(vacancyFind_IF){ //查找空位
  84          //              
  85          //                      if(0 == datsTemp[loop] || 0xff == datsTemp[loop])break;
  86          //              
  87          //              }else{  //查找指定场景编号
  88          //              
  89          //                      if(scenarioNum == datsTemp[loop])break;
  90          //              }
  91          //      }
  92          //      
  93          //      if(loop < SW_SCENCRAIO_LEN){
  94          //      
  95          //              return loop; //索引可查 返回索引
  96          //              
  97          //      }else{
  98          //      
  99          //              return SW_SCENCRAIO_INSERTINVALID; //索引不可查 返回无效值
 100          //      }
 101          //}
 102          
 103          ///*场景存储*/
 104          //bit swScenario_oprateSave(u8 scenarioNum, u8 swAct){
 105          
 106          //      u8 datsTemp = 0;
 107          //      u8 insert = 0;
 108          //      
 109          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 110          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则更改对应响应状态
 111          //      
 112          //              datsTemp = swAct;
 113          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 114          //              
 115          //      }else{ //场景编号不可查到则新增
C51 COMPILER V9.54   DATAMANAGE                                                            09/30/2018 16:43:38 PAGE 3   

 116          //              
 117          //              insert = swScenarioNum_findFromEEPROM(1, 0); //查空位
 118          //              if(SW_SCENCRAIO_INSERTINVALID != insert){ //有空位则新增
 119          //              
 120          //                      datsTemp = swAct;
 121          //                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 122          //                      datsTemp = scenarioNum;
 123          //                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 124          //              
 125          //              }else{ //无空位返回失败
 126          //              
 127          //                      return 0;
 128          //              }
 129          //      }
 130          //      
 131          //      return 1;
 132          //}
 133          
 134          ///*场景删除*/
 135          //bit swScenario_oprateDele(u8 scenarioNum){
 136          
 137          //      u8 datsTemp = 0;
 138          //      u8 insert = 0;
 139          //      
 140          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 141          //      
 142          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则执行删除
 143          //      
 144          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 145          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 146          //              
 147          //              return 1;
 148          //              
 149          //      }else{
 150          //      
 151          //              return 0;
 152          //      }
 153          //}
 154          
 155          ///*场景对应响应动作查询*/
 156          //u8 swScenario_oprateCheck(u8 scenarioNum){
 157          
 158          //      u8 datsTemp = 0;
 159          //      u8 insert = 0;
 160          //      
 161          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 162          //      
 163          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则执行删除
 164          //              
 165          //              EEPROM_read_n(EEPROM_ADDR_swScenarioAct, &datsTemp, 1); //读取场景对应动作并返回
 166          //              return datsTemp;
 167          //              
 168          //      }else{
 169          //      
 170          //              return SW_SCENCRAIO_ACTINVALID; //场景号无效不可查 返回无效响应动作值
 171          //      }
 172          //}
 173          
 174          void Factory_recover(void){
 175   1              
 176   1              u8 xdata datsTemp[EEPROM_USE_OF_NUMBER] = {0};
 177   1              
C51 COMPILER V9.54   DATAMANAGE                                                            09/30/2018 16:43:38 PAGE 4   

 178   1              coverEEPROM_write_n(EEPROM_ADDR_START, datsTemp, EEPROM_USE_OF_NUMBER); //首次启动EEPROM擦除
 179   1              datsTemp[0] = BIRTHDAY_FLAG;
 180   1              coverEEPROM_write_n(EEPROM_ADDR_BirthdayMark, &datsTemp[0], 1); //打出生标记
 181   1              
 182   1              datsTemp[0] = TIPSBKCOLOR_DEFAULT_ON; //背光初始化
 183   1              coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround, &datsTemp[0], 1);
 184   1              datsTemp[0] = TIPSBKCOLOR_DEFAULT_OFF;
 185   1              coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround + 1, &datsTemp[0], 1);  
 186   1              
 187   1              datsTemp[0] = 0;
 188   1              coverEEPROM_write_n(EEPROM_ADDR_portCtrlEachOther, &datsTemp[0], clusterNum_usr);
 189   1              
 190   1              delayMs(10);
 191   1              
 192   1      //      ((void(code *)(void))0x0000)(); //重启
 193   1      }
 194          
 195          void birthDay_Judge(void){
 196   1      
 197   1              u8 xdata datsTemp = 0;
 198   1              
 199   1              EEPROM_read_n(EEPROM_ADDR_BirthdayMark, &datsTemp, 1);
 200   1              if(datsTemp != BIRTHDAY_FLAG){
 201   2              
 202   2                      Factory_recover();//首次启动EEPROM擦除
 203   2              }
 204   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    283    ----
   CONSTANT SIZE    =    128    ----
   XDATA SIZE       =     12     130
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
