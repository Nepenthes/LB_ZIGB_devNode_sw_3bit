C51 COMPILER V9.54   DATAMANAGE                                                            12/20/2018 14:37:17 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DATAMANAGE
OBJECT MODULE PLACED IN .\Output\dataManage.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Usr\dataManage.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\
                    -std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\dataManage.lst) OBJECT(.\Output\dataManage.ob
                    -j)

line level    source

   1          #include "dataManage.h"
   2          
   3          #include "STC15Fxxxx.H"
   4          
   5          #include "eeprom.h"
   6          #include "delay.h"
   7          #include "USART.h"
   8          
   9          #include "stdio.h"
  10          #include "string.h"
  11          
  12          #include "Tips.h"
  13          
  14          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
               u8 SWITCH_TYPE = SWITCH_TYPE_FANS;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
               u8 SWITCH_TYPE = SWITCH_TYPE_dIMMER;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
               u8 SWITCH_TYPE = SWITCH_TYPE_SOCKETS;
              #else
  21           u8 SWITCH_TYPE = SWITCH_TYPE_CURTAIN;
  22          #endif
  23          
  24          u8 DEV_actReserve = 0x01;
  25          
  26          //u8 CTRLEATHER_PORT[clusterNum_usr] = {0x1A, 0x1B, 0x1C};
  27          u8 CTRLEATHER_PORT[clusterNum_usr] = {0, 0, 0};
  28          
  29          u16 dev_currentPanid = 0;
  30          
  31          #if(DEBUG_LOGOUT_EN == 1)       
  32           u8 xdata log_buf[LOGBUFF_LEN] = {0};
  33          #endif          
  34          
  35          /********************本地文件变量创建区******************/
  36          unsigned char xdata MAC_ID[6]           = {0}; 
  37          unsigned char xdata MAC_ID_DST[6]       = {1,1,1,1,1,1};  //远端MAC地址默认全是1，全是0的话影响服务器解析
  38          
  39          #if(DATASAVE_INTLESS_ENABLEIF)
  40           u8 xdata loopInsert_relayStatusRealTime_record = 0; //继电器状态实时记录游标
  41          #endif
  42          
  43          //设备锁标志
  44          bit     deviceLock_flag = false;
  45          
  46          /*MAC更新*/
  47          void MAC_ID_Relaes(void){
  48   1              
  49   1              u8 code *id_ptr = ROMADDR_ROM_STC_ID;
  50   1      
  51   1              memcpy(MAC_ID, id_ptr - 5, 6); //起点在前，向后读，只取后六位
  52   1              
  53   1      #if(DEBUG_LOGOUT_EN == 1)       
C51 COMPILER V9.54   DATAMANAGE                                                            12/20/2018 14:37:17 PAGE 2   

  54   1              { //输出打印，谨记 用后注释，否则占用大量代码空间
  55   2      
  56   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
  57   2                      
  58   2                      sprintf(log_buf, "mac_reales:%02X %02X %02X ", (int)MAC_ID[0], (int)MAC_ID[1], (int)MAC_ID[2]);
  59   2                      PrintString1_logOut(log_buf);
  60   2                      sprintf(log_buf, "%02X %02X %02X.\n", (int)MAC_ID[3], (int)MAC_ID[4], (int)MAC_ID[5]);
  61   2                      PrintString1_logOut(log_buf);
  62   2              }
  63   1      #endif
  64   1      
  65   1      //      memcpy(MAC_ID, id_ptr - 5, 6); 
  66   1      //      memcpy(MAC_ID, MACID_test, 6); 
  67   1      }
  68          
  69          void portCtrlEachOther_Reales(void){
  70   1      
  71   1              EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther, CTRLEATHER_PORT, 3);
  72   1      }
  73          
  74          void devLockInfo_Reales(void){
  75   1      
  76   1              u8 xdata deviceLock_IF = 0;
  77   1      
  78   1              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
  79   1              
  80   1              (deviceLock_IF)?(deviceLock_flag = 1):(deviceLock_flag = 0);
  81   1      }
  82          
  83          /*获取当前开关类型对应有效操作位*/
  84          u8 switchTypeReserve_GET(void){
  85   1      
  86   1              u8 act_Reserve = 0x07;
  87   1      
  88   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      act_Reserve = 0x01;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      act_Reserve = 0x07;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      act_Reserve = 0x07;
              #else
  95   1              switch(SWITCH_TYPE){
  96   2              
  97   2                      case SWITCH_TYPE_SWBIT1:{
  98   3                      
  99   3                              act_Reserve = 0x02;
 100   3                      
 101   3                      }break;
 102   2                      
 103   2                      case SWITCH_TYPE_SWBIT2:{
 104   3                      
 105   3                              act_Reserve = 0x05;
 106   3                      
 107   3                      }break;
 108   2                      
 109   2                      case SWITCH_TYPE_SWBIT3:
 110   2                      case SWITCH_TYPE_CURTAIN:{
 111   3                      
 112   3                              act_Reserve = 0x07;
 113   3                      
 114   3                      }break;
 115   2              }
C51 COMPILER V9.54   DATAMANAGE                                                            12/20/2018 14:37:17 PAGE 3   

 116   1              
 117   1      #endif
 118   1              
 119   1              return act_Reserve;
 120   1      }
 121          
 122          ///*场景号对应EEPROM存储索引号查找*/
 123          //u8 swScenarioNum_findFromEEPROM(bit vacancyFind_IF, u8 scenarioNum){ //是否为空位查找 否则指定场景号查找
 124          
 125          //      u8 loop = 0;
 126          //      u8 xdata datsTemp[SW_SCENCRAIO_LEN] = {0};
 127          //      
 128          //      EEPROM_read_n(EEPROM_ADDR_swScenarioNum, datsTemp, SW_SCENCRAIO_LEN);
 129          //      for(loop = 0; loop < SW_SCENCRAIO_LEN; loop ++){
 130          //      
 131          //              if(vacancyFind_IF){ //查找空位
 132          //              
 133          //                      if(0 == datsTemp[loop] || 0xff == datsTemp[loop])break;
 134          //              
 135          //              }else{  //查找指定场景编号
 136          //              
 137          //                      if(scenarioNum == datsTemp[loop])break;
 138          //              }
 139          //      }
 140          //      
 141          //      if(loop < SW_SCENCRAIO_LEN){
 142          //      
 143          //              return loop; //索引可查 返回索引
 144          //              
 145          //      }else{
 146          //      
 147          //              return SW_SCENCRAIO_INSERTINVALID; //索引不可查 返回无效值
 148          //      }
 149          //}
 150          
 151          ///*场景存储*/
 152          //bit swScenario_oprateSave(u8 scenarioNum, u8 swAct){
 153          
 154          //      u8 datsTemp = 0;
 155          //      u8 insert = 0;
 156          //      
 157          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 158          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则更改对应响应状态
 159          //      
 160          //              datsTemp = swAct;
 161          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 162          //              
 163          //      }else{ //场景编号不可查到则新增
 164          //              
 165          //              insert = swScenarioNum_findFromEEPROM(1, 0); //查空位
 166          //              if(SW_SCENCRAIO_INSERTINVALID != insert){ //有空位则新增
 167          //              
 168          //                      datsTemp = swAct;
 169          //                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 170          //                      datsTemp = scenarioNum;
 171          //                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 172          //              
 173          //              }else{ //无空位返回失败
 174          //              
 175          //                      return 0;
 176          //              }
 177          //      }
C51 COMPILER V9.54   DATAMANAGE                                                            12/20/2018 14:37:17 PAGE 4   

 178          //      
 179          //      return 1;
 180          //}
 181          
 182          ///*场景删除*/
 183          //bit swScenario_oprateDele(u8 scenarioNum){
 184          
 185          //      u8 datsTemp = 0;
 186          //      u8 insert = 0;
 187          //      
 188          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 189          //      
 190          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则执行删除
 191          //      
 192          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 193          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 194          //              
 195          //              return 1;
 196          //              
 197          //      }else{
 198          //      
 199          //              return 0;
 200          //      }
 201          //}
 202          
 203          ///*场景对应响应动作查询*/
 204          //u8 swScenario_oprateCheck(u8 scenarioNum){
 205          
 206          //      u8 datsTemp = 0;
 207          //      u8 insert = 0;
 208          //      
 209          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 210          //      
 211          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则执行删除
 212          //              
 213          //              EEPROM_read_n(EEPROM_ADDR_swScenarioAct, &datsTemp, 1); //读取场景对应动作并返回
 214          //              return datsTemp;
 215          //              
 216          //      }else{
 217          //      
 218          //              return SW_SCENCRAIO_ACTINVALID; //场景号无效不可查 返回无效响应动作值
 219          //      }
 220          //}
 221          
 222          void Factory_recover(void){
 223   1              
 224   1              u8 xdata datsTemp[EEPROM_USE_OF_NUMBER] = {0};
 225   1              
 226   1              coverEEPROM_write_n(EEPROM_ADDR_START, datsTemp, EEPROM_USE_OF_NUMBER); //首次启动EEPROM擦除
 227   1              datsTemp[0] = BIRTHDAY_FLAG;
 228   1              coverEEPROM_write_n(EEPROM_ADDR_BirthdayMark, &datsTemp[0], 1); //打出生标记
 229   1              
 230   1              datsTemp[0] = TIPSBKCOLOR_DEFAULT_ON; //背光初始化
 231   1              coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround, &datsTemp[0], 1);
 232   1              datsTemp[0] = TIPSBKCOLOR_DEFAULT_OFF;
 233   1              coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround + 1, &datsTemp[0], 1);  
 234   1              
 235   1              datsTemp[0] = 10; //窗帘轨道时间 初始给10
 236   1              coverEEPROM_write_n(EEPROM_ADDR_curtainOrbitalPeriod, &datsTemp[0], 1);
 237   1              
 238   1              datsTemp[0] = 0;
 239   1              coverEEPROM_write_n(EEPROM_ADDR_portCtrlEachOther, &datsTemp[0], clusterNum_usr);
C51 COMPILER V9.54   DATAMANAGE                                                            12/20/2018 14:37:17 PAGE 5   

 240   1              
 241   1              memset(CTRLEATHER_PORT, 0, clusterNum_usr); //运行缓存清空
 242   1              
 243   1              delayMs(10);
 244   1              
 245   1              ((void(code *)(void))0x0000)(); //重启
 246   1      }
 247          
 248          void birthDay_Judge(void){
 249   1      
 250   1              u8 xdata datsTemp = 0;
 251   1              
 252   1              EEPROM_read_n(EEPROM_ADDR_BirthdayMark, &datsTemp, 1);
 253   1              if(datsTemp != BIRTHDAY_FLAG){
 254   2              
 255   2                      Factory_recover(); //首次启动EEPROM擦除
 256   2              }
 257   1      }
 258          
 259          #if(DATASAVE_INTLESS_ENABLEIF)
 260          void devParamDtaaSave_relayStatusRealTime(u8 currentRelayStatus){
 261   1              
 262   1              u8 xdata dataRead_temp[RECORDPERIOD_OPREATION_LOOP] = {0};
 263   1              
 264   1              if(loopInsert_relayStatusRealTime_record >= RECORDPERIOD_OPREATION_LOOP){
 265   2              
 266   2                      loopInsert_relayStatusRealTime_record = 0;
 267   2                      EEPROM_SectorErase(EEPROM_ADDR_STATUSRELAY); //擦扇区
 268   2              }
 269   1              
 270   1              dataRead_temp[loopInsert_relayStatusRealTime_record ++] = currentRelayStatus;
 271   1              
 272   1              EEPROM_write_n(EEPROM_ADDR_STATUSRELAY, dataRead_temp, loopInsert_relayStatusRealTime_record);
 273   1      }
 274          
 275          u8 devDataRecovery_relayStatus(void){
 276   1      
 277   1              u8 xdata dataRead_temp[RECORDPERIOD_OPREATION_LOOP] = {0};
 278   1              u8 xdata loop = 0;
 279   1              u8 xdata res = 0;
 280   1              
 281   1              EEPROM_read_n(EEPROM_ADDR_STATUSRELAY, dataRead_temp, RECORDPERIOD_OPREATION_LOOP);
 282   1              
 283   1              for(loop = 0; loop < RECORDPERIOD_OPREATION_LOOP; loop ++){
 284   2              
 285   2                      if(dataRead_temp[loop] == 0xff){
 286   3                      
 287   3                              (!loop)?(res = 0):(res = dataRead_temp[loop - 1]);
 288   3      #if(DEBUG_LOGOUT_EN == 1)       
 289   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 290   4      
 291   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 292   4                                      
 293   4                                      sprintf(log_buf, "insert catch: %d, val:%02X.\n", (int)loop, (int)res);
 294   4                                      PrintString1_logOut(log_buf);
 295   4                              }
 296   3      #endif
 297   3                              break;
 298   3                      }
 299   2              }
 300   1              
 301   1              EEPROM_SectorErase(EEPROM_ADDR_STATUSRELAY); //擦扇区
C51 COMPILER V9.54   DATAMANAGE                                                            12/20/2018 14:37:17 PAGE 6   

 302   1              
 303   1              return res;
 304   1      }
 305          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    703    ----
   CONSTANT SIZE    =    401    ----
   XDATA SIZE       =     77     332
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
