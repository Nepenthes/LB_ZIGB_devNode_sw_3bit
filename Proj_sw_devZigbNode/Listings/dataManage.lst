C51 COMPILER V9.54   DATAMANAGE                                                            11/02/2018 15:47:41 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DATAMANAGE
OBJECT MODULE PLACED IN .\Output\dataManage.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Usr\dataManage.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\
                    -std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\dataManage.lst) OBJECT(.\Output\dataManage.ob
                    -j)

line level    source

   1          #include "dataManage.h"
   2          
   3          #include "STC15Fxxxx.H"
   4          
   5          #include "eeprom.h"
   6          #include "delay.h"
   7          #include "USART.h"
   8          
   9          #include "stdio.h"
  10          #include "string.h"
  11          
  12          #include "Tips.h"
  13          
  14          u8 SWITCH_TYPE = SWITCH_TYPE_SWBIT3;
  15          u8 DEV_actReserve = 0x01;
  16          
  17          //u8 CTRLEATHER_PORT[clusterNum_usr] = {0x1A, 0x1B, 0x1C};
  18          u8 CTRLEATHER_PORT[clusterNum_usr] = {0, 0, 0};
  19          
  20          #if(DEBUG_LOGOUT_EN == 1)       
  21           u8 xdata log_buf[LOGBUFF_LEN] = {0};
  22          #endif          
  23          
  24          /********************本地文件变量创建区******************/
  25          unsigned char xdata MAC_ID[6]           = {0}; 
  26          unsigned char xdata MAC_ID_DST[6]       = {1,1,1,1,1,1};  //远端MAC地址默认全是1，全是0的话影响服务器解析
  27          
  28          //设备锁标志
  29          bit     deviceLock_flag = false;
  30          
  31          /*MAC更新*/
  32          void MAC_ID_Relaes(void){
  33   1              
  34   1              u8 code *id_ptr = ROMADDR_ROM_STC_ID;
  35   1      
  36   1              memcpy(MAC_ID, id_ptr - 5, 6); //起点在前，向后读，只取后六位
  37   1              
  38   1      #if(DEBUG_LOGOUT_EN == 1)       
  39   1              { //输出打印，谨记 用后注释，否则占用大量代码空间
  40   2                      u8 xdata log_buf[64];
  41   2                      
  42   2                      sprintf(log_buf, "mac_reales:%02X %02X %02X ", (int)MAC_ID[0], (int)MAC_ID[1], (int)MAC_ID[2]);
  43   2                      PrintString1_logOut(log_buf);
  44   2                      sprintf(log_buf, "%02X %02X %02X.\n", (int)MAC_ID[3], (int)MAC_ID[4], (int)MAC_ID[5]);
  45   2                      PrintString1_logOut(log_buf);
  46   2              }
  47   1      #endif
  48   1      
  49   1      //      memcpy(MAC_ID, id_ptr - 6, 6); 
  50   1      //      memcpy(MAC_ID, MACID_test, 6); 
  51   1      }
  52          
  53          void portCtrlEachOther_Reales(void){
C51 COMPILER V9.54   DATAMANAGE                                                            11/02/2018 15:47:41 PAGE 2   

  54   1      
  55   1              EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther, CTRLEATHER_PORT, 3);
  56   1      }
  57          
  58          void devLockInfo_Reales(void){
  59   1      
  60   1              u8 xdata deviceLock_IF = 0;
  61   1      
  62   1              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
  63   1              
  64   1              (deviceLock_IF)?(deviceLock_flag = 1):(deviceLock_flag = 0);
  65   1      }
  66          
  67          /*获取当前开关类型对应有效操作位*/
  68          u8 switchTypeReserve_GET(void){
  69   1      
  70   1              u8 act_Reserve = 0x07;
  71   1      
  72   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT3){
  73   2                      
  74   2                      act_Reserve = 0x07;
  75   2                      
  76   2              }else
  77   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT2){
  78   2                      
  79   2                      act_Reserve = 0x03;
  80   2              
  81   2              }else
  82   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1){
  83   2              
  84   2                      act_Reserve = 0x01;
  85   2              }
  86   1              
  87   1              return act_Reserve;
  88   1      }
  89          
  90          ///*场景号对应EEPROM存储索引号查找*/
  91          //u8 swScenarioNum_findFromEEPROM(bit vacancyFind_IF, u8 scenarioNum){ //是否为空位查找 否则指定场景号查找
  92          
  93          //      u8 loop = 0;
  94          //      u8 xdata datsTemp[SW_SCENCRAIO_LEN] = {0};
  95          //      
  96          //      EEPROM_read_n(EEPROM_ADDR_swScenarioNum, datsTemp, SW_SCENCRAIO_LEN);
  97          //      for(loop = 0; loop < SW_SCENCRAIO_LEN; loop ++){
  98          //      
  99          //              if(vacancyFind_IF){ //查找空位
 100          //              
 101          //                      if(0 == datsTemp[loop] || 0xff == datsTemp[loop])break;
 102          //              
 103          //              }else{  //查找指定场景编号
 104          //              
 105          //                      if(scenarioNum == datsTemp[loop])break;
 106          //              }
 107          //      }
 108          //      
 109          //      if(loop < SW_SCENCRAIO_LEN){
 110          //      
 111          //              return loop; //索引可查 返回索引
 112          //              
 113          //      }else{
 114          //      
 115          //              return SW_SCENCRAIO_INSERTINVALID; //索引不可查 返回无效值
C51 COMPILER V9.54   DATAMANAGE                                                            11/02/2018 15:47:41 PAGE 3   

 116          //      }
 117          //}
 118          
 119          ///*场景存储*/
 120          //bit swScenario_oprateSave(u8 scenarioNum, u8 swAct){
 121          
 122          //      u8 datsTemp = 0;
 123          //      u8 insert = 0;
 124          //      
 125          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 126          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则更改对应响应状态
 127          //      
 128          //              datsTemp = swAct;
 129          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 130          //              
 131          //      }else{ //场景编号不可查到则新增
 132          //              
 133          //              insert = swScenarioNum_findFromEEPROM(1, 0); //查空位
 134          //              if(SW_SCENCRAIO_INSERTINVALID != insert){ //有空位则新增
 135          //              
 136          //                      datsTemp = swAct;
 137          //                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 138          //                      datsTemp = scenarioNum;
 139          //                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 140          //              
 141          //              }else{ //无空位返回失败
 142          //              
 143          //                      return 0;
 144          //              }
 145          //      }
 146          //      
 147          //      return 1;
 148          //}
 149          
 150          ///*场景删除*/
 151          //bit swScenario_oprateDele(u8 scenarioNum){
 152          
 153          //      u8 datsTemp = 0;
 154          //      u8 insert = 0;
 155          //      
 156          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
 157          //      
 158          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则执行删除
 159          //      
 160          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 161          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 162          //              
 163          //              return 1;
 164          //              
 165          //      }else{
 166          //      
 167          //              return 0;
 168          //      }
 169          //}
 170          
 171          ///*场景对应响应动作查询*/
 172          //u8 swScenario_oprateCheck(u8 scenarioNum){
 173          
 174          //      u8 datsTemp = 0;
 175          //      u8 insert = 0;
 176          //      
 177          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //查场景编号
C51 COMPILER V9.54   DATAMANAGE                                                            11/02/2018 15:47:41 PAGE 4   

 178          //      
 179          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //场景编号可查到则执行删除
 180          //              
 181          //              EEPROM_read_n(EEPROM_ADDR_swScenarioAct, &datsTemp, 1); //读取场景对应动作并返回
 182          //              return datsTemp;
 183          //              
 184          //      }else{
 185          //      
 186          //              return SW_SCENCRAIO_ACTINVALID; //场景号无效不可查 返回无效响应动作值
 187          //      }
 188          //}
 189          
 190          void Factory_recover(void){
 191   1              
 192   1              u8 xdata datsTemp[EEPROM_USE_OF_NUMBER] = {0};
 193   1              
 194   1              coverEEPROM_write_n(EEPROM_ADDR_START, datsTemp, EEPROM_USE_OF_NUMBER); //首次启动EEPROM擦除
 195   1              datsTemp[0] = BIRTHDAY_FLAG;
 196   1              coverEEPROM_write_n(EEPROM_ADDR_BirthdayMark, &datsTemp[0], 1); //打出生标记
 197   1              
 198   1              datsTemp[0] = TIPSBKCOLOR_DEFAULT_ON; //背光初始化
 199   1              coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround, &datsTemp[0], 1);
 200   1              datsTemp[0] = TIPSBKCOLOR_DEFAULT_OFF;
 201   1              coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround + 1, &datsTemp[0], 1);  
 202   1              
 203   1              datsTemp[0] = 0;
 204   1              coverEEPROM_write_n(EEPROM_ADDR_portCtrlEachOther, &datsTemp[0], clusterNum_usr);
 205   1              
 206   1              memset(CTRLEATHER_PORT, 0, clusterNum_usr); //运行缓存清空
 207   1              
 208   1              delayMs(10);
 209   1              
 210   1              ((void(code *)(void))0x0000)(); //重启
 211   1      }
 212          
 213          void birthDay_Judge(void){
 214   1      
 215   1              u8 xdata datsTemp = 0;
 216   1              
 217   1              EEPROM_read_n(EEPROM_ADDR_BirthdayMark, &datsTemp, 1);
 218   1              if(datsTemp != BIRTHDAY_FLAG){
 219   2              
 220   2                      Factory_recover();//首次启动EEPROM擦除
 221   2              }
 222   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    401    ----
   CONSTANT SIZE    =    172    ----
   XDATA SIZE       =     76     194
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
