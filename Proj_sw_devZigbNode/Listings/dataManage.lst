C51 COMPILER V9.54   DATAMANAGE                                                            01/11/2019 12:04:13 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DATAMANAGE
OBJECT MODULE PLACED IN .\Output\dataManage.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Usr\dataManage.c OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\
                    -std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\dataManage.lst) OBJECT(.\Output\dataManage.ob
                    -j)

line level    source

   1          #include "dataManage.h"
   2          
   3          #include "STC15Fxxxx.H"
   4          
   5          #include "Relay.h"
   6          
   7          #include "eeprom.h"
   8          #include "delay.h"
   9          #include "USART.h"
  10          
  11          #include "stdio.h"
  12          #include "string.h"
  13          
  14          #include "Tips.h"
  15          
  16          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
               u8 SWITCH_TYPE = SWITCH_TYPE_FANS;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
               u8 SWITCH_TYPE = SWITCH_TYPE_dIMMER;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
               u8 SWITCH_TYPE = SWITCH_TYPE_SOCKETS;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
               u8 SWITCH_TYPE = SWITCH_TYPE_INFRARED;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
               u8 SWITCH_TYPE = SWITCH_TYPE_SCENARIO;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
               u8 SWITCH_TYPE = SWITCH_TYPE_HEATER;
              #else
  29           u8 SWITCH_TYPE = SWITCH_TYPE_CURTAIN;
  30          #endif
  31          
  32          u8 DEV_actReserve = 0x01;
  33          
  34          //u8 CTRLEATHER_PORT[clusterNum_usr] = {0x1A, 0x1B, 0x1C};
  35          u8 CTRLEATHER_PORT[clusterNum_usr] = {0, 0, 0};
  36          
  37          u16 dev_currentPanid = 0;
  38          
  39          #if(DEBUG_LOGOUT_EN == 1)       
  40           u8 idata log_buf[LOGBUFF_LEN] = {0};
  41          #endif          
  42          
  43          /********************±¾µØÎÄ¼þ±äÁ¿´´½¨Çø******************/
  44          unsigned char xdata MAC_ID[6]           = {0}; 
  45          unsigned char xdata MAC_ID_DST[6]       = {1,1,1,1,1,1};  //Ô¶¶ËMACµØÖ·Ä¬ÈÏÈ«ÊÇ1£¬È«ÊÇ0µÄ»°Ó°Ïì·þÎñÆ÷½âÎö
  46          
  47          #if(DATASAVE_INTLESS_ENABLEIF)
  48           u8 xdata loopInsert_relayStatusRealTime_record = 0; //¼ÌµçÆ÷×´Ì¬ÊµÊ±¼ÇÂ¼ÓÎ±ê
  49          #endif
  50          
  51          //Éè±¸Ëø±êÖ¾
  52          bit     deviceLock_flag = false;
  53          
C51 COMPILER V9.54   DATAMANAGE                                                            01/11/2019 12:04:13 PAGE 2   

  54          /*MAC¸üÐÂ*/
  55          void MAC_ID_Relaes(void){
  56   1              
  57   1              u8 code *id_ptr = ROMADDR_ROM_STC_ID;
  58   1      
  59   1              memcpy(MAC_ID, id_ptr - 5, 6); //ÆðµãÔÚÇ°£¬Ïòºó¶Á£¬Ö»È¡ºóÁùÎ»
  60   1              
  61   1      #if(DEBUG_LOGOUT_EN == 1)       
  62   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
  63   2      
  64   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
  65   2                      
  66   2                      sprintf(log_buf, "mac_reales:%02X %02X %02X ", (int)MAC_ID[0], (int)MAC_ID[1], (int)MAC_ID[2]);
  67   2                      PrintString1_logOut(log_buf);
  68   2                      sprintf(log_buf, "%02X %02X %02X.\n", (int)MAC_ID[3], (int)MAC_ID[4], (int)MAC_ID[5]);
  69   2                      PrintString1_logOut(log_buf);
  70   2              }
  71   1      #endif
  72   1      
  73   1      //      memcpy(MAC_ID, id_ptr - 5, 6); 
  74   1      //      memcpy(MAC_ID, MACID_test, 6); 
  75   1      }
  76          
  77          void portCtrlEachOther_Reales(void){
  78   1      
  79   1              EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther, CTRLEATHER_PORT, 3);
  80   1      }
  81          
  82          void devLockInfo_Reales(void){
  83   1      
  84   1              u8 xdata deviceLock_IF = 0;
  85   1      
  86   1              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
  87   1              
  88   1              (deviceLock_IF)?(deviceLock_flag = 1):(deviceLock_flag = 0);
  89   1      }
  90          
  91          /*»ñÈ¡µ±Ç°¿ª¹ØÀàÐÍ¶ÔÓ¦ÓÐÐ§²Ù×÷Î»*/
  92          u8 switchTypeReserve_GET(void){
  93   1      
  94   1              u8 act_Reserve = 0x07;
  95   1      
  96   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      act_Reserve = 0x01;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
                      act_Reserve = 0x01;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      act_Reserve = 0x07;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      act_Reserve = 0x07;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      act_Reserve = 0x07;
              #else
 107   1              switch(SWITCH_TYPE){
 108   2              
 109   2                      case SWITCH_TYPE_HEATER:
 110   2                      case SWITCH_TYPE_SWBIT1:{
 111   3                      
 112   3                              act_Reserve = 0x02;
 113   3                      
 114   3                      }break;
 115   2                      
C51 COMPILER V9.54   DATAMANAGE                                                            01/11/2019 12:04:13 PAGE 3   

 116   2                      case SWITCH_TYPE_SWBIT2:{
 117   3                      
 118   3                              act_Reserve = 0x05;
 119   3                      
 120   3                      }break;
 121   2                      
 122   2                      case SWITCH_TYPE_SWBIT3:
 123   2                      case SWITCH_TYPE_CURTAIN:{
 124   3                      
 125   3                              act_Reserve = 0x07;
 126   3                      
 127   3                      }break;
 128   2              }
 129   1              
 130   1      #endif
 131   1              
 132   1              return act_Reserve;
 133   1      }
 134          
 135          ///*³¡¾°ºÅ¶ÔÓ¦EEPROM´æ´¢Ë÷ÒýºÅ²éÕÒ*/
 136          //u8 swScenarioNum_findFromEEPROM(bit vacancyFind_IF, u8 scenarioNum){ //ÊÇ·ñÎª¿ÕÎ»²éÕÒ ·ñÔòÖ¸¶¨³¡¾°ºÅ²éÕÒ
 137          
 138          //      u8 loop = 0;
 139          //      u8 xdata datsTemp[SW_SCENCRAIO_LEN] = {0};
 140          //      
 141          //      EEPROM_read_n(EEPROM_ADDR_swScenarioNum, datsTemp, SW_SCENCRAIO_LEN);
 142          //      for(loop = 0; loop < SW_SCENCRAIO_LEN; loop ++){
 143          //      
 144          //              if(vacancyFind_IF){ //²éÕÒ¿ÕÎ»
 145          //              
 146          //                      if(0 == datsTemp[loop] || 0xff == datsTemp[loop])break;
 147          //              
 148          //              }else{  //²éÕÒÖ¸¶¨³¡¾°±àºÅ
 149          //              
 150          //                      if(scenarioNum == datsTemp[loop])break;
 151          //              }
 152          //      }
 153          //      
 154          //      if(loop < SW_SCENCRAIO_LEN){
 155          //      
 156          //              return loop; //Ë÷Òý¿É²é ·µ»ØË÷Òý
 157          //              
 158          //      }else{
 159          //      
 160          //              return SW_SCENCRAIO_INSERTINVALID; //Ë÷Òý²»¿É²é ·µ»ØÎÞÐ§Öµ
 161          //      }
 162          //}
 163          
 164          ///*³¡¾°´æ´¢*/
 165          //bit swScenario_oprateSave(u8 scenarioNum, u8 swAct){
 166          
 167          //      u8 datsTemp = 0;
 168          //      u8 insert = 0;
 169          //      
 170          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //²é³¡¾°±àºÅ
 171          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //³¡¾°±àºÅ¿É²éµ½Ôò¸ü¸Ä¶ÔÓ¦ÏìÓ¦×´Ì¬
 172          //      
 173          //              datsTemp = swAct;
 174          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 175          //              
 176          //      }else{ //³¡¾°±àºÅ²»¿É²éµ½ÔòÐÂÔö
 177          //              
C51 COMPILER V9.54   DATAMANAGE                                                            01/11/2019 12:04:13 PAGE 4   

 178          //              insert = swScenarioNum_findFromEEPROM(1, 0); //²é¿ÕÎ»
 179          //              if(SW_SCENCRAIO_INSERTINVALID != insert){ //ÓÐ¿ÕÎ»ÔòÐÂÔö
 180          //              
 181          //                      datsTemp = swAct;
 182          //                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 183          //                      datsTemp = scenarioNum;
 184          //                      coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 185          //              
 186          //              }else{ //ÎÞ¿ÕÎ»·µ»ØÊ§°Ü
 187          //              
 188          //                      return 0;
 189          //              }
 190          //      }
 191          //      
 192          //      return 1;
 193          //}
 194          
 195          ///*³¡¾°É¾³ý*/
 196          //bit swScenario_oprateDele(u8 scenarioNum){
 197          
 198          //      u8 datsTemp = 0;
 199          //      u8 insert = 0;
 200          //      
 201          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //²é³¡¾°±àºÅ
 202          //      
 203          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //³¡¾°±àºÅ¿É²éµ½ÔòÖ´ÐÐÉ¾³ý
 204          //      
 205          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioNum + insert, &datsTemp, 1);
 206          //              coverEEPROM_write_n(EEPROM_ADDR_swScenarioAct + insert, &datsTemp, 1);
 207          //              
 208          //              return 1;
 209          //              
 210          //      }else{
 211          //      
 212          //              return 0;
 213          //      }
 214          //}
 215          
 216          ///*³¡¾°¶ÔÓ¦ÏìÓ¦¶¯×÷²éÑ¯*/
 217          //u8 swScenario_oprateCheck(u8 scenarioNum){
 218          
 219          //      u8 datsTemp = 0;
 220          //      u8 insert = 0;
 221          //      
 222          //      insert = swScenarioNum_findFromEEPROM(0, scenarioNum); //²é³¡¾°±àºÅ
 223          //      
 224          //      if(SW_SCENCRAIO_INSERTINVALID != insert){ //³¡¾°±àºÅ¿É²éµ½ÔòÖ´ÐÐÉ¾³ý
 225          //              
 226          //              EEPROM_read_n(EEPROM_ADDR_swScenarioAct, &datsTemp, 1); //¶ÁÈ¡³¡¾°¶ÔÓ¦¶¯×÷²¢·µ»Ø
 227          //              return datsTemp;
 228          //              
 229          //      }else{
 230          //      
 231          //              return SW_SCENCRAIO_ACTINVALID; //³¡¾°ºÅÎÞÐ§²»¿É²é ·µ»ØÎÞÐ§ÏìÓ¦¶¯×÷Öµ
 232          //      }
 233          //}
 234          
 235          void Factory_recover(void){
 236   1              
 237   1              u8 xdata datsTemp[EEPROM_USE_OF_NUMBER] = {0};
 238   1              
 239   1              coverEEPROM_write_n(EEPROM_ADDR_START_USRDATA, datsTemp, EEPROM_USE_OF_NUMBER); //Ê×´ÎÆô¶¯EEPROM²Á³ý
C51 COMPILER V9.54   DATAMANAGE                                                            01/11/2019 12:04:13 PAGE 5   

 240   1              datsTemp[0] = BIRTHDAY_FLAG;
 241   1              coverEEPROM_write_n(EEPROM_ADDR_BirthdayMark, &datsTemp[0], 1); //´ò³öÉú±ê¼Ç
 242   1              
 243   1              memset(datsTemp, 0xff, sizeof(bkLightColorInsert_paramAttr)); //±³¹âµÆ²ÎÊý³ö³§»¯ --³ö³§»¯0xffÌîÂú£¬´ÙÊ¹±³
             -¹âµÆ³õÊ¼»¯Ê±²ÎÊý»Ö¸´ÖÁÄ¬ÈÏÖµ
 244   1              coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround, datsTemp, sizeof(bkLightColorInsert_paramAttr));
 245   1              
 246   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
              #else
 253   1              datsTemp[0] = CURTAIN_ORBITAL_PERIOD_INITTIME; //´°Á±¹ìµÀÊ±¼ä ¸³³õÊ¼Öµ
 254   1              coverEEPROM_write_n(EEPROM_ADDR_curtainOrbitalPeriod, &datsTemp[0], 1);
 255   1              
 256   1      #endif  
 257   1      
 258   1              datsTemp[0] = 0;
 259   1              coverEEPROM_write_n(EEPROM_ADDR_portCtrlEachOther, &datsTemp[0], clusterNum_usr);
 260   1              
 261   1              memset(CTRLEATHER_PORT, 0, clusterNum_usr); //ÔËÐÐ»º´æÇå¿Õ
 262   1              
 263   1              delayMs(10);
 264   1              
 265   1              ((void(code *)(void))0x0000)(); //ÖØÆô
 266   1      }
 267          
 268          void birthDay_Judge(void){
 269   1      
 270   1              u8 xdata datsTemp = 0;
 271   1              
 272   1              EEPROM_read_n(EEPROM_ADDR_BirthdayMark, &datsTemp, 1);
 273   1              if(datsTemp != BIRTHDAY_FLAG){
 274   2              
 275   2                      Factory_recover(); //Ê×´ÎÆô¶¯EEPROM²Á³ý
 276   2              }
 277   1      }
 278          
 279          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED) //ºìÍâÊý¾Ý´æ´¢£¬Ò»¸öÉÈÇøÒ»ÌõÊý¾Ý
              void infrared_eeprom_dataSave(u8 insertNum, u8 dats[], u8 datsLen){
                      
                      //Ò»¸öÉÈÇøÎª512 Bytes£¬Ò»¸öºìÍâÖ¸ÁîÎª232 Bytes£¬¹ÊÒ»¸öÉÈÇø¿ÉÒÔ´æÁ½¸öºìÍâÖ¸Áî
              
                      u16 code EEPROM_SECTOR_HALFSIZE = EEPROM_SECTOR_SIZE / 2;
                      
                      u8      xdata dataSaveTemp[EEPROM_SECTOR_SIZE] = {0}; //Êý¾Ý´æ´¢»º´æ
                      u16 xdata EEadress_Insert = EEPROM_ADDR_START_IRDATA + ((u16)(insertNum / 2) * EEPROM_SECTOR_SIZE); //´æ´
             -¢µØÖ·Ë÷Òý»º´æ
                      
                      EEPROM_read_n(EEadress_Insert, dataSaveTemp, EEPROM_SECTOR_SIZE); //Õû¸öÉÈÇøÊý¾Ý¶Áµ½»º´æ
                      EEPROM_SectorErase(EEadress_Insert); //»º´æ»ñÈ¡ºó²Á³ýÕû¸öÉÈÇø
                      
                      if(insertNum % 2){ //ÆæÊý£¬¶ÔÓ¦ÉÈÇøºó°ë
                      
                              memset(&dataSaveTemp[EEPROM_SECTOR_HALFSIZE], 0, EEPROM_SECTOR_HALFSIZE); //Êý¾Ý´æ´¢ÖÁÉÈÇøºó°ë
                              memcpy(&dataSaveTemp[EEPROM_SECTOR_HALFSIZE], dats, datsLen);
                              
                      }else{ //Å¼Êý£¬¶ÔÓ¦ÉÈÇøÇ°°ë
                      
                              memset(&dataSaveTemp[0], 0, EEPROM_SECTOR_HALFSIZE); //Êý¾Ý´æ´¢ÖÁÉÈÇøÇ°°ë
C51 COMPILER V9.54   DATAMANAGE                                                            01/11/2019 12:04:13 PAGE 6   

                              memcpy(&dataSaveTemp[0], dats, datsLen);
                      }
                      
                      EEPROM_write_n(EEadress_Insert, dataSaveTemp, EEPROM_SECTOR_SIZE);
              }
              
              void infrared_eeprom_dataRead(u8 insertNum, u8 dats[], u8 datsLen){
                      
                      //Ò»¸öÉÈÇøÎª512 Bytes£¬Ò»¸öºìÍâÖ¸ÁîÎª232 Bytes£¬¹ÊÒ»¸öÉÈÇø¿ÉÒÔ´æÁ½¸öºìÍâÖ¸Áî
                      
                      u16 code EEPROM_SECTOR_HALFSIZE = EEPROM_SECTOR_SIZE / 2;
              
                      u16 xdata EEadress_Insert = EEPROM_ADDR_START_IRDATA + ((u16)(insertNum / 2) * EEPROM_SECTOR_SIZE); //´æ´
             -¢µØÖ·Ë÷Òý»º´æ
                      
                      if(insertNum % 2){ //ÆæÊý£¬¶ÔÓ¦ÉÈÇøºó°ë
                      
                              EEadress_Insert += EEPROM_SECTOR_HALFSIZE; //´æ´¢Ë÷Òý¸üÐÂÖÁÉÈÇøºó°ë
                              
                      }else{ //Å¼Êý£¬¶ÔÓ¦ÉÈÇøÇ°°ë
                      
                              EEadress_Insert = EEadress_Insert; //´æ´¢Ë÷Òý¸üÐÂÖÁÉÈÇøÇ°°ë
                      }
                      
                      EEPROM_read_n(EEadress_Insert, dats, datsLen);
              }
              #else
 326           #if(DATASAVE_INTLESS_ENABLEIF) //¼ÌµçÆ÷×´Ì¬EEPROM¶ÀÁ¢´æ´¢Ïà¹Øº¯Êý¶¨Òå
 327          void devParamDtaaSave_relayStatusRealTime(u8 currentRelayStatus){
 328   1              
 329   1              u8 xdata dataRead_temp[RECORDPERIOD_OPREATION_LOOP] = {0};
 330   1              
 331   1              if(loopInsert_relayStatusRealTime_record >= RECORDPERIOD_OPREATION_LOOP){
 332   2              
 333   2                      loopInsert_relayStatusRealTime_record = 0;
 334   2                      EEPROM_SectorErase(EEPROM_ADDR_START_STATUSRELAY); //²ÁÉÈÇø
 335   2              }
 336   1              
 337   1              dataRead_temp[loopInsert_relayStatusRealTime_record ++] = currentRelayStatus;
 338   1              
 339   1              EEPROM_write_n(EEPROM_ADDR_START_STATUSRELAY, dataRead_temp, loopInsert_relayStatusRealTime_record);
 340   1      }
 341          
 342          u8 devDataRecovery_relayStatus(void){
 343   1      
 344   1              u8 xdata dataRead_temp[RECORDPERIOD_OPREATION_LOOP] = {0};
 345   1              u8 xdata loop = 0;
 346   1              u8 xdata res = 0;
 347   1              
 348   1              EEPROM_read_n(EEPROM_ADDR_START_STATUSRELAY, dataRead_temp, RECORDPERIOD_OPREATION_LOOP);
 349   1              
 350   1              for(loop = 0; loop < RECORDPERIOD_OPREATION_LOOP; loop ++){
 351   2              
 352   2                      if(dataRead_temp[loop] == 0xff){
 353   3                      
 354   3                              (!loop)?(res = 0):(res = dataRead_temp[loop - 1]);
 355   3        #if(DEBUG_LOGOUT_EN == 1)     
 356   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 357   4      
 358   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 359   4                                      
 360   4                                      sprintf(log_buf, "insert catch: %d, val:%02X.\n", (int)loop, (int)res);
C51 COMPILER V9.54   DATAMANAGE                                                            01/11/2019 12:04:13 PAGE 7   

 361   4                                      PrintString1_logOut(log_buf);
 362   4                              }
 363   3        #endif
 364   3                              break;
 365   3                      }
 366   2              }
 367   1              
 368   1              EEPROM_SectorErase(EEPROM_ADDR_START_STATUSRELAY); //²ÁÉÈÇø
 369   1              
 370   1              return res;
 371   1      }
 372           #endif
 373          
 374          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    637    ----
   CONSTANT SIZE    =    401    ----
   XDATA SIZE       =     13     332
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7       2
   IDATA SIZE       =     64    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
