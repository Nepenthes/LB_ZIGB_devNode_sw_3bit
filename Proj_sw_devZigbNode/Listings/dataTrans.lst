C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DATATRANS
OBJECT MODULE PLACED IN .\Output\dataTrans.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE dataTrans\dataTrans.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr;.\Usr_l
                    -ib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\dataTrans.lst) OBJECT(.\Output\dataTrans
                    -.obj)

line level    source

   1          #include "dataTrans.h"
   2          
   3          #include "string.h"
   4          #include "stdio.h"
   5          
   6          #include "eeprom.h"
   7          #include "USART.h"
   8          #include "delay.h"
   9          #include "Relay.h"
  10          
  11          #include "timerAct.h"
  12          #include "pars_Method.h"
  13          #include "dataManage.h"
  14          #include "Tips.h"
  15          
  16          /**********************±¾µØÎÄ¼þ±äÁ¿¶¨ÒåÇø************************/
  17          datsAttr_datsTrans xdata datsSend_request = {0}; //Ô¶¶ËÊý¾Ý´«ÊäÇëÇó»º´æ
  18          datsAttr_datsTrans xdata datsRcv_respond = {0}; //Ô¶¶ËÊý¾Ý´«ÊäÇëÇóµÈ´ýÏìÓ¦»º´æ»º´æ
  19          remoteDataReq_method xdata devRemoteDataReqMethod = {0}; //Ô¶¶ËÊý¾ÝÇëÇó·½Ê½
  20          
  21          stt_devOpreatDataPonit xdata dev_currentDataPoint = {0}; //ÖÜÆÚÑ¯·ÃÊý¾Ýµã
  22          stt_agingDataSet_bitHold xdata  dev_agingCmd_rcvPassive = {0}; //ÖÜÆÚÑ¯·ÃÊ±Ð§Õ¼Î»Ö¸Áî»º´æ --±»¶¯½ÓÊÕ
  23          stt_agingDataSet_bitHold xdata  dev_agingCmd_sndInitative = {0}; //ÖÜÆÚÑ¯·ÃÊ±Ð§Õ¼Î»Ö¸Áî»º´æ --Ö÷¶¯ÉÏ´«
  24          u8 dtModeKeepAcess_currentCmd = DTMODEKEEPACESS_FRAMECMD_ASR; //Êý¾Ý´«ÊäÎª¶¨Ê±Ñ¯·ÃÄ£Ê½Ê±£¬Ð¯´øÑ¯·ÃÖ¸ÁîÖµ£¬
             -ÐèÒªÖ÷¶¯ÉÏ´«Ê±Ôò¸ü¸Ä´ËÖµ
  25          
  26          //zigbeeÔËÐÐ×´Ì¬ÇÐ»»±êÖ¾
  27          stt_statusChange xdata devStatus_switch = {0, status_NULL};
  28          //Êý¾ÝÇëÇóÍê³ÉºóÊÇ·ñÐèÒªÖØÆôÍøÂç
  29          bit reConnectAfterDatsReq_IF = 0; //ÓÃÓÚ»¥¿ØÍ¨Ñ¶´Ø¼´¿Ì×¢²áÌØÊâÇé¿öÏÂÊ¹ÓÃ
  30          
  31          bit coordinatorOnline_IF = 0; //Ð­µ÷Æ÷ÔÚÏß±êÖ¾
  32          
  33          //zigbÍøÂç¶¯×÷×¨ÓÃÊ±¼ä¼ÆÊý
  34          u16 xdata zigbNwkAction_counter = 0;
  35          
  36          //zigbÉè±¸ÍøÂç¹ÒÆðÊôÐÔ²ÎÊý
  37          attr_devNwkHold xdata devNwkHoldTime_Param = {0};
  38          
  39          //ÐÄÌø
  40          bit heartBeatCycle_FLG                  = 0; //ÐÄÌøÖÜÆÚ´¥·¢
  41          u8      xdata heartBeatCount            = 0; //ÐÄÌøÖÜÆÚ¼ÆÊý
  42          u8      xdata heartBeatPeriod           = PERIOD_HEARTBEAT_ASR; //ÐÄÌø¼ÆÊýÖÜÆÚ
  43          u8      xdata heartBeatHang_timeCnt = 0; //ÐÄÌø¹ÒÆð¼ÆÊ±(´ËÊý¾ÝÎª0Ê±²Å¿ÉÒÔ·¢ËÍÐÄÌø£¬·ñÔòÐÄÌø¹ÒÆð£¬ÓÃÓÚÍ¨ÐÅ±ÜÈÃ)
  44          
  45          //¼¯ÈºÊÜ¿ØÖÜÆÚÂÖÑ¯-<°üÀ¨ÓÐ»¥¿ØºÍ³¡¾°>
  46          u8      xdata colonyCtrlGet_queryCounter = COLONYCTRLGET_QUERYPERIOD; //¼¯ÈºÊÜ¿Ø×´Ì¬ÖÜÆÚÐÔÑ¯²é¼ÆÊ±¼ÆÊýÖµ 
  47          u8      xdata colonyCtrlGet_statusLocalEaCtrl[clusterNum_usr] = {0}; //¼¯Èº¿ØÖÆ-±¾µØ»¥¿Ø×´Ì¬Î»¼ÇÂ¼
  48          u8      xdata colonyCtrlGet_statusLocalScene = 0; //¼¯Èº¿ØÖÆ-±¾µØ³¡¾°×´Ì¬Î»¼ÇÂ¼
  49          u8      xdata colonyCtrlGetHang_timeCnt = 0; //¼¯ÈºÊÜ¿Ø×´Ì¬ÖÜÆÚÐÔÂÖÑ¯¹ÒÆð¼ÆÊ±(´ËÊý¾ÝÎª0Ê±²Å¿ÉÒÔ½øÐÐÖÜÆÚÑ¯²é£¬·ñ
             -ÔòÑ¯²é¹ÒÆð£¬ÓÃÓÚÍ¨ÐÅ±ÜÈÃ)
  50          
  51          //´®¿Ú½ÓÊÕ³¬Ê±±êÖ¾
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 2   

  52          bit uartRX_toutFLG      = 0;
  53          //´®¿Ú½ÓÊÕ³¬Ê±¼ÆÊý
  54          bit rxTout_count_EN = 0;
  55          u8  rxTout_count        = 0;
  56          //´®¿ÚÊý¾Ý»º´æ
  57          u8      datsRcv_length  = 0;
  58          uartTout_datsRcv xdata datsRcv_ZIGB = {{0}, 0};
  59          
  60          //zigbeeÍ¨ÐÅÏß³Ìµ±Ç°ÔËÐÐ×´Ì¬±êÖ¾
  61          threadRunning_Status devRunning_Status = status_NULL;
  62          
  63          void zigbUart_pinInit(void){
  64   1      
  65   1              //TXÍÆÍìÊä³ö
  66   1              P3M1 &= 0xFD;   
  67   1              P3M0 |= 0x02;   
  68   1              
  69   1              //RX¸ß×èÊäÈë
  70   1              P3M1 |= 0x01;
  71   1              P3M0 &= 0xFE;
  72   1              
  73   1              //TXÍÆÍìÊä³ö
  74   1              P2M1 &= ~0x08;
  75   1              P2M0 |= 0x08;
  76   1      }
  77                  
  78          /*--------------------------------------------------------------*/
  79          void uartObjZigb_Init(void){
  80   1      
  81   1              EA = 0;
  82   1      
  83   1              PS = 1;
  84   1              SCON = (SCON & 0x3f) | UART_8bit_BRTx;
  85   1      
  86   1      {
  87   2              u32 j = (MAIN_Fosc / 4) / ZIGB_BAUND;   //°´1T¼ÆËã
  88   2                      j = 65536UL - j;
  89   2              
  90   2              TH2 = (u8)(j>>8);
  91   2              TL2 = (u8)j;
  92   2      }
  93   1              AUXR &= ~(1<<4);        //Timer stop
  94   1              AUXR |= 0x01;           //S1 BRT Use Timer2;
  95   1              AUXR &= ~(1<<3);        //Timer2 set As Timer
  96   1              AUXR |=  (1<<2);        //Timer2 set as 1T mode
  97   1      
  98   1              IE2  &= ~(1<<2);        //½ûÖ¹ÖÐ¶Ï
  99   1              AUXR &= ~(1<<3);        //¶¨Ê±
 100   1              AUXR |=  (1<<4);        //Timer run enable
 101   1      
 102   1              ES        = 1;
 103   1              REN   = 1;
 104   1              P_SW1 = (P_SW1 & 0x3f) | (UART1_SW_P30_P31 & 0xc0);
 105   1              
 106   1              memset(TX1_Buffer, 0, sizeof(char) * COM_TX1_Lenth);
 107   1      
 108   1              EA = 1;
 109   1      
 110   1              PrintString1("i'm UART1 for wifi data translate !!!\n");
 111   1              PrintString1_logOut("i'm UART1 for datsLog !!!\n");
 112   1      }
 113          
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 3   

 114          ///*----------------------------
 115          //·¢ËÍ´®¿ÚÊý¾Ý
 116          //----------------------------*/
 117          //void uartObjWIFI_Send_Byte(u8 dat)    //´®¿Ú1
 118          //{
 119          //      TX1_write2buff(dat);
 120          //}
 121          
 122          //void uartObjWIFI_Send_String(char *s,unsigned char ucLength){  //´®¿Ú1
 123          //      
 124          //      uart1_datsSend(s, ucLength);
 125          //}
 126          
 127          //void rxBuff_WIFI_Clr(void){
 128          
 129          //      memset(rxBuff_WIFI, 0xff, sizeof(char) * COM_RX1_Lenth);
 130          //      COM1.RX_Cnt = 0;
 131          //}
 132          
 133          /********************* UART1(WIIF)ÖÐ¶Ïº¯Êý_×Ô¶¨ÒåÖØ¹¹************************/
 134          void UART1_Rountine (void) interrupt UART1_VECTOR
 135          {
 136   1              
 137   1              if(RI)
 138   1              {
 139   2                      RI = 0;
 140   2                      if(COM1.B_RX_OK == 0)
 141   2                      {
 142   3                              
 143   3      //                      if(COM1.RX_Cnt >= COM_RX1_Lenth)        COM1.RX_Cnt = 0;
 144   3      //                      RX1_Buffer[COM1.RX_Cnt++] = SBUF;
 145   3      //                      COM1.RX_TimeOut = TimeOutSet1;
 146   3                              
 147   3                              if(!rxTout_count_EN){
 148   4                              
 149   4                                      rxTout_count_EN = 1;
 150   4                                      rxTout_count    = 0;
 151   4                                      datsRcv_length  = 0;
 152   4                                      
 153   4                                      memset(RX1_Buffer, 0xff, sizeof(char) * COM_RX1_Lenth);
 154   4                              }
 155   3                              
 156   3                              
 157   3                              RX1_Buffer[datsRcv_length ++]   = SBUF;
 158   3                              rxTout_count = 0;
 159   3                      }
 160   2              }
 161   1      
 162   1              if(TI)
 163   1              {
 164   2                      TI = 0;
 165   2                      if(COM1.TX_read != COM1.TX_write)
 166   2                      {
 167   3                              SBUF = TX1_Buffer[COM1.TX_read];
 168   3                              if(++COM1.TX_read >= COM_TX1_Lenth)             COM1.TX_read = 0;
 169   3                      }
 170   2                      else    COM1.B_TX_busy = 0;
 171   2              }
 172   1      }
 173          
 174          /* ×Ô¶¨ÒåÐ£Ñé*///×Ô¼Ò²úÆ·Ð­Òé²ã
 175          static 
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 4   

 176          unsigned char frame_Check(unsigned char frame_temp[], u8 check_num){
 177   1        
 178   1              unsigned char loop              = 0;
 179   1              unsigned char val_Check = 0;
 180   1              
 181   1              for(loop = 0; loop < check_num; loop ++){
 182   2              
 183   2                      val_Check += frame_temp[loop];
 184   2              }
 185   1              
 186   1              val_Check  = ~val_Check;
 187   1              val_Check ^= 0xa7;
 188   1              
 189   1              return val_Check;
 190   1      }
 191          
 192          /*´ËÊý¾Ý·â×°±ØÐëÔÚÊý¾Ý°ü·¢ËÍÇ°×îºóµ÷ÓÃ£¬×Ô¶¨Òå¶ÔÏó½øÐÐÊý¾Ý·â×°*///±ÜÃâÐ£Ñé±»ÌáÇ°¶ø³ö´í
 193          static 
 194          u8 dtasTX_loadBasic_CUST(bit ifRemoteDats,
 195                                                       u8 dats_Tx[],
 196                                                       u8 datsLen_TX,
 197                                                       u8 frame_Type,
 198                                                       u8 frame_CMD,
 199                                                       bit ifSpecial_CMD){
 200   1                                                         
 201   1              dats_Tx[2]      = frame_Type;
 202   1              dats_Tx[3]      = frame_CMD;
 203   1              
 204   1              if(!ifSpecial_CMD)dats_Tx[10] = SWITCH_TYPE;    //¿ª¹ØÀàÐÍÌî³ä
 205   1              
 206   1              memcpy(&dats_Tx[5], &MAC_ID[1], 5);     //MACÌî³ä
 207   1                                                        
 208   1              dats_Tx[4]      = frame_Check(&dats_Tx[5], 28);
 209   1                                                                 
 210   1              if(ifRemoteDats){
 211   2                      
 212   2                      u8 xdata dats_Temp[64] = {0};
 213   2              
 214   2                      dats_Tx[0] = ZIGB_FRAMEHEAD_CTRLREMOTE;
 215   2                      dats_Tx[1]      = datsLen_TX + 12;
 216   2                      
 217   2                      memcpy(dats_Temp, &dats_Tx[1], datsLen_TX - 13);
 218   2                      memset(&dats_Tx[1], 0, datsLen_TX - 1);
 219   2                      memcpy(&dats_Tx[13], dats_Temp, datsLen_TX - 13);
 220   2                      memcpy(&dats_Tx[1], MAC_ID_DST, 6);
 221   2                      memcpy(&dats_Tx[8], &MAC_ID[1], 5);
 222   2                      
 223   2                      return 45;
 224   2                      
 225   2              }else{
 226   2              
 227   2                      dats_Tx[0]      = ZIGB_FRAMEHEAD_CTRLLOCAL;
 228   2                      dats_Tx[1]      = datsLen_TX;
 229   2                      
 230   2                      return 33;
 231   2              }
 232   1      }
 233          
 234          /*Êý¾ÝÒì»òÐ£Ñé*///ZNPÐ­Òé²ã
 235          static 
 236          u8 XORNUM_CHECK(u8 buf[], u8 length){
 237   1      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 5   

 238   1              u8 loop = 0;
 239   1              u8 valXOR = buf[0];
 240   1              
 241   1              for(loop = 1;loop < length;loop ++)valXOR ^= buf[loop];
 242   1              
 243   1              return valXOR;
 244   1      }
 245          
 246          /*zigbeeÊý¾ÝÖ¡¼ÓÔØ*/
 247          static 
 248          u8 ZigB_TXFrameLoad(u8 frame[],u8 cmd[],u8 cmdLen,u8 dats[],u8 datsLen){                
 249   1      
 250   1              const u8 frameHead = ZIGB_FRAME_HEAD;   //ZNP,SOFÖ¡Í·
 251   1              u8 xor_check = datsLen;                                 //Òì»òÐ£Ñé£¬Ö¡Î²
 252   1              u8 loop = 0;
 253   1              u8 ptr = 0;
 254   1              
 255   1              frame[ptr ++] = frameHead;
 256   1              frame[ptr ++] = datsLen;
 257   1              
 258   1              memcpy(&frame[ptr],cmd,cmdLen);
 259   1              ptr += cmdLen;
 260   1              for(loop = 0;loop < cmdLen;loop ++)xor_check ^= cmd[loop];
 261   1      
 262   1              memcpy(&frame[ptr],dats,datsLen);
 263   1              ptr += datsLen;
 264   1              for(loop = 0;loop < datsLen;loop ++)xor_check ^= dats[loop];    
 265   1              
 266   1              frame[ptr ++] = xor_check;
 267   1              
 268   1              return ptr;
 269   1      }
 270          
 271          /*ÖÜÆÚÐÔÖ÷¶¯·¢ÂëÍ¨ÐÅ¹ÒÆð£¬Í¨ÐÅÇåÕÏ*/
 272          void periodDataTrans_momentHang(u8 hangTime){ //¹ÒÆðÊ±¼ä µ¥Î»£ºs
 273   1      
 274   1              heartBeatCount = 0;
 275   1              colonyCtrlGet_queryCounter = COLONYCTRLGET_QUERYPERIOD;
 276   1              
 277   1              heartBeatHang_timeCnt = colonyCtrlGetHang_timeCnt = hangTime;
 278   1      }
 279          
 280          /*zigbeeµ¥Ö¸ÁîÊý¾ÝÇëÇó£¬·µ»ØÓ¦´ðÊý¾Ý³¤¶È*/
 281          static 
 282          u8 zigb_datsRequest( u8 frameREQ[],             //ÇëÇóÖ¡
 283                                                   u8 frameREQ_Len,       //ÇëÇóÖ¡³¤
 284                                                   u8 resp_cmd[2],        //ËùÐèÓ¦´ðÖ¸Áî
 285                                                   u8 resp_dats[],        //Ó¦´ðÊý¾Ý»º´æ
 286                                                   u8 loopReapt,u16 timeWait){    //Ñ­»·´ÎÊý£¬µ¥´ÎµÈ´ýÊ±¼ä
 287   1                                                
 288   1              u16 Local_Delay = timeWait;             
 289   1              u8      loop = 0;
 290   1                                                       
 291   1              for(loop = 0;loop < loopReapt;loop ++){
 292   2              
 293   2                      uartRX_toutFLG = 0;
 294   2                      zigbNwkAction_counter = timeWait;       
 295   2                  uartZigB_datsSend(frameREQ, frameREQ_Len);
 296   2                      
 297   2                      while(zigbNwkAction_counter){ //¶¨Ê±Æ÷ÖÐ¶ÏÄÚ½øÐÐµ¹¼ÆÊ±
 298   3      
 299   3                              if(uartRX_toutFLG){
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 6   

 300   4                              
 301   4                                      uartRX_toutFLG = 0;
 302   4                                      
 303   4                                      if(!memcmp(&(datsRcv_ZIGB.rcvDats[2]), resp_cmd, 2)){
 304   5                                      
 305   5                                              memcpy(resp_dats, datsRcv_ZIGB.rcvDats, datsRcv_ZIGB.rcvDatsLen);
 306   5                                              return datsRcv_ZIGB.rcvDatsLen;
 307   5                                              
 308   5                                      }
 309   4                              }
 310   3                      }
 311   2              }       
 312   1      
 313   1              return 0;
 314   1      }
 315          
 316          /*zigbeeµ¥Ö¸ÁîÏÂ·¢¼°ÏìÓ¦ÑéÖ¤*///×èÈû
 317          bit zigb_VALIDA_INPUT(u8 REQ_CMD[2],            //Ö¸Áî
 318                                                    u8 REQ_DATS[],                //Êý¾Ý
 319                                                    u8 REQdatsLen,                //Êý¾Ý³¤¶È
 320                                                    u8 ANSR_frame[],              //ÏìÓ¦Ö¡
 321                                                    u8 ANSRdatsLen,               //ÏìÓ¦Ö¡³¤¶È
 322                                                    u8 times,u16 timeDelay){      //Ñ­»·´ÎÊý£¬µ¥´ÎµÈ´ýÊ±¼ä
 323   1                                                 
 324   1      #define dataLen_validaInput     96
 325   1              u8 xdata dataTXBUF[dataLen_validaInput] = {0};
 326   1              u8      loop = 0;
 327   1              u8      datsTX_Len;
 328   1      
 329   1              datsTX_Len = ZigB_TXFrameLoad(dataTXBUF,REQ_CMD, 2, REQ_DATS, REQdatsLen);
 330   1      
 331   1              for(loop = 0;loop < times;loop ++){
 332   2              
 333   2                      uartRX_toutFLG = 0;
 334   2                      zigbNwkAction_counter = timeDelay;
 335   2                      uartZigB_datsSend(dataTXBUF, datsTX_Len);
 336   2                      
 337   2                      while(zigbNwkAction_counter){ //¶¨Ê±Æ÷ÖÐ¶ÏÄÚ½øÐÐµ¹¼ÆÊ±
 338   3                              
 339   3                              if(uartRX_toutFLG){
 340   4                              
 341   4                                      uartRX_toutFLG = 0;
 342   4                                      
 343   4                                      if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ANSR_frame, ANSRdatsLen)){
 344   5                                      
 345   5                                              delayMs(2);
 346   5                                              return 1;
 347   5                                      }
 348   4                              }
 349   3                      }
 350   2              }
 351   1              
 352   1              return 0;
 353   1      }
 354          
 355          ///*zigbeeÍ¨ÐÅ´ØÉèÖÃ*///×èÈû
 356          //bit zigb_clusterSet(u16 deviveID, u8 endPoint){
 357          
 358          //      datsAttr_ZigbInit code default_param = {{0x24,0x00},{0x0E,0x0D,0x00,0x0D,0x00,0x0D,0x00,0x01,0x00,0x00,
             -0x01,0x00,0x00},0x0D,{0xFE,0x01,0x64,0x00,0x00,0x65},0x06,300};       //Êý¾Ý´Ø×¢²á,Ä¬ÈÏ²ÎÊý
 359          //      u8 code frameResponse_Subs[6] = {0xFE,0x01,0x64,0x00,0xB8,0xDD}; //ÏìÓ¦Ö¡Ìæ²¹£¬ÈôÊý¾Ý´ØÒÑ¾­×¢²á
 360          //              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 7   

 361          //#define       dataLen_zigbClusterSet  64
 362          //      u8 xdata paramTX_temp[dataLen_zigbClusterSet] = {0};
 363          //      
 364          //      bit setResult = 0;
 365          //      
 366          //      memcpy(paramTX_temp, default_param.zigbInit_reqDAT, default_param.reqDAT_num);
 367          //      paramTX_temp[0] = endPoint;
 368          //      paramTX_temp[3] = (u8)((deviveID & 0x00ff) >> 0);
 369          //      paramTX_temp[4] = (u8)((deviveID & 0xff00) >> 8);
 370          //      
 371          //      setResult =  zigb_VALIDA_INPUT( (u8 *)default_param.zigbInit_reqCMD,
 372          //                                                                      (u8 *)paramTX_temp,
 373          //                                                                      default_param.reqDAT_num,
 374          //                                                                      (u8 *)default_param.zigbInit_REPLY,
 375          //                                                                      default_param.REPLY_num,
 376          //                                                                      2,              //2´ÎÒÔÄÚÃ»ÓÐÕýÈ·ÏìÓ¦¾ÍÊ§°Ü
 377          //                                                                      default_param.timeTab_waitAnsr);
 378          //      
 379          //      if(setResult)return setResult;
 380          //      else{
 381          //      
 382          //              return zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 383          //                                                               (u8 *)paramTX_temp,
 384          //                                                               default_param.reqDAT_num,
 385          //                                                               (u8 *)frameResponse_Subs,
 386          //                                                               6,
 387          //                                                               2,             //2´ÎÒÔÄÚÃ»ÓÐÕýÈ·ÏìÓ¦¾ÍÊ§°Ü
 388          //                                                               default_param.timeTab_waitAnsr);
 389          //      }
 390          //}
 391          
 392          ///*zigbeeÖØÐÂÈëÍø*///×èÈûº¯Êý£¬½ö¹©²âÊÔÊ¹ÓÃ
 393          //bit ZigB_NwkJoin(u16 PANID, u8 CHANNELS){
 394          
 395          //#define       cmdNum_zigbNwkJoin      8       
 396          //      
 397          //#define        loop_PANID             5
 398          //#define        loop_CHANNELS  6
 399          
 400          //      datsAttr_ZigbInit code ZigbInit_dats[cmdNum_zigbNwkJoin] = {
 401          //              
 402          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¸´Î»
 403          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¸´Î»
 404          //              {       {0x26,0x05},    {0x03,0x01,0x03},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //¼Ä´æÆ÷³
             -õÊ¼»¯£¬È«²¿Çå¿Õ
 405          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¶þ´Î¸´Î»
 406          //              
 407          ////            {       {0x26,0x05},    {0x87,0x01,0x00},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«É
             -èÖÃ£¨Ð­µ÷Æ÷£©
 408          //              {       {0x26,0x05},    {0x87,0x01,0x01},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨Â·ÓÉÆ÷£©
 409          ////            {       {0x26,0x05},    {0x87,0x01,0x02},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«É
             -èÖÃ£¨ÖÕ¶Ë£©
 410          //              
 411          //              {       {0x27,0x02},    {0x34,0x12},                    0x02,   {0xFE,0x01,0x67,0x02,0x00,0x64},                                                        0x06,   500             },      //PAN_ID¼Ä´æÆ
             -÷ÉèÖÃ
 412          //              {       {0x27,0x03},    {0x00,0x80,0x00,0x00},  0x04,   {0xFE,0x01,0x67,0x03,0x00,0x65},                                                        0x06,   500             },      //ÐÅµ
             -À¼Ä´æÆ÷ÅäÖÃ
 413          ////            {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x09,0x8D},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 8   

             -¶¨½ÇÉ«Ð­µ÷Æ÷£¨Ð­µ÷Æ÷ÏìÓ¦£©
 414          //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x07,0x83},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨Â·ÓÉÆ÷ÏìÓ¦£©
 415          ////            {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x06,0x82},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È
             -¶¨½ÇÉ«Ð­µ÷Æ÷£¨ÖÕ¶ËÏìÓ¦£©
 416          //      };
 417          //      
 418          //#define       dataLen_zigbNwkJoin 64
 419          //      u8 xdata paramTX_temp[dataLen_zigbNwkJoin] = {0};
 420          //      
 421          //      u8  loop;
 422          //      u32 chnl_temp = 0x00000800UL << CHANNELS;
 423          //      
 424          //      for(loop = 1; loop < cmdNum_zigbNwkJoin; loop ++){
 425          //              
 426          //              memset(paramTX_temp, 0, dataLen_zigbNwkJoin * sizeof(u8));
 427          //              
 428          //              switch(loop){   //×ÔÑ¡²ÎÊý&Ä¬ÈÏ²ÎÊý
 429          //              
 430          //                      case loop_PANID:{
 431          //                      
 432          //                              paramTX_temp[0] = (u8)((PANID & 0x00ff) >> 0);
 433          //                              paramTX_temp[1] = (u8)((PANID & 0xff00) >> 8);
 434          //                              
 435          //                      }break;
 436          //                      
 437          //                      case loop_CHANNELS:{
 438          //                      
 439          //                              paramTX_temp[0] = (u8)((chnl_temp & 0x000000ff) >>  0);
 440          //                              paramTX_temp[1] = (u8)((chnl_temp & 0x0000ff00) >>  8);
 441          //                              paramTX_temp[2] = (u8)((chnl_temp & 0x00ff0000) >> 16);
 442          //                              paramTX_temp[3] = (u8)((chnl_temp & 0xff000000) >> 24);
 443          //                              
 444          //                      }break;
 445          //                      
 446          //                      default:{
 447          //                      
 448          //                              memcpy(paramTX_temp,ZigbInit_dats[loop].zigbInit_reqDAT,ZigbInit_dats[loop].reqDAT_num);
 449          //                              
 450          //                      }break;
 451          //              }
 452          //      
 453          //              delayMs(100);
 454          //              if(0 == zigb_VALIDA_INPUT((u8 *)ZigbInit_dats[loop].zigbInit_reqCMD,
 455          //                                                                (u8 *)paramTX_temp,
 456          //                                                                ZigbInit_dats[loop].reqDAT_num,
 457          //                                                                (u8 *)ZigbInit_dats[loop].zigbInit_REPLY,
 458          //                                                                ZigbInit_dats[loop].REPLY_num,
 459          //                                                                3,
 460          //                                                                ZigbInit_dats[loop].timeTab_waitAnsr)
 461          //                                                               )loop = 0;
 462          //      }
 463          //      
 464          //      return zigb_clusterSet(13, 13); //Éè±¸ID 13£¬ÖÕ¶Ëµã 13£»
 465          //}
 466          
 467          /*zigbee Ö÷¶¯¿ª·ÅÍøÂç*///×èÈû
 468          bit ZigB_nwkOpen(bit openIF, u8 openTime){
 469   1      
 470   1              datsAttr_ZigbInit code default_param = {{0x26,0x08}, {0xFC,0xFF,0x00}, 0x03, {0xFE,0x01,0x66,0x08,0x00,0x
             -6F}, 0x06, 150}; //zigbeeÖ¸ÁîÏÂ´ïÄ¬ÈÏ²ÎÊý
 471   1              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 9   

 472   1              bit resultSet = 0;
 473   1              
 474   1              u8 openTime_temp = 0;
 475   1              
 476   1      #define paramLen_zigbNwkOpen 3
 477   1              u8 xdata paramTX_temp[paramLen_zigbNwkOpen] = {0xFC,0xFF,0x00};
 478   1              
 479   1              (openIF)?(paramTX_temp[2] = openTime):(paramTX_temp[2] = 0);
 480   1              
 481   1              resultSet = zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 482   1                                                                        (u8 *)paramTX_temp,
 483   1                                                                        default_param.reqDAT_num,
 484   1                                                                        (u8 *)default_param.zigbInit_REPLY,
 485   1                                                                        default_param.REPLY_num,
 486   1                                                                        2,    //2´ÎÎÞ»Ø¸´ÎªÊ§°Ü
 487   1                                                                        default_param.timeTab_waitAnsr);
 488   1      
 489   1      #if(DEBUG_LOGOUT_EN == 1)       
 490   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 491   1      //              u8 xdata log_buf[64];
 492   1      //              
 493   1      //              sprintf(log_buf, "nwkOpen result:%d.\n", (int)resultSet);
 494   1      //              PrintString1_logOut(log_buf);
 495   1      //      }
 496   1      #endif
 497   1              
 498   1              return resultSet;
 499   1      }
 500          
 501          /*zigbee PANID»ñÈ¡*///×èÈû
 502          static u16 ZigB_getPanIDCurrent(void){
 503   1      
 504   1              u16 PANID_temp = 0;
 505   1              
 506   1      #define paramLen_zigbPanIDGet 32
 507   1              u8 xdata paramTX_temp[paramLen_zigbPanIDGet] = {0};
 508   1              
 509   1              u8 code frameREQ_zigbPanIDGet[6] = {0xFE, 0x01, 0x26, 0x06, 0x06, 0x27};        //zigb PANID»ñÈ¡Ö¸ÁîÖ¡
 510   1              u8 code cmdResp_zigbPanIDGet[2]  = {0x66, 0x06};        //zigb PANID»ñÈ¡Ô¤ÆÚÏìÓ¦Ö¸Áî
 511   1              u8 datsResp_Len = 0;
 512   1      
 513   1              datsResp_Len = zigb_datsRequest(frameREQ_zigbPanIDGet, 6, cmdResp_zigbPanIDGet, paramTX_temp, 2, 300);
 514   1      
 515   1              if(datsResp_Len){
 516   2      
 517   2                      PANID_temp |= (((u16)(paramTX_temp[5]) << 0) & 0x00FF);
 518   2                      PANID_temp |= (((u16)(paramTX_temp[6]) << 8) & 0xFF00);
 519   2      
 520   2      //              printf_datsHtoA("[Tips_uartZigb]: resultDats:", local_datsParam->frameResp, local_datsParam->frameResp
             -Len);
 521   2              }
 522   1      
 523   1              return PANID_temp;
 524   1      }
 525          
 526          /*zigbeeÏµÍ³Ê±¼ä»ñÈ¡²¢¸üÐÂ*///×èÈû
 527          static bit getSystemTime_reales(void){
 528   1              
 529   1              bit resultOpreat = 0;
 530   1      
 531   1      #define paramLen_zigbSystimeGet 32
 532   1              u8 xdata paramTX_temp[paramLen_zigbSystimeGet] = {0};
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 10  

 533   1              
 534   1              u8 code frameREQ_zigbSystimeGet[5] = {0xFE, 0x00, 0x21, 0x11, 0x30};    //zigb PANID»ñÈ¡Ö¸ÁîÖ¡
 535   1              u8 code cmdResp_zigbSystimeGet[2]  = {0x61, 0x11};      //zigb PANID»ñÈ¡Ô¤ÆÚÏìÓ¦Ö¸Áî
 536   1              u8 datsResp_Len = 0;
 537   1      
 538   1              datsResp_Len = zigb_datsRequest(frameREQ_zigbSystimeGet, 5, cmdResp_zigbSystimeGet, paramTX_temp, 2, 300)
             -;
 539   1              
 540   1              if(!datsResp_Len)resultOpreat = 0;
 541   1              else{
 542   2                      
 543   2                      u16 Y_temp16 = ((u16)paramTX_temp[13] << 0) | ((u16)paramTX_temp[14] << 8);
 544   2                      u8  Y_temp8 = 0;
 545   2                      u8  M_temp8 = 0;
 546   2                      
 547   2                      u8 Y = (u8)(Y_temp16 % 2000);
 548   2                      u8 M = paramTX_temp[11];
 549   2                      u8 D = paramTX_temp[12];
 550   2                      u8 W = 0;
 551   2                      
 552   2                      /*¼ÆËã»º´æ¸³Öµ*/
 553   2                      Y_temp8 = Y;
 554   2                      if(M == 1 || M == 2){ //Ò»ÔÂºÍ¶þÔÂµ±×÷ÉÏÒ»ÄêÊ®ÈýÔÂºÍÊ®ËÄÔÂ
 555   3                      
 556   3                              M_temp8 = M + 12;
 557   3                              Y_temp8 --;
 558   3                      }
 559   2                      else M_temp8 = M;
 560   2                      
 561   2                      /*¿ªÊ¼¼ÆËã*/
 562   2                      W =      Y_temp8 + (Y_temp8 / 4) + 5 - 40 + (26 * (M_temp8 + 1) / 10) + D - 1;  //²ÌÀÕ¹«Ê½
 563   2                      W %= 7; 
 564   2                      
 565   2                      /*¼ÆËã½á¹û¸³Öµ*/
 566   2                      W?(systemTime_current.time_Week = W):(systemTime_current.time_Week = 7);
 567   2                      
 568   2                      systemTime_current.time_Month =         M;
 569   2                      systemTime_current.time_Day =           D;
 570   2                      systemTime_current.time_Year =          Y;
 571   2                      
 572   2                      systemTime_current.time_Hour =          paramTX_temp[8];
 573   2                      systemTime_current.time_Minute =        paramTX_temp[9];
 574   2                      systemTime_current.time_Second =        paramTX_temp[10];
 575   2                      
 576   2                      /*±¾µØÊ±¼äÎ¬³Ö¼ÆÊýÖµÐ£×¼¸üÐÂ*/
 577   2                      sysTimeKeep_counter = systemTime_current.time_Minute * 60 + systemTime_current.time_Second; //ÏµÍ³Ê±¼äÎ¬
             -³Ö¼ÆÊýÖµ¸üÐÂ
 578   2                      
 579   2                      resultOpreat = 1;
 580   2              }
 581   1              
 582   1      #if(DEBUG_LOGOUT_EN == 1)       
 583   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 584   1      //              u8 xdata log_buf[64];
 585   1      //              
 586   1      //              sprintf(log_buf, "sysTime reales result:%d.\n", (int)resultOpreat);
 587   1      //              PrintString1_logOut(log_buf);
 588   1      //      }
 589   1      #endif
 590   1              
 591   1              return resultOpreat;
 592   1      }
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 11  

 593          
 594          /*zigbeeÏµÍ³Ê±¼äÉèÖÃ*///×èÈû
 595          static
 596          bit zigB_sysTimeSet(u32 timeStamp, bit timeZoneAdjust_IF){
 597   1      
 598   1              datsAttr_ZigbInit code default_param = {{0x21,0x10},{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
             -00},0x0B,{0xFE,0x01,0x61,0x10,0x00},0x05,100}; //zigbeeÖ¸ÁîÏÂ´ïÄ¬ÈÏ²ÎÊý
 599   1              u8 xdata timeStampArray[0x0B] = {0};
 600   1              bit resultSet = 0;
 601   1              u32 timeStamp_temp = timeStamp;
 602   1              
 603   1              if(timeZoneAdjust_IF){ //ÊÇ·ñÐèÒªÊ±Çøµ÷Õû
 604   2              
 605   2                      if(sysTimeZone_H <= 12){
 606   3                      
 607   3                              timeStamp_temp += (3600UL * (long)sysTimeZone_H + 60UL * (long)sysTimeZone_M); //Ê±ÇøÕý
 608   3                              
 609   3                      }else
 610   2                      if(sysTimeZone_H > 12 && sysTimeZone_H <= 24){
 611   3                      
 612   3                              timeStamp_temp -= (3600UL * (long)(sysTimeZone_H - 12) + 60UL * (long)sysTimeZone_M); //Ê±Çø¸º
 613   3                              
 614   3                      }else
 615   2                      if(sysTimeZone_H >= 30){
 616   3                      
 617   3                              timeStamp_temp += (3600UL * (long)(sysTimeZone_H - 17) + 60UL * (long)sysTimeZone_M); //Ê±ÇøÌØÊâ
 618   3                      }
 619   2              }
 620   1      
 621   1              timeStampArray[0] = (u8)((timeStamp_temp & 0x000000ff) >> 0);
 622   1              timeStampArray[1] = (u8)((timeStamp_temp & 0x0000ff00) >> 8);
 623   1              timeStampArray[2] = (u8)((timeStamp_temp & 0x00ff0000) >> 16);
 624   1              timeStampArray[3] = (u8)((timeStamp_temp & 0xff000000) >> 24);
 625   1              
 626   1              resultSet = zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 627   1                                                                        (u8 *)timeStampArray,
 628   1                                                                        default_param.reqDAT_num,
 629   1                                                                        (u8 *)default_param.zigbInit_REPLY,
 630   1                                                                        default_param.REPLY_num,
 631   1                                                                        2,    //2´ÎÎÞ»Ø¸´ÎªÊ§°Ü
 632   1                                                                        default_param.timeTab_waitAnsr);
 633   1              
 634   1      #if(DEBUG_LOGOUT_EN == 1)       
 635   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 636   1      //              u8 xdata log_buf[64];
 637   1      //              
 638   1      //              sprintf(log_buf, "sysTime set result:%d.\n", (int)resultSet);
 639   1      //              PrintString1_logOut(log_buf);
 640   1      //      }
 641   1      #endif
 642   1              
 643   1              return resultSet;
 644   1      }
 645          
 646          ///*zigbeeÓ²¼þ¸´Î»³õÊ¼»¯*///×èÈû
 647          //bit ZigB_resetInit(void){
 648          
 649          //#define zigbInit_loopTry              3
 650          //#define zigbInit_onceWait     5000
 651          
 652          //      u8 code initCmp_Frame[11] = {0xFE, 0x06, 0x41, 0x80, 0x01, 0x02, 0x00, 0x02, 0x06, 0x03, 0xC3};
 653          //      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 12  

 654          //      u8      loop = 0;
 655          //      u16 timeWait = 0;
 656          //      
 657          //      for(loop = 0; loop < zigbInit_loopTry; loop ++){
 658          //      
 659          //              zigbPin_RESET = 0;
 660          //              delayMs(100);
 661          //              zigbPin_RESET = 1;
 662          //              
 663          //              timeWait = zigbInit_onceWait;
 664          //              while(timeWait --){
 665          //              
 666          //                      delayMs(2);     //±ØÐëÑÓÊ±
 667          //                      if(uartRX_toutFLG){
 668          //                      
 669          //                              uartRX_toutFLG = 0;
 670          //                              
 671          //                              if(!memcmp(datsRcv_ZIGB.rcvDats, initCmp_Frame, 11)){
 672          //                              
 673          //                                      return 1;
 674          //                                      
 675          //                              }else{
 676          //                                      
 677          //                                      delayMs(1);     //±ØÐëÑÓÊ±
 678          //                              }
 679          //                      }
 680          //              }
 681          //      }
 682          //      
 683          //      return 0;
 684          //}
 685          
 686          ///*zigbee³õÊ¼»¯×Ô¼ì*///×èÈû
 687          //bit ZigB_inspectionSelf(void){        
 688          //      
 689          //#define       paramLen_zigbInspection 64
 690          //      u8 xdata paramTX_temp[paramLen_zigbInspection] = {0};
 691          //      
 692          ////    bit REQResult = 0;
 693          //      
 694          ////    u8 code frameREQ_zigbStatusCheck[5] = {0xFE, 0x00, 0x27, 0x00, 0x27};   //zigb×´Ì¬²éÑ¯Ö¸ÁîÖ¡
 695          ////    u8 code cmdResp_zigbStatusCheck[2]      = {0x67, 0x00}; //zigb×´Ì¬²éÑ¯ÏìÓ¦Ö¸Áî
 696          //      u8 code frameREQ_zigbJoinNWK[5]         = {0xFE, 0x00, 0x26, 0x00, 0x26};       //zigb¼¤»îÍøÂçÖ¸ÁîÖ¡
 697          //      u8 code cmdResp_zigbJoinNWK[2]          = {0x45, 0xC0}; //zigb¼¤»îÍøÂçÏìÓ¦Ö¸Áî
 698          //      u8 datsResp_Len = 0;
 699          //      
 700          ////    datsResp_Len = zigb_datsRequest(frameREQ_zigbStatusCheck, 5, cmdResp_zigbStatusCheck, paramTX_temp, 2
             -, 500);
 701          ////    if(paramTX_temp[16] == 0x07)REQResult
 702          //      
 703          //      datsResp_Len = zigb_datsRequest(frameREQ_zigbJoinNWK, 5, cmdResp_zigbJoinNWK, paramTX_temp, 2, 5000);
 704          //      if(paramTX_temp[4] == 0x07)return (zigb_clusterSet(13, 13) & zigb_clusterSet(13, 14));  //Éè±¸ID 13£¬ÖÕ¶
             -Ëµã 13£»        
 705          //      else{
 706          //      
 707          //              return 0;
 708          //      }
 709          //}
 710          
 711          /*zigbee·Ç×èÈûÈëÍøÇëÇó×´Ì¬»ú*///·Ç×èÈû ---ÐÅµÀÄ¬ÈÏµÚËÄÐÅµÀ
 712          static 
 713          void zigB_nwkJoinRequest(bit reJoin_IF){
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 13  

 714   1      
 715   1      #define cmdNum_zigbNwkREQ       9       
 716   1      
 717   1              datsAttr_ZigbInit code ZigbInit_dats[cmdNum_zigbNwkREQ] = {
 718   1      
 719   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¸´Î»(Ó²¼þ)
 720   1      //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x00,0x02,0x00,0x02,0x06,0x03,0xC2},       0x0B,   4000    },      
             -//¸´Î»(Ìæ²¹)
 721   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¸´Î»(Èí¼þ)
 722   1                      {       {0x26,0x05},    {0x03,0x01,0x03},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //¼Ä´æÆ÷³õÊ
             -¼»¯£¬È«²¿Çå¿Õ
 723   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¶þ´Î¸´Î»(Èí¼þ)
 724   1                      
 725   1      //              {       {0x26,0x05},    {0x87,0x01,0x00},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨Ð­µ÷Æ÷£©
 726   1                      {       {0x26,0x05},    {0x87,0x01,0x01},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖÃ£
             -¨Â·ÓÉÆ÷£©
 727   1      //              {       {0x26,0x05},    {0x87,0x01,0x02},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨ÖÕ¶Ë£©
 728   1                      
 729   1                      {       {0x27,0x02},    {0xFF,0xFF},                    0x02,   {0xFE,0x01,0x67,0x02,0x00,0x64},                                                        0x06,   500             },      //PAN_ID¼Ä´æÆ÷É
             -èÖÃ
 730   1                      {       {0x27,0x03},    {0x00,0x80,0x00,0x00},  0x04,   {0xFE,0x01,0x67,0x03,0x00,0x65},                                                        0x06,   500             },      //ÐÅµÀ¼
             -Ä´æÆ÷ÅäÖÃ
 731   1      //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x09,0x8D},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨Ð­µ÷Æ÷ÏìÓ¦£©
 732   1                      {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x07,0x83},                                                        0x06,   8000    },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨½ÇÉ
             -«Ð­µ÷Æ÷£¨Â·ÓÉÆ÷ÏìÓ¦£©
 733   1      //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x06,0x82},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨ÖÕ¶ËÏìÓ¦£©
 734   1                      {       {0x26,0x08},    {0xFC,0xFF,0x00},               0x03,   {0xFE,0x01,0x66,0x08,0x00,0x6F},                                                        0x06,   150             },  //¹Ø±Õ
             -ÍøÂç
 735   1              };
 736   1              
 737   1              datsAttr_ZigbInit code defaultParam_clusterRegister = {{0x24,0x00},{0x0E,0x0D,0x00,0x0D,0x00,0x0D,0x00,0x
             -01,0x00,0x00,0x01,0x00,0x00},0x0D,{0xFE,0x01,0x64,0x00,0x00,0x65},0x06,500};  //Êý¾Ý´Ø×¢²á,Ä¬ÈÏ²ÎÊý
 738   1              u8 code frameResponseSubs_clusterRegister[6] = {0xFE,0x01,0x64,0x00,0xB8,0xDD}; //ÏìÓ¦Ö¡Ìæ²¹£¬ÈôÊý¾Ý´ØÒÑ¾
             -­×¢²á
 739   1              
 740   1      #define clusterNum_default 3
 741   1              datsAttr_clusterREG code cluster_Default[clusterNum_default] = {
 742   1              
 743   1                      {ZIGB_ENDPOINT_CTRLSECENARIO, zigbDatsDefault_ClustID}, 
 744   1                      {ZIGB_ENDPOINT_CTRLNORMAL, zigbDatsDefault_ClustID}, 
 745   1                      {ZIGB_ENDPOINT_CTRLSYSZIGB, zigbDatsDefault_ClustID}
 746   1              };
 747   1              
 748   1      #define dataLen_zigbNwkREQ 64
 749   1              u8 xdata paramTX_temp[dataLen_zigbNwkREQ] = {0};
 750   1              
 751   1              static u8 xdata step_CortexA = 0, //×´Ì¬»ú-Ö÷²½Öè
 752   1                                xdata step_CortexB = 0; //×´Ì¬»ú-×Ó²½Öè
 753   1              static u8 xdata reactionLoop = 0; //ÖØ¸´´ÎÊý»º´æ
 754   1                         u8 xdata actionReaptDefine_normal = 2; //ÖØ¸´´ÎÊý¶¨Òå_³£¹æÖ¸ÁîÏÂ
 755   1              
 756   1              u8 datsTX_Len = 0;
 757   1              
 758   1              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
 759   2              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 14  

 760   2                      devStatus_switch.statusChange_IF = 0;
 761   2                      devRunning_Status = devStatus_switch.statusChange_standBy;
 762   2                      
 763   2                      step_CortexA = 0;
 764   2                      step_CortexB = 0;
 765   2                      reactionLoop = 0;
 766   2                      zigbPin_RESET = 1;
 767   2                      
 768   2                      return;
 769   2              }
 770   1              
 771   1              if(step_CortexA > (cmdNum_zigbNwkREQ + clusterNum_usr + clusterNum_default)){ //ÅÐ¶Ïµ±Ç°×´Ì¬»úÄÚ²¿×´Ì¬Á÷³
             -ÌÊÇ·ñÍê³É
 772   2              
 773   2                      step_CortexA = 0;
 774   2                      step_CortexB = 0;
 775   2                      reactionLoop = 0;
 776   2                      zigbPin_RESET = 1;
 777   2                      
 778   2                      sysTimeReales_counter = PERIOD_SYSTIMEREALES; //systime¸üÐÂÖÜÆÚÖØÖÃ£¬·ÀÖ¹¶àÖ¸Áî¶ÂÈû³åÍ»
 779   2                      
 780   2                      devRunning_Status = status_passiveDataRcv; //Íâ²¿×´Ì¬ÇÐ»»
 781   2                      devTips_status = status_Normal; //Éè±¸ÏµÍ³tips×´Ì¬ÇÐ»»
 782   2                      
 783   2      #if(DEBUG_LOGOUT_EN == 1)
 784   2                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 785   3                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 786   3                              sprintf(log_buf, "nwkZigb connect/rejoin all complete.\n");
 787   3                              PrintString1_logOut(log_buf);
 788   3                      }                       
 789   2      #endif
 790   2                      
 791   2                      return;
 792   2              }
 793   1              
 794   1              if(!reJoin_IF)if(step_CortexA == 0)step_CortexA = 7; //ÊÇ·ñÎªÖØÐÂÖ÷¶¯¼ÓÈëÐÂÍøÂç£¬·ñÔò²»½øÐÐÓ²¼þ¸´Î»(Ó²¼þ¸
             -´Î»½«µ¼ÖÂ±¾µØÊ±¼ä±»ÖØÖÃ)
 795   1              if((step_CortexA == 7) || (step_CortexA == 0))sysTimeReales_counter     = PERIOD_SYSTIMEREALES; //·Ç×èÈû¹Ø¼üÖ
             -¸Áî²»ÄÜ±»×èÈûÖ¸Áî´ò¶Ï£¨Ó²¼þ¸´Î» ºÍ ÈëÍøÊ± ÖÐ¶Ï×èÈûÖ¸ÁîÏÂ´ï£©
 796   1              
 797   1      #if(DEBUG_LOGOUT_EN == 1)
 798   1              {//Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 799   2              #define STATUSMACHINE_NWKREQ_DISPINITVAL 255
 800   2                      static u8 xdata stepDisp_CortexA = STATUSMACHINE_NWKREQ_DISPINITVAL;
 801   2                      
 802   2                      if(stepDisp_CortexA != step_CortexA){
 803   3                      
 804   3                              stepDisp_CortexA = step_CortexA;
 805   3                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 806   3                              sprintf(log_buf, "nwkZigb connect/rejoin mainStep-%02d@method:%d complete.\n", (int)stepDisp_CortexA, (
             -int)reJoin_IF);
 807   3                              PrintString1_logOut(log_buf);
 808   3                      }
 809   2              }
 810   1      #endif
 811   1              
 812   1              if(step_CortexA == 0){ //ÌØÊâÖ¸Áî_Ó²¼þ¸´Î»:<0>
 813   2              
 814   2                      switch(step_CortexA){
 815   3                      
 816   3                              case 0:{ //Ê×ÌõÖ¸Áî£¬Ó²¼þ¸´Î»
 817   4                              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 15  

 818   4                                      switch(step_CortexB){
 819   5                                      
 820   5                                              case 0:{ //²½ÖèÒ»£ºÓ²¼þÀ­µÍ100ms
 821   6                                              
 822   6                                                      zigbPin_RESET = 0;
 823   6                                                      zigbNwkAction_counter = 200;
 824   6                                                      step_CortexB = 1;
 825   6                                              
 826   6                                              }break;
 827   5                                      
 828   5                                              case 1:{ //²½Öè¶þ£ºÓ²¼þÀ­µÍÍê±ÏºóÈ·ÈÏÓ¦´ðÖ¡Ê±³¤
 829   6                                              
 830   6                                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý6000ms
 831   7                                                      
 832   7                                                              zigbPin_RESET = 1;
 833   7                                                              zigbNwkAction_counter = 6000;
 834   7                                                              step_CortexB = 2;
 835   7                                                      }
 836   6                                                      
 837   6                                              }break;
 838   5                                              
 839   5                                              case 2:{ //²½Öè¶þ£ºÈ·ÈÏÓ¦´ðÖ¡
 840   6                                                      
 841   6                                                      if(!zigbNwkAction_counter)step_CortexB = 0; //·Ç×èÈûµÈ´ýÏìÓ¦
 842   6                                              
 843   6                                                      if(uartRX_toutFLG){
 844   7                                                      
 845   7                                                              uartRX_toutFLG = 0;
 846   7                                                              
 847   7                                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ZigbInit_dats[0].zigbInit_REPLY, ZigbInit_dats[0].RE
             -PLY_num)){
 848   8                              
 849   8                                                                      step_CortexB = 0;
 850   8                                                                      reactionLoop = 0;
 851   8                                                                      step_CortexA ++;
 852   8                                                              }
 853   7                                                      }
 854   6                                                      
 855   6                                              }break;
 856   5                                      }
 857   4                                      
 858   4                              }break;
 859   3                      }
 860   2              }else
 861   1              if(step_CortexA > 0 && step_CortexA < cmdNum_zigbNwkREQ){ //³£¹æÖ¸Áî:<1 - 9>
 862   2                      
 863   2      //              if(!reJoin_IF)if(step_CortexA == 2)step_CortexA = 7;    //ÊÇ·ñÎªÖØÐÂÖ÷¶¯¼ÓÈëÐÂÍøÂç£¬·ñÔòÖ»½øÐÐ±»¶¯ÍøÂç¼¤»
             -î
 864   2      
 865   2                      switch(step_CortexB){
 866   3                      
 867   3                              case 0:{
 868   4                                      
 869   4                                      (step_CortexA == 7)?(actionReaptDefine_normal = 12):(actionReaptDefine_normal =  2); //ÓÉÓÚÈëÍø¹ý³Ì½Ï¸
             -´ÔÓ£¬ÈëÍøÖ¸ÁîµÈ´ýÊ±¼ä·Å³¤
 870   4                                      
 871   4                                      if(reactionLoop > actionReaptDefine_normal){
 872   5                                              
 873   5                                              reactionLoop = 0;
 874   5                                              step_CortexA = 0;
 875   5                                              break;
 876   5                                      }
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 16  

 877   4                                      
 878   4                                      datsTX_Len = ZigB_TXFrameLoad(paramTX_temp, 
 879   4                                                                                                ZigbInit_dats[step_CortexA].zigbInit_reqCMD, 
 880   4                                                                                                2, 
 881   4                                                                                                ZigbInit_dats[step_CortexA].zigbInit_reqDAT, 
 882   4                                                                                                ZigbInit_dats[step_CortexA].reqDAT_num);
 883   4                                      
 884   4                                      uartZigB_datsSend(paramTX_temp, datsTX_Len);
 885   4                                      
 886   4                                      zigbNwkAction_counter = ZigbInit_dats[step_CortexA].timeTab_waitAnsr;
 887   4                                      step_CortexB = 1;
 888   4                                      
 889   4                              }break;
 890   3                                      
 891   3                              case 1:{
 892   4                                      
 893   4                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ýÏìÓ¦
 894   5                                      
 895   5                                              reactionLoop ++;
 896   5                                              step_CortexB = 0;
 897   5                                      }
 898   4                                      else
 899   4                                      if(uartRX_toutFLG){
 900   5                                      
 901   5                                              uartRX_toutFLG = 0;
 902   5                                              
 903   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ZigbInit_dats[step_CortexA].zigbInit_REPLY, ZigbInit_d
             -ats[step_CortexA].REPLY_num)){
 904   6                                              
 905   6                                                      step_CortexB = 0;
 906   6                                                      reactionLoop = 0;
 907   6                                                      step_CortexA ++;
 908   6                                              }
 909   5                                      }
 910   4                                      
 911   4                              }break;
 912   3                      }
 913   2                      
 914   2              }else
 915   1              if(step_CortexA >= cmdNum_zigbNwkREQ){ //ÌØÊâÖ¸Áî_³£¹æÍ¨ÐÅ´Ø×¢²á:<10 - n>
 916   2                      
 917   2                      u8 datsREG_cluster[16] = {0};
 918   2                      memcpy(datsREG_cluster, defaultParam_clusterRegister.zigbInit_reqDAT, defaultParam_clusterRegister.reqDA
             -T_num);
 919   2                      if(step_CortexA < (cmdNum_zigbNwkREQ + clusterNum_default)){ //Ä¬ÈÏ×¨ÓÃÍ¨ÐÅ´Ø²ÎÊýÌî×°
 920   3                      
 921   3                              datsREG_cluster[0] = cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].endpoint;
 922   3                              datsREG_cluster[3] = (u8)((cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].devID & 0x00ff) >> 0);
 923   3                              datsREG_cluster[4] = (u8)((cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].devID & 0xff00) >> 8);
 924   3                              
 925   3                      }else{  //ÓÃ»§Í¨ÐÅ´Ø£¨»¥¿Ø£©×¢²á²ÎÊýÌî×°
 926   3                      
 927   3                              if((CTRLEATHER_PORT[step_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr] >= 0x10) && (CTRLEATHER_PORT[ste
             -p_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr] < 255)){ //Í¨ÐÅ´Ø¶Ë¿ÚºÏ·¨ÐÔÅÐ¶Ï
 928   4                              
 929   4                                      datsREG_cluster[0] = CTRLEATHER_PORT[step_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr];
 930   4                                      datsREG_cluster[3] = zigbDatsDefault_ClustID; //Ä¬ÈÏ´ØID <LSB>
 931   4                                      datsREG_cluster[4] = 0; //Ä¬ÈÏ´ØID <MSB>
 932   4                                      
 933   4                              }else{
 934   4                              
 935   4                                      step_CortexA ++;
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 17  

 936   4                                      return;
 937   4                              }
 938   3                      }
 939   2              
 940   2                      switch(step_CortexB){
 941   3                      
 942   3                              case 0:{
 943   4                                      
 944   4                                      if(reactionLoop > 2){
 945   5                                              
 946   5                                              reactionLoop = 0;
 947   5                                              step_CortexA = 0;
 948   5                                              break;
 949   5                                      }
 950   4                                      
 951   4                                      datsTX_Len = ZigB_TXFrameLoad(paramTX_temp, 
 952   4                                                                                                defaultParam_clusterRegister.zigbInit_reqCMD, 
 953   4                                                                                                2, 
 954   4                                                                                                datsREG_cluster, 
 955   4                                                                                                defaultParam_clusterRegister.reqDAT_num);
 956   4                                      
 957   4                                      uartZigB_datsSend(paramTX_temp, datsTX_Len);
 958   4                                      
 959   4                                      zigbNwkAction_counter = defaultParam_clusterRegister.timeTab_waitAnsr;
 960   4                                      step_CortexB = 1;
 961   4                                      
 962   4                              }break;
 963   3                                      
 964   3                              case 1:{
 965   4                                      
 966   4                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ýÏìÓ¦
 967   5                                      
 968   5                                              reactionLoop ++;
 969   5                                              step_CortexB = 0;
 970   5                                      }
 971   4                                      else
 972   4                                      if(uartRX_toutFLG){
 973   5                                      
 974   5                                              uartRX_toutFLG = 0;
 975   5                                              
 976   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, defaultParam_clusterRegister.zigbInit_REPLY, defaultPa
             -ram_clusterRegister.REPLY_num) || //Ô¤ÆÚÏìÓ¦
 977   5                                                 memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, frameResponseSubs_clusterRegister, 6)){ //Ìæ²¹ÏìÓ¦
 978   6                                              
 979   6                                                      step_CortexB = 0;
 980   6                                                      reactionLoop = 0;
 981   6                                                      step_CortexA ++;
 982   6                                              }
 983   5                                      }
 984   4                                      
 985   4                              }break;
 986   3                      }
 987   2              }
 988   1      }
 989          
 990          /*zigbeeÍøÂçÊý¾Ý·¢ËÍ¸ñÊ½»¯Ìî×°*/
 991          static 
 992          u8 zigb_datsLoad_datsSend(u8  frame_Temp[NORMALDATS_DEFAULT_LENGTH],
 993                                                            u16 DstAddr,
 994                                                            u8  portPoint,
 995                                                            u8  dats[],
 996                                                            u8  datsLen){
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 18  

 997   1              
 998   1              u8 code zigbCMD_DatsSend[2] = {0x24, 0x01};
 999   1              
1000   1      #define zigbDatsSend_datsTransLen       72
1001   1              u8 xdata buf_datsLOAD[zigbDatsSend_datsTransLen] = {0};
1002   1              u8 datsTX_Len = 0;
1003   1                                                                
1004   1              memset(frame_Temp, 0, NORMALDATS_DEFAULT_LENGTH * sizeof(u8));  
1005   1      
1006   1              //·¢ËÍÖ¡Ìî×°
1007   1              buf_datsLOAD[0] = (u8)((DstAddr & 0x00ff) >> 0);
1008   1              buf_datsLOAD[1] = (u8)((DstAddr & 0xff00) >> 8);
1009   1              buf_datsLOAD[2] = portPoint;
1010   1              buf_datsLOAD[3] = portPoint;
1011   1              buf_datsLOAD[4] = zigbDatsDefault_ClustID;
1012   1              buf_datsLOAD[6] = zigbDatsDefault_TransID;
1013   1              buf_datsLOAD[7] = zigbDatsDefault_Option;
1014   1              buf_datsLOAD[8] = zigbDatsDefault_Radius;
1015   1              buf_datsLOAD[9] = datsLen;
1016   1              memcpy(&buf_datsLOAD[10], dats, datsLen);       
1017   1              
1018   1              return ZigB_TXFrameLoad(frame_Temp, (u8 *)zigbCMD_DatsSend, 2, buf_datsLOAD, datsLen + 10);
1019   1      }
1020          
1021          /*zigbeeÎÞÊÓÏìÓ¦»Ø¸´Ö±½Ó·¢ËÍÊý¾Ý*///×èÈû
1022          static
1023          void dataSendRemote_straightforward( u16 DstAddr, //Ô¶¶ËÍøÂç¶ÌµØÖ·
1024                                                                                    u8 port,       //¶Ëµã¿Ú
1025                                                                                    u8 dats[], //Êý¾Ý
1026                                                                                    u8 datsLen ){ //Êý¾Ý³¤¶È
1027   1                                                                                                                                                
1028   1              u8 xdata buf_datsTX[NORMALDATS_DEFAULT_LENGTH] = {0};
1029   1              u8 datsTX_Len = 0;
1030   1              
1031   1              datsTX_Len = zigb_datsLoad_datsSend(buf_datsTX, DstAddr, port, dats, datsLen);
1032   1              
1033   1              uartZigB_datsSend(buf_datsTX, datsTX_Len);
1034   1      }
1035          
1036          /*zigbeeÍøÂçÊý¾Ý·¢ËÍÇëÇó×´Ì¬»ú*///·Ç×èÈû
1037          static
1038          void dataTransRequest_datsSend(void){
1039   1      
1040   1              u8 xdata buf_datsTX[NORMALDATS_DEFAULT_LENGTH] = {0};
1041   1              u8 datsTX_Len = 0;
1042   1              
1043   1      #define zigbDatsSend_datsRespLen        64
1044   1              u8 xdata buf_datsRX[zigbDatsSend_datsRespLen] = {0};
1045   1              u8 datsRX_Len = 0;
1046   1              
1047   1      #define zigbDatsSend_ASR_datsLen        3
1048   1              u8              ASR_dats[zigbDatsSend_ASR_datsLen] = {0};
1049   1              u8 code ASR_cmd[2] = {0x44,0x80};       //±¾µØZNPÐ­Òé²ãÈ·ÈÏ·¢ËÍÏìÓ¦
1050   1              
1051   1      #define resCODE_datsSend_NOROUTER 0xCD  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-Â·ÓÉÊ§Áª£¬Í¨Ñ¶Ã½½é¶ªÊ§
1052   1      #define resCODE_datsSend_NOREMOTE 0xE9  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-¶Ô·½²»ÔÚÏß£¬Ä¿±êµØÖ·½ÚµãÉè±¸²»´æÔÚ
1053   1      #define resCODE_datsSend_TIMEOUT  0x01  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-·¢ËÍ³¬Ê±
1054   1      #define resCODE_datsSend_SUCCESS  0x00  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-·¢ËÍ³É¹¦
1055   1              static u8 datsTrans_respondCode = 0; //·¢ËÍÍê³ÉÏìÓ¦Âë
1056   1              
1057   1              static u8 step = 0;
1058   1              static u8 reactionLoop = 0;
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 19  

1059   1              
1060   1              if(devStatus_switch.statusChange_IF){   //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
1061   2              
1062   2                      devStatus_switch.statusChange_IF = 0;
1063   2                      devRunning_Status = devStatus_switch.statusChange_standBy;
1064   2                      
1065   2                      step = 0;
1066   2                      reactionLoop = 0;
1067   2                      
1068   2                      return;
1069   2              }
1070   1              
1071   1              //½ÓÊÕÖ¡Ìî×°_±¾µØ
1072   1              ASR_dats[0] = resCODE_datsSend_SUCCESS; //·¢ËÍ³É¹¦ÏìÓ¦´úÂë
1073   1              ASR_dats[1] = datsSend_request.portPoint;
1074   1              ASR_dats[2] = zigbDatsDefault_TransID;
1075   1              datsRX_Len = ZigB_TXFrameLoad(buf_datsRX, (u8 *)ASR_cmd, 2, ASR_dats, zigbDatsSend_ASR_datsLen);
1076   1              
1077   1              datsTX_Len = zigb_datsLoad_datsSend(buf_datsTX, datsSend_request.nwkAddr, datsSend_request.portPoint, dat
             -sSend_request.datsTrans.dats, datsSend_request.datsTrans.datsLen);
1078   1              
1079   1              switch(step){
1080   2              
1081   2                      case 0:{ //ÏìÓ¦½ÓÊÕ¾ÍÐ÷£¬ÉèÖÃÏìÓ¦Ê±¼ä
1082   3                              
1083   3                              if(reactionLoop > 3){ //ÖØ·¢´ÎÊýÒÑ³¬³ö
1084   4                                      
1085   4                                      datsTrans_respondCode = resCODE_datsSend_TIMEOUT; //ÏìÓ¦Âë¸ÄÎª³¬Ê±
1086   4                                      
1087   4                                      reactionLoop = 0;
1088   4                                      step = 4;
1089   4                                      
1090   4                                      break;
1091   4                              }
1092   3                      
1093   3                              zigbPin_RESET = 1; //±£ÏÕÆð¼û£¬¸´Î»À­¸ß
1094   3                              if(!devRemoteDataReqMethod.keepTxUntilCmp_IF)uartZigB_datsSend(buf_datsTX, datsTX_Len); //·ÇËÀ¿Ä£¬·¢Ò»´
             -Î¾ÍÐÐ
1095   3                              zigbNwkAction_counter = REMOTE_DATAREQ_TIMEOUT; //Ä¬ÈÏÐ­Òé²ãÏìÓ¦Ê±¼ä<Ê±¼äÌ«¶ÌÎÞ·¨ÊÕµ½ºóÃæµÄ½ÓÊÕ×´Ì¬ÏìÓ¦
             -Ö¸Áî£¬Ö»ÄÜÊÕµ½ÏµÍ³ÏìÓ¦>
1096   3                              step = 1;
1097   3                              
1098   3                      }break;
1099   2                      
1100   2                      case 1:{ //·Ç×èÈûµÈ´ýÏµÍ³ÏìÓ¦
1101   3                              
1102   3                              static u8 xdata local_funRecord = 0; //±¾µØ ³ý´Î±È ÅÐ¶Ï
1103   3                                         u8 xdata funRecord_temp = zigbNwkAction_counter / devRemoteDataReqMethod.datsTxKeep_Period; //³ý´Î±
             -È£¬ÓÃÓÚÖÜÆÚÅÐ¶Ï
1104   3                      
1105   3                              if(!zigbNwkAction_counter){ //³¬Ê±ÅÐ¶Ï
1106   4                              
1107   4                                      reactionLoop ++;
1108   4                                      step = 0;
1109   4                                      local_funRecord = 0;
1110   4                              }
1111   3                              else{
1112   4                                      
1113   4                                      if(devRemoteDataReqMethod.keepTxUntilCmp_IF){ //ËÀ¿Ä·½Ê½ÏÂ£¬³¬Ê±Ê±¼äÄÚ£¬ÖÜÆÚÑ­»·ÏÂ·¢Ö¸Áî
1114   5                                              
1115   5                                              if(local_funRecord != funRecord_temp){ //°´³ÖÐøÆµÂÊ³ÖÐø·¢ËÍ
1116   6                                              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 20  

1117   6                                                      local_funRecord = funRecord_temp; //±¾µØ³ý´Î±È¸üÐÂ
1118   6                                                      
1119   6                                                      uartZigB_datsSend(buf_datsTX, datsTX_Len);
1120   6                                              }
1121   5                                      }
1122   4                                      
1123   4                                      if(uartRX_toutFLG){
1124   5                                      
1125   5                                              uartRX_toutFLG = 0;
1126   5      
1127   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, buf_datsRX, datsRX_Len)){ //Ó¦´ðÖ¸ÁîºÍÓ¦´ðÂë¶¼ÕýÈ·
1128   6                                              
1129   6                                                      if(datsRcv_respond.datsTrans.datsLen == 0){ //ÅÐ¶ÏÌõ¼þÊÇ·ñÐèÒªÔ¶¶ËÏìÓ¦
1130   7                                                      
1131   7                                                              step = 3;
1132   7                                                              
1133   7                                                      }else{
1134   7                                                      
1135   7                                                              step = 2;
1136   7                                                              zigbNwkAction_counter = REMOTE_RESPOND_TIMEOUT; //Ä¬ÈÏÔ¶¶ËÏìÓ¦Ê±¼ä<¶Ô·½½ÚµãÏìÓ¦>
1137   7                                                      }
1138   6                                                      
1139   6                                                      local_funRecord = 0; //±¾µØ³ý´Î±È¸´Î»
1140   6                                                      
1141   6                                              }else{  
1142   6                                                      
1143   6                                                      if(!memcmp(&datsRcv_ZIGB.rcvDats[2], ASR_cmd, 2)){ //Ó¦´ðÖ¸ÁîÕýÈ·£¬µ«Ó¦´ðÂë´íÎó£¬ÔòÈ¡³ö´íÎóÂë
1144   7                                                      
1145   7                                                              datsTrans_respondCode = datsRcv_ZIGB.rcvDats[4]; //´íÎóÏìÓ¦Âë×°ÔØ
1146   7                                                              
1147   7                                                              if(devRemoteDataReqMethod.keepTxUntilCmp_IF){ //·¢ËÍ·½Ê½ÅÐ¶Ï-ÊÇ·ñÎªËÀ¿Ä·½Ê½
1148   8                                                              
1149   8                                                                      
1150   8                                                                      
1151   8                                                              }else{
1152   8                                                              
1153   8                                                                      step = 4; //·ÇËÀ¿Ä·½Ê½£¬ÔòÓÐÓ¦´ðÖ¸Áî£¬µ«Ó¦´ðÊý¾Ý´íÎó£¬ÌøÖÁÊ§°Ü²½Öè
1154   8                                                              }
1155   7                                                      }
1156   6                                                      
1157   6      //#if(DEBUG_LOGOUT_EN == 1)
1158   6      //                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1159   6      //                                                      u8 xdata log_buf[64]; //Êý¾Ý´«ÊäÊ§°ÜÐ­Òé²ãÏìÓ¦´úÂë´òÓ¡
1160   6      //                                                      
1161   6      //                                                      sprintf(log_buf, "dats_TX fail code: %02X %02X %02X.\n", (int)datsRcv_ZIGB.rcvDats[2], (int)datsR
             -cv_ZIGB.rcvDats[3], (int)datsRcv_ZIGB.rcvDats[4]);
1162   6      //                                                      PrintString1_logOut(log_buf);
1163   6      //                                              }       
1164   6      //#endif                                
1165   6                                              }
1166   5                                      }
1167   4                              }
1168   3                              
1169   3                      }break;
1170   2                      
1171   2                      case 2:{ //·Ç×èÈûµÈ´ýÔ¶¶ËÏìÓ¦
1172   3      
1173   3                              if(!zigbNwkAction_counter){
1174   4                              
1175   4                                      reactionLoop ++;
1176   4                                      step = 0;
1177   4                              }
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 21  

1178   3                              else{
1179   4                                      
1180   4                                      if(uartRX_toutFLG){
1181   5                                              
1182   5                                              u16 idata datsFrom_addr = ((u16)(datsRcv_ZIGB.rcvDats[9]) << 8) | ((u16)(datsRcv_ZIGB.rcvDats[8]) << 
             -0); //Êý¾Ý·¢ËÍ·½ÍøÂçµØÖ·
1183   5                                              u8      idata dstPoint =  datsRcv_ZIGB.rcvDats[11];     //Ô¶¶Ë  
1184   5                                              
1185   5                                              uartRX_toutFLG = 0;
1186   5                                              
1187   5                                              if(datsRcv_ZIGB.rcvDats[0] != ZIGB_FRAME_HEAD){ //Ö¡Í·²»¶Ô£¬´òÓ¡Êä³ö
1188   6                                              
1189   6      #if(DEBUG_LOGOUT_EN == 1)
1190   6                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1191   7                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1192   7                                                              sprintf(log_buf, "err frameHead:%02X.\n", (int)datsRcv_ZIGB.rcvDats[0]);
1193   7                                                              PrintString1_logOut(log_buf);
1194   7                                                      }                       
1195   6      #endif  
1196   6                                              }
1197   5      
1198   5                                              if(!memcmp(&(datsRcv_ZIGB.rcvDats[21]), datsRcv_respond.datsTrans.dats, datsRcv_respond.datsTrans.dat
             -sLen) && 
1199   5                                                 (datsRcv_respond.nwkAddr == datsFrom_addr) &&
1200   5                                                      (datsRcv_respond.portPoint == dstPoint)){
1201   6                                              
1202   6                                                      step = 3;
1203   6                                                              
1204   6                                              }else{
1205   6                                              
1206   6      #if(DEBUG_LOGOUT_EN == 1)
1207   6                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1208   7                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1209   7      //                                                      sprintf(log_buf, "data remoteRcv is %02X %02X %02X.\n", (int)datsRcv_ZIGB.rcvDats[21], (int)datsR
             -cv_ZIGB.rcvDats[22], (int)datsRcv_ZIGB.rcvDats[23]);
1210   7                                                              sprintf(log_buf, "rcvPort is %02X, rcvNwkAddr is %04X.\n", (int)dstPoint, (int)datsFrom_addr);
1211   7      //                                                      sprintf(log_buf, "rcvPort is %02X, rcvNwkAddr is %04X.\n", (int)datsRcv_respond.portPoint, (int)d
             -atsRcv_respond.nwkAddr);
1212   7                                                              PrintString1_logOut(log_buf);
1213   7                                                      }       
1214   6      #endif  
1215   6                                              }
1216   5                                      }
1217   4                              }
1218   3                              
1219   3                      }break;
1220   2                      
1221   2                      case 3:{ //ÏìÓ¦³É¹¦
1222   3                      
1223   3                              if(reConnectAfterDatsReq_IF){ //Õë¶Ô¼´¿Ì×¢²á»¥¿ØÌØÊâÇé¿ö ×´Ì¬ÇÐ»»
1224   4                              
1225   4                                      reConnectAfterDatsReq_IF = 0;
1226   4                                      devRunning_Status = status_nwkReconnect;
1227   4                                      
1228   4                              }else{ 
1229   4                              
1230   4                                      devRunning_Status = status_passiveDataRcv;
1231   4                              }
1232   3                              
1233   3                              reactionLoop = 0;
1234   3                              step = 0;
1235   3                              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 22  

1236   3                              /*ËÀ¿ÄÊôÐÔ¸´Î»*///ÊôÐÔÉèÖÃ½öÉúÐ§Ò»´Î
1237   3                              devRemoteDataReqMethod.keepTxUntilCmp_IF = 0; //ËÀ¿ÄÊ¹ÄÜ¸´Î»
1238   3                              devRemoteDataReqMethod.datsTxKeep_Period = 0; //ËÀ¿ÄÖÜÆÚ¸´Î»
1239   3                              
1240   3                      }break;
1241   2                      
1242   2                      case 4:{ //ÏìÓ¦Ê§°Ü
1243   3                      
1244   3                              if(reConnectAfterDatsReq_IF){ //Õë¶Ô¼´¿Ì×¢²á»¥¿ØÌØÊâÇé¿ö ×´Ì¬ÇÐ»»
1245   4                              
1246   4                                      reConnectAfterDatsReq_IF = 0;
1247   4                                      devRunning_Status = status_nwkReconnect;
1248   4                                      
1249   4                              }else{ 
1250   4                              
1251   4                                      devRunning_Status = status_passiveDataRcv;
1252   4                              }
1253   3                              
1254   3                              //Õë¶ÔÊý¾Ý´«ÊäÊ§°ÜÏìÓ¦´úÂëÇé¿ö½øÐÐÑ¡ÔñÐÔÖØÁ¬£¬·ñÔò½öÊ±ÇøÐ­µ÷Æ÷Éè±¸¾Ígg
1255   3                              if(datsTrans_respondCode){ 
1256   4                                      
1257   4      #if(DEBUG_LOGOUT_EN == 1)                               
1258   4                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1259   5                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1260   5                                              sprintf(log_buf, "remote dataRequest fail, code:[0x%02X].\n", (int)datsTrans_respondCode);
1261   5                                              PrintString1_logOut(log_buf);
1262   5                                      }
1263   4      #endif  
1264   4                                      
1265   4                                      switch(datsTrans_respondCode){ //ÏìÓ¦Ê§°ÜÂë·ÖÎö
1266   5                                      
1267   5                                              case resCODE_datsSend_NOROUTER:
1268   5                                              case resCODE_datsSend_NOREMOTE:
1269   5                                              case resCODE_datsSend_SUCCESS:{
1270   6                                              
1271   6                                                      devTips_nwkZigb = nwkZigb_outLine; //ÔÝÊ±Ö»×öÊ§°ÜÌáÊ¾£¬²»×öÆäËû¶¯×÷
1272   6                                                      
1273   6                                              }break;
1274   5                                              
1275   5                                              default:{
1276   6                                              
1277   6                                                      devTips_nwkZigb = nwkZigb_outLine; //ÔÝÊ±Ö»×öÊ§°ÜÌáÊ¾£¬²»×öÆäËû¶¯×÷
1278   6                                                      
1279   6                                              }break;
1280   5                                      }
1281   4                                      
1282   4                                      datsTrans_respondCode = 0;
1283   4                              }
1284   3                              
1285   3                              reactionLoop = 0;
1286   3                              step = 0;
1287   3                              
1288   3                              /*ËÀ¿ÄÊôÐÔ¸´Î»*///ÊôÐÔÉèÖÃ½öÉúÐ§Ò»´Î
1289   3                              devRemoteDataReqMethod.keepTxUntilCmp_IF = 0; //ËÀ¿ÄÊ¹ÄÜ¸´Î»
1290   3                              devRemoteDataReqMethod.datsTxKeep_Period = 0; //ËÀ¿ÄÖÜÆÚ¸´Î»
1291   3                              
1292   3                      }break;
1293   2                              
1294   2                      default:{
1295   3                      
1296   3                              step = 4;
1297   3                              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 23  

1298   3                      }break;
1299   2              }
1300   1      }
1301          
1302          /*Éè±¸Êý¾Ý´«ÊäÖ÷×´Ì¬ÇÐ»»ÖÁÍøÂç¹ÒÆð*/
1303          void devStatusChangeTo_devHold(bit zigbNwkSysNote_IF){ //Éè±¸ÍøÂç¹ÒÆð
1304   1      
1305   1              devNwkHoldTime_Param.devHoldTime_counter = DEVHOLD_TIME_DEFAULT;
1306   1              if(zigbNwkSysNote_IF)devNwkHoldTime_Param.zigbNwkSystemNote_IF = 1;
1307   1              
1308   1              devStatus_switch.statusChange_standBy = status_devNwkHold; //Êý¾Ý´«Êä×´Ì¬»ú¸ü±ä
1309   1              devStatus_switch.statusChange_IF = 1;
1310   1              
1311   1              devTips_status = status_devHold; //tips¸ü±ä
1312   1              
1313   1      #if(DEBUG_LOGOUT_EN == 1)                               
1314   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1315   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1316   2                      sprintf(log_buf, "devHold start right now.\n");
1317   2                      PrintString1_logOut(log_buf);
1318   2              }
1319   1      #endif  
1320   1      }
1321          
1322          /*Éè±¸ÍøÂç¹ÒÆðÍ£Ö¹£¬Ê¹ÌáÇ°½áÊø*/
1323          void devHoldStop_makeInAdvance(void){ //Í£Ö¹Éè±¸ÍøÂç¹ÒÆð£¨ÌáÇ°£©
1324   1      
1325   1              if(devNwkHoldTime_Param.devHoldTime_counter)devNwkHoldTime_Param.devHoldTime_counter = 0;
1326   1      }
1327          
1328          /*zigbeeÉè±¸ÍøÂç¹ÒÆð×´Ì¬»ú*///·Ç×èÈû
1329          static 
1330          void function_devNwkHold(void){
1331   1              
1332   1              static status_Step = 0; //µ±Ç°×´Ì¬»ú²½Öè×´Ì¬Ö¸Ê¾
1333   1              
1334   1              if(devNwkHoldTime_Param.devHoldTime_counter){ //Ö±µ½¹ÒÆðÊ±¼ä½áÊø
1335   2              
1336   2                      if(devNwkHoldTime_Param.zigbNwkSystemNote_IF){ //Í¨Öªµ±Ç°ÍøÂçÄÚ×ÓÉè±¸¹ÒÆð,±¨Ò»´Î
1337   3                              
1338   3                              u8 xdata dats_Note[3] = {ZIGB_SYSCMD_DEVHOLD, 1, 0}; //ÃüÁî¡¢Êý¾Ý³¤¶È¡¢Êý¾Ý
1339   3                      
1340   3                              devNwkHoldTime_Param.zigbNwkSystemNote_IF = 0; //Í¨ÖªÊ¹ÄÜ¸´Î»
1341   3                              
1342   3                              dataSendRemote_straightforward( 0xFFFF, //¹ã²¥Í¨ÖªÍøÄÚËùÓÐ×ÓÉè±¸¹ÒÆð
1343   3                                                                                              ZIGB_ENDPOINT_CTRLSYSZIGB,
1344   3                                                                                              dats_Note,
1345   3                                                                                              3 );
1346   3                              
1347   3                              delayMs(50); //±ØÐèÑÓÊ±£¬·ñÔòÊý¾Ý»¹Ã»·¢ËÍ³öÈ¥£¬¾ÍÅÜµ½ÏÂÒ»²½¸´Î»ÁË
1348   3                      }
1349   2                      
1350   2                      { //Éè±¸¹ÒÆð,Ñ­»·¸´Î»
1351   3                              
1352   3                              switch(status_Step){
1353   4                              
1354   4                                      case 0:{ //¸´Î»200ms
1355   5                                      
1356   5                                              zigbPin_RESET = 0;
1357   5                                              zigbNwkAction_counter = 200;
1358   5                                              status_Step = 1;
1359   5                                      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 24  

1360   5                                      }break;
1361   4                                              
1362   4                                      case 1:{ //Ã¿6s¸´Î»Ò»´Î
1363   5                                      
1364   5                                              if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý
1365   6                                              
1366   6                                                      zigbPin_RESET = 1;
1367   6                                                      zigbNwkAction_counter = 6000;
1368   6                                                      status_Step = 2;
1369   6                                              }
1370   5                                      
1371   5                                      }break;
1372   4                                      
1373   4                                      case 2:{
1374   5                                      
1375   5                                              if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý
1376   6                                              
1377   6                                                      status_Step = 0;
1378   6                                                      
1379   6      #if(DEBUG_LOGOUT_EN == 1)                               
1380   6                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1381   7                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1382   7                                                              sprintf(log_buf, "devHold time count remind: %02d s.\n", (int)devNwkHoldTime_Param.devHoldTime_coun
             -ter);
1383   7                                                              PrintString1_logOut(log_buf);
1384   7                                                      }
1385   6      #endif
1386   6                                              }
1387   5                                      
1388   5                                      }break;
1389   4                                      
1390   4                                      default:{
1391   5                                              
1392   5                                              status_Step = 0;
1393   5                                              
1394   5                                      }break;
1395   4                              }
1396   3                      }
1397   2      
1398   2              }else{
1399   2              
1400   2                      //¹ÒÆðÊ±¼ä½áÊø,Ö÷×´Ì¬»Ö¸´ÖÁÖØÁ¬£¬±¾µØ×´Ì¬»Ö¸´
1401   2                      status_Step = 0;
1402   2                      zigbPin_RESET = 1;
1403   2                      
1404   2                      devRunning_Status = status_nwkReconnect; //Ö±½Ó½«Ö÷×´Ì¬ÇÐ»»ÖÁÍøÂçÖØÁ¬,²»×ßstandbyÁ÷³Ì
1405   2                      devTips_status = status_Normal; //tips¸ü±ä
1406   2              
1407   2      #if(DEBUG_LOGOUT_EN == 1)                               
1408   2                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1409   3                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1410   3                              sprintf(log_buf, "devHold stop.\n");
1411   3                              PrintString1_logOut(log_buf);
1412   3                      }
1413   2      #endif  
1414   2              }
1415   1      }
1416          
1417          /*zigbee¼¯Èº¿ØÖÆÊý¾Ý½âÎö*/
1418          static 
1419          void dataParing_scenarioCtrl(u8 datsFrame[]){
1420   1      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 25  

1421   1              u8 dataTX_temp = CTRLSECENARIO_RESPCMD_SPECIAL;
1422   1              
1423   1              swCommand_fromUsr.objRelay = datsFrame[0]; //¼ÌµçÆ÷ÏìÓ¦¼´¿É
1424   1              swCommand_fromUsr.actMethod = relay_OnOff;
1425   1              
1426   1              colonyCtrlGet_statusLocalScene = datsFrame[0]; //±¾µØ³¡¾°¿ØÖÆÂÖÑ¯Öµ¸üÐÂ(³¡¾°¿ØÖÆ½öÀ´×ÔÓÚÊÖ»ú¿ØÖÆ)
1427   1              
1428   1              dataSendRemote_straightforward(0, ZIGB_ENDPOINT_CTRLSECENARIO, &dataTX_temp, 1); //³¡¾°¿ØÖÆÔ¶¶Ë»Ø¸´
1429   1              
1430   1      #if(DEBUG_LOGOUT_EN == 1)
1431   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1432   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1433   2                      sprintf(log_buf, "cmdScenarioCtrl comming, statusData:%02X.\n", (int)datsFrame[0]);
1434   2                      PrintString1_logOut(log_buf);
1435   2              }                       
1436   1      #endif          
1437   1      }
1438          
1439          /*zigbeeÏµÍ³½»»¥Êý¾Ý½âÎö*/
1440          static 
1441          void dataParing_zigbSysCtrl(u8 datsFrame[]){
1442   1      
1443   1              /*>>>>>>>>>>>>>>frame reference<<<<<<<<<<<<<<<<<*/
1444   1              /*----------------------------------------------*/
1445   1              /*  frame_CMD   |       frame_dataLen|  frame_data      |
1446   1              /*----------------------------------------------*/
1447   1              /*      1byte           |       1byte            |      < 256byte       |       
1448   1              /*----------------------------------------------*/
1449   1              
1450   1              frame_zigbSysCtrl xdata dats = {0};
1451   1              
1452   1              dats.command = datsFrame[0];
1453   1              memcpy(dats.dats, &datsFrame[2], datsFrame[1]);
1454   1              dats.datsLen = datsFrame[1];
1455   1              
1456   1              switch(dats.command){
1457   2              
1458   2                      case ZIGB_SYSCMD_NWKOPEN:{ //ÍøÂç¿ª·Å
1459   3                              
1460   3                              bit resultSet = 0;
1461   3                              
1462   3                              resultSet = ZigB_nwkOpen(1, dats.dats[0]); //¹¦ÄÜ´¥·¢
1463   3                              tips_statusChangeToZigbNwkOpen(dats.dats[0]); //tips´¥·¢
1464   3                              
1465   3      #if(DEBUG_LOGOUT_EN == 1)
1466   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1467   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1468   4                                      sprintf(log_buf, "master cmdComing:nwkOpen:%02ds.\n", (int)dats.dats[0]);
1469   4                                      PrintString1_logOut(log_buf);
1470   4                              }                       
1471   3      #endif          
1472   3                              
1473   3                      }break;
1474   2                      
1475   2                      case ZIGB_SYSCMD_TIMESET:{ //ÏµÍ³Ê±¼äÉè¶¨
1476   3                      
1477   3                              bit resultSet = 0;
1478   3                              bit timeZoneAdjust_needIF = 0;
1479   3                              u32 time_Temp = 0UL;
1480   3                              
1481   3                              time_Temp |= (u32)dats.dats[0] << 0;
1482   3                              time_Temp |= (u32)dats.dats[1] << 8;
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 26  

1483   3                              time_Temp |= (u32)dats.dats[2] << 16;
1484   3                              time_Temp |= (u32)dats.dats[3] << 24;
1485   3                              if((sysTimeZone_H != dats.dats[4]) || (sysTimeZone_M != dats.dats[5])){ //Ê±ÇøÍ¬²½
1486   4                              
1487   4                                      sysTimeZone_H = dats.dats[4];
1488   4                                      sysTimeZone_M = dats.dats[5];
1489   4                                      coverEEPROM_write_n(EEPROM_ADDR_timeZone_H, &sysTimeZone_H, 1);
1490   4                                      coverEEPROM_write_n(EEPROM_ADDR_timeZone_M, &sysTimeZone_M, 1);
1491   4                              }
1492   3                              
1493   3                              if(dats.dats[6])timeZoneAdjust_needIF = 1; //Ê±Çø²¹³¥Ê¹ÄÜÅÐ¶Ï
1494   3                              if(time_Temp > ZIGB_UTCTIME_START)resultSet = zigB_sysTimeSet(time_Temp - ZIGB_UTCTIME_START, timeZoneA
             -djust_needIF); //zigbee ±¾µØÏµÍ³Ê±¼äÉèÖÃ<UTC¸º²¹³¥>
1495   3                              
1496   3      #if(DEBUG_LOGOUT_EN == 1)
1497   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1498   4                                      u8 xdata log_buf[64];
1499   4                                      
1500   4                                      sprintf(log_buf, "master UTC coming:[0x%02X%02X%02X%02X].\n", (int)dats.dats[3], (int)dats.dats[2], (i
             -nt)dats.dats[1], (int)dats.dats[0]);
1501   4                                      PrintString1_logOut(log_buf);
1502   4                              }                       
1503   3      #endif  
1504   3                      }break;
1505   2                      
1506   2                      case ZIGB_SYSCMD_DEVHOLD:{ //ÍøÂç¹ÒÆð£¨ÓÃ×÷Íø¹ØÇÐ»»£©
1507   3                              
1508   3      #if(DEBUG_LOGOUT_EN == 1)
1509   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1510   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1511   4                                      sprintf(log_buf, "node cmdComing:devNwk hold.\n");
1512   4                                      PrintString1_logOut(log_buf);
1513   4                              }                       
1514   3      #endif  
1515   3                              devStatusChangeTo_devHold(0); //Éè±¸ÍøÂç±»¶¯¹ÒÆð,²»½øÐÐÍøÂçÍ¨Öª
1516   3                              
1517   3                      }break;
1518   2                      
1519   2                      case ZIGB_SYSCMD_DATATRANS_HOLD:{ //Í¨ÐÅÖ÷¶¯±ÜÕÏ£¬½«ÖÜÆÚÐÔÍ¨ÐÅ¹ÒÆð
1520   3                              
1521   3      #if(DEBUG_LOGOUT_EN == 1)
1522   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1523   4                                      u8 xdata log_buf[64];
1524   4                                      
1525   4                                      sprintf(log_buf, "master cmd: dtPeriod hold, time:%d.\n", (int)dats.dats[0]);
1526   4                                      PrintString1_logOut(log_buf);
1527   4                              }                       
1528   3      #endif  
1529   3                              if(!heartBeatHang_timeCnt && !colonyCtrlGetHang_timeCnt){ //ÓÐÐ§ÖÜÆÚÄÚ£¬¸¨Öú²¹³ä¹ã²¥Ò»´Î£¬·ÀÖ¹ÆäËû½ÚµãÃ
             -»ÊÕµ½
1530   4                                      
1531   4      //                              PrintString1_logOut("dtPeriod hold one more time.\n");
1532   4      //                              dataSendRemote_straightforward(0xffff, ZIGB_ENDPOINT_CTRLSYSZIGB, datsFrame, datsFrame[1] + 2);
1533   4                                      
1534   4                              }else{
1535   4                              
1536   4      //#if(DEBUG_LOGOUT_EN == 1)
1537   4      //                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1538   4      //                                      u8 xdata log_buf[64];
1539   4      //                                      
1540   4      //                                      sprintf(log_buf, "dtPeriod holdAdd err, parm1: %d, parm2: %d.\n", (int)heartBeatHang_timeCnt, (int)
             -colonyCtrlGetHang_timeCnt);
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 27  

1541   4      //                                      PrintString1_logOut(log_buf);
1542   4      //                              }                       
1543   4      //#endif        
1544   4                              }
1545   3                              
1546   3                              periodDataTrans_momentHang(dats.dats[0]);  //±ÜÕÏÊ±¼ä¼ÓÔØ£¬¶¯×÷Ö´ÐÐ
1547   3                      }
1548   2      
1549   2      #if(COLONYINFO_QUERYPERIOD_EN == ENABLE) /*ºêÅÐÍ·*///¼¯Èº¿ØÖÆÐÅÏ¢ÖÜÆÚ²éÑ¯Ê¹ÄÜ
                              case ZIGB_SYSCMD_COLONYPARAM_REQPERIOD:{ /*ºêÊ¹ÄÜ*///¸üÐÂ¼¯ÈºÐÅÏ¢²¢¶¯×÷
                              
                                      /*>>>>>>>>>>>>>>>>>>>frame_data reference<<<<<<<<<<<<<<<*/
                                      /*------------------------------------------------------*/
                                      /*  frame_data[0]                       |       frame_data[1...3]               |
                                      /*------------------------------------------------------*/
                                      /*      ×î½üÒ»´Î³¡¾°¿ØÖÆ×´Ì¬Öµ  |       ×î½üÒ»´Î»¥¿Ø¸üÐÂ×´Ì¬Öµ  |
                                      /*------------------------------------------------------*/
                                      
                                      u8 idata statusRelay_temp = status_Relay; //¿ª¹Ø¶¯×÷Ö´ÐÐ»º´æ
                                      
              //#if(DEBUG_LOGOUT_EN == 1)
              //                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
              //                                      u8 xdata log_buf[64];
              //                                      
              //                                      sprintf(log_buf, "curRealy_Val:%02X, dataQuery result:%02X %02X %02X %02X.\n",
              //                                                                       (int)status_Relay,
              //                                                                       (int)dats.dats[0],
              //                                                                       (int)dats.dats[1],
              //                                                                       (int)dats.dats[2],
              //                                                                       (int)dats.dats[3]);
              //                                      PrintString1_logOut(log_buf);
              //                              }                       
              //#endif                
                                      if(dats.dats[0] != colonyCtrlGet_statusLocalScene){ //³¡¾°×´Ì¬ÖµÂÖÑ¯¸üÐÂ
                                      
              #if(DEBUG_LOGOUT_EN == 1)
                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
                                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                                      sprintf(log_buf, "differ scene detect from poling.\n");
                                                      PrintString1_logOut(log_buf);
                                              }                       
              #endif  
                                              
                                              //ÉÏÒ»´Î³¡¾°¿ØÖÆÈôÃ»ÓÐÊÕµ½£¬Ôò½øÐÐ²¹³¥²Ù×÷
                                              colonyCtrlGet_statusLocalScene = dats.dats[0];
                                              
                                              if(colonyCtrlGet_statusLocalScene <= 0x07){ //3bitÒÔÄÚ²Ù×÷ÎªÓÐÐ§Öµ£¬±ãÓÚ³õÊ¼»¯²Ù×÷Å×ÆúÎÞÐ§Öµ
                                              
                                                      swCommand_fromUsr.actMethod = relay_OnOff;
                                                      swCommand_fromUsr.objRelay = colonyCtrlGet_statusLocalScene;
                                              }
                                      }
                                      
                                      if(memcmp(&dats.dats[1], colonyCtrlGet_statusLocalEaCtrl, clusterNum_usr)){ //»¥¿Ø×´Ì¬ÖµÖµÂÖÑ¯¸üÐÂ
                                              
                                              u8 idata loop;
                                              
              #if(DEBUG_LOGOUT_EN == 1)
                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
                                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                                      sprintf(log_buf, "differ eachCtrl detect from poling, currentVal is: %02X %02X %02X.\n", (int)colonyC
             -trlGet_statusLocalEaCtrl[0],
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 28  

                                                                                                                                                                                                                                       (int)colonyCtrlGet_statusLocalEaCtrl[1],
                                                                                                                                                                                                                                       (int)colonyCtrlGet_statusLocalEaCtrl[2]);
                                                      PrintString1_logOut(log_buf);
                                              }                       
              #endif
                                              //ÉÏÒ»´Î»¥¿ØÈôÃ»ÓÐÊÕµ½£¬Ôò½øÐÐ²¹³¥²Ù×÷
                                              memcpy(colonyCtrlGet_statusLocalEaCtrl, &dats.dats[1], clusterNum_usr);
                                              
                                              for(loop = 0; loop < clusterNum_usr; loop ++){ //ÑÚÂëÅÐ¶Ï²Ù×÷Î»£¬±ãÓÚ³õÊ¼»¯²Ù×÷Å×ÆúÎÞÐ§Öµ
                                              
                                                      if(colonyCtrlGet_statusLocalEaCtrl[loop] == STATUSLOCALEACTRL_VALMASKRESERVE_ON)statusRelay_temp |= (
             -1 << loop);
                                                      if(colonyCtrlGet_statusLocalEaCtrl[loop] == STATUSLOCALEACTRL_VALMASKRESERVE_OFF)statusRelay_temp &= 
             -~(1 << loop);
                                                      
                                                      swCommand_fromUsr.actMethod = relay_OnOff;
                                                      swCommand_fromUsr.objRelay = statusRelay_temp;
                                              }
                                      }
                                      
                              }break;
              #else /*ºêÅÐÖÐ*///¼¯Èº¿ØÖÆÐÅÏ¢ÖÜÆÚ²éÑ¯Ê¹ÄÜ
1622   2                      case ZIGB_SYSCMD_COLONYPARAM_REQPERIOD:{ /*ºêÊ§ÄÜ*///½ö½ÓÊÕ³¡¾°¿ØÖÆÐÅÏ¢²¢¶¯×÷
1623   3                      
1624   3                              u8 idata statusRelay_temp = status_Relay; //¿ª¹Ø¶¯×÷Ö´ÐÐ»º´æ
1625   3                              
1626   3                              if(dats.dats[0] != colonyCtrlGet_statusLocalScene){ //³¡¾°×´Ì¬ÖµÂÖÑ¯¸üÐÂ
1627   4                              
1628   4      #if(DEBUG_LOGOUT_EN == 1)
1629   4                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1630   5                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1631   5                                              sprintf(log_buf, "differ scene detect from poling.\n");
1632   5                                              PrintString1_logOut(log_buf);
1633   5                                      }                       
1634   4      #endif  
1635   4                                      
1636   4                                      //ÉÏÒ»´Î³¡¾°¿ØÖÆÈôÃ»ÓÐÊÕµ½£¬Ôò½øÐÐ²¹³¥²Ù×÷
1637   4                                      colonyCtrlGet_statusLocalScene = dats.dats[0];
1638   4                                      
1639   4                                      if(colonyCtrlGet_statusLocalScene <= 0x07){ //3bitÒÔÄÚ²Ù×÷ÎªÓÐÐ§Öµ£¬±ãÓÚ³õÊ¼»¯²Ù×÷Å×ÆúÎÞÐ§Öµ
1640   5                                      
1641   5                                              swCommand_fromUsr.actMethod = relay_OnOff;
1642   5                                              swCommand_fromUsr.objRelay = colonyCtrlGet_statusLocalScene;
1643   5                                      }
1644   4                              }
1645   3                              
1646   3                      }break;
1647   2      #endif /*ºêÅÐÎ²*///¼¯Èº¿ØÖÆÐÅÏ¢ÖÜÆÚ²éÑ¯Ê¹ÄÜ
1648   2                      default:break;
1649   2              }
1650   1      }
1651          
1652          /*zigbee³£¹æ¿ØÖÆ×ª·¢Êý¾Ý½âÎö*/
1653          static 
1654          void dataParing_Nomal(u8 datsParam[], u16 nwkAddr_from, u8 port_from){
1655   1              
1656   1      #define dataLen_dataParingNomal 96
1657   1              u8 xdata paramTX_temp[dataLen_dataParingNomal] = {0};
1658   1              
1659   1              bit dataFromRemote_IF = 0;      //ÊÇ·ñÎª·þÎñÆ÷¶ËÊý¾Ý±êÖ¾
1660   1      
1661   1              /*²úÆ·¶þ¼¶Ð­ÒéºË¶Ô_³£¹æ¿ØÖÆ*///¿ØÖÆÏÂ´ï
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 29  

1662   1              switch(datsParam[0]){
1663   2              
1664   2                      /*Ô¶¶Ë*/
1665   2                      case ZIGB_FRAMEHEAD_CTRLREMOTE:{
1666   3                              
1667   3                              dataFromRemote_IF = 1;
1668   3                              
1669   3                              memcpy(MAC_ID_DST, &datsParam[7], 6);
1670   3                              memcpy(&datsParam[1], &datsParam[13], datsRcv_ZIGB.rcvDats[20] - 13);
1671   3                      }
1672   2                      
1673   2                      /*±¾µØ*/
1674   2                      case ZIGB_FRAMEHEAD_CTRLLOCAL:{
1675   3                              
1676   3                              bit frameCheck_Done = 0; //Êý¾Ý¼ì²âºÏ¸ñ±êÖ¾
1677   3                              
1678   3                              {
1679   4                                      bit frameCodeCheck_PASS = 0; //Ð£ÑéÂë¼ì²éÍ¨¹ý±êÖ¾
1680   4                                      bit frameMacCheck_PASS  = 0; //macµØÖ·´ý¼ì²éÍ¨¹ý±êÖ¾
1681   4                                      
1682   4                                      if(datsParam[4] == frame_Check(&datsParam[5], 28))frameCodeCheck_PASS = 1; //Ð£ÑéÂë¼ì²â
1683   4                                      if(!memcmp(&datsParam[5], &MAC_ID[1], 5))frameMacCheck_PASS = 1; //MAC¼ì²â
1684   4      
1685   4                                      if(datsParam[3] == FRAME_MtoZIGBCMD_cmdConfigSearch){ //ÌØÊâÖ¸Áî²»×öMAC¼ì²â
1686   5                                      
1687   5                                              frameMacCheck_PASS = 1;
1688   5                                              
1689   5                                      }else
1690   4                                      if((datsParam[3] == FRAME_MtoZIGBCMD_cmdCfg_swTim) || //ÌØÊâÖ¸Áî²»×öÐ£ÑéÂë¼ì²â
1691   4                                         (datsParam[3] == FRAME_MtoZIGBCMD_cmdswTimQuery)){
1692   5                                         
1693   5                                              frameCodeCheck_PASS = 1;
1694   5                                      }
1695   4                                         
1696   4                                      if(frameCodeCheck_PASS && frameCodeCheck_PASS)frameCheck_Done = 1;
1697   4                              }
1698   3                                 
1699   3                              if(frameCheck_Done){ //Ö¡¼ì²éÍ¨¹ý£¬¿ªÊ¼½âÎö¡¢¶¯×÷¼°ÏìÓ¦
1700   4                                      
1701   4                                      bit respond_IF          = 0;    //ÊÇ·ñ»Ø¸´
1702   4                                      bit specialCmd_IF       = 0;    //ÊÇ·ñÎªÌØÊâÖ¸Áî£¨ÌØÊâÖ¸ÁîÕ¼ÓÃ¿ª¹ØÀàÐÍÄÇÒ»¸ö×Ö½Ú£©
1703   4                                      
1704   4      #if(DEBUG_LOGOUT_EN == 1)
1705   4                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1706   5                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1707   5                                              sprintf(log_buf, "cmdComing:%02X.\n", (int)datsParam[3]);
1708   5                                              PrintString1_logOut(log_buf);
1709   5                                      }                       
1710   4      #endif          
1711   4                                      memset(paramTX_temp, 0, sizeof(u8) * dataLen_dataParingNomal);
1712   4                              
1713   4                                      switch(datsParam[3]){
1714   5                                      
1715   5                                              case FRAME_MtoZIGBCMD_cmdConfigSearch:{
1716   6                                                      
1717   6                                                      if(!deviceLock_flag){ //Éè±¸ÊÇ·ñÉÏËø
1718   7                                                              
1719   7                                                              u16 xdata panid_Temp = ZigB_getPanIDCurrent(); //ÅäÖÃ»Ø¸´Ìí¼ÓPANID
1720   7                                                              
1721   7                                                              paramTX_temp[11] = status_Relay; //¿ª¹Ø×´Ì¬»Ø¸´Ìî×°
1722   7                                                              
1723   7                                                              paramTX_temp[14] = (u8)((panid_Temp & 0xFF00) >> 8); //ÍøÂçPANID»Ø¸´Ìî×°
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 30  

1724   7                                                              paramTX_temp[15] = (u8)((panid_Temp & 0x00FF) >> 0);
1725   7                                                              
1726   7                                                              sysTimeZone_H = datsParam[12];
1727   7                                                              sysTimeZone_M = datsParam[13];
1728   7                                                              coverEEPROM_write_n(EEPROM_ADDR_timeZone_H, &sysTimeZone_H, 1);
1729   7                                                              coverEEPROM_write_n(EEPROM_ADDR_timeZone_M, &sysTimeZone_M, 1);
1730   7                                                              
1731   7                                                              periodDataTrans_momentHang(10); //½ÓÊÕµ½ËÑË÷Âëºó ½«ÆäËûÖÜÆÚÖ÷¶¯·¢ÂëÍ¨ÐÅ½øÐÐ±ÜÈÃ ÎªËÑË÷ÏìÓ¦ÇåÂ· 10s
1732   7                                                      
1733   7                                                              respond_IF              = 1; //ÏìÓ¦»Ø¸´
1734   7                                                              specialCmd_IF   = 0;
1735   7                                                              
1736   7                                                      }else{
1737   7                                                      
1738   7                                                              
1739   7                                                      }
1740   6                                                      
1741   6                                              }break;
1742   5                                              
1743   5                                              case FRAME_MtoZIGBCMD_cmdControl:{
1744   6      
1745   6                                                      paramTX_temp[11] = 0;
1746   6                                                      paramTX_temp[11] |= (datsParam[11] & 0x07);     //×´Ì¬Î»Ìî×°
1747   6                                                      if(             (datsParam[11] & 0x01) != (status_Relay & 0x01))paramTX_temp[11] |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÒ»Î»
1748   6                                                      else if((datsParam[11] & 0x02) != (status_Relay & 0x02))paramTX_temp[11] |= 0x40; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ
             -»>µÚ¶þÎ»
1749   6                                                      else if((datsParam[11] & 0x04) != (status_Relay & 0x04))paramTX_temp[11] |= 0x80; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ
             -»>µÚÈýÎ»
1750   6                                                      
1751   6                                                      swCommand_fromUsr.objRelay = datsParam[11];
1752   6                                                      swCommand_fromUsr.actMethod = relay_OnOff;
1753   6      
1754   6                                                      respond_IF              = 1; //ÏìÓ¦»Ø¸´
1755   6                                                      specialCmd_IF   = 0;                                                    
1756   6                                                      
1757   6                                              }break;
1758   5                                                      
1759   5                                              case FRAME_MtoZIGBCMD_cmdQuery:{}break;
1760   5                                                      
1761   5                                              case FRAME_MtoZIGBCMD_cmdInterface:{}break;
1762   5                                                      
1763   5                                              case FRAME_MtoZIGBCMD_cmdReset:{}break;
1764   5                                                      
1765   5                                              case FRAME_MtoZIGBCMD_cmdDevLockON:{
1766   6                                              
1767   6                                                      //Êý¾Ý´¦Àí¼°¶¯×÷ÏìÓ¦
1768   6                                                      {
1769   7                                                              u8 deviceLock_IF = 1;
1770   7                                                              
1771   7                                                              deviceLock_flag  = 1;
1772   7                                                              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
1773   7                                                      }               
1774   6                                                      
1775   6                                              }break;
1776   5                                                      
1777   5                                              case FRAME_MtoZIGBCMD_cmdDevLockOFF:{
1778   6                                              
1779   6                                                      //Êý¾Ý´¦Àí¼°¶¯×÷ÏìÓ¦
1780   6                                                      {
1781   7                                                              u8 deviceLock_IF = 0;
1782   7                                                              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 31  

1783   7                                                              deviceLock_flag  = 0;
1784   7                                                              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
1785   7                                                      }       
1786   6                                              
1787   6                                              }break;
1788   5                                                      
1789   5                                              case FRAME_MtoZIGBCMD_cmdswTimQuery:{
1790   6                                              
1791   6                                                      //·ÖÀà»Ø¸´
1792   6                                                      switch(datsParam[13]){ //×ÓÃüÁî½âÎö
1793   7                                                      
1794   7                                                              case 0: /*ÉÏÎ»»úÔÚ¶¨Ê±µÄÊ±ºò¸ø0£¬´ýÐ­ÉÌ*/
1795   7                                                              case cmdConfigTim_normalSwConfig:{
1796   8                                                              
1797   8                                                                      u8 loop = 0;
1798   8                                                              
1799   8                                                                      //Êý¾ÝÏìÓ¦¼°»Ø¸´
1800   8                                                                      EEPROM_read_n(EEPROM_ADDR_swTimeTab, &paramTX_temp[14], 12);    //¶¨Ê±±í»Ø¸´Ìî×°
1801   8                                                                      
1802   8                                                                      //»Ø¸´Êý¾Ý¶þ´Î´¦Àí£¨Õë¶ÔÒ»´ÎÐÔ¶¨Ê±Êý¾Ý£©
1803   8                                                                      for(loop = 0; loop < 4; loop ++){
1804   9                                                                      
1805   9                                                                              if(swTim_onShoot_FLAG & (1 << loop)){
1806  10                                                                                      
1807  10                                                                                      paramTX_temp[14 + loop * 3] &= 0x80;
1808  10                                                                              }
1809   9                                                                      }
1810   8                                                                                      
1811   8                                                                      specialCmd_IF = 1; //ÌØÊâÕ¼Î»Ö¸Áî
1812   8                                                                      
1813   8      #if(DEBUG_LOGOUT_EN == 1)
1814   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1815   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1816   9                                                                              sprintf(log_buf, ">>>>>>>>timer_tab3 respond:[%02X-%02X-%02X].\n", (int)paramTX_temp[20], (int)pa
             -ramTX_temp[21], (int)paramTX_temp[22]);
1817   9                                                                              PrintString1_logOut(log_buf);
1818   9                                                                      }                       
1819   8      #endif  
1820   8                                                                      
1821   8                                                              }break;
1822   7                                                              
1823   7                                                              case cmdConfigTim_onoffDelaySwConfig:{
1824   8                                                              
1825   8                                                                      if(!delayCnt_onoff)paramTX_temp[14] = 0;
1826   8                                                                      else paramTX_temp[14] = delayPeriod_onoff - (u8)(delayCnt_onoff / 60);
1827   8                                                                      paramTX_temp[15] = delayUp_act;
1828   8                                                                      
1829   8                                                              }break;
1830   7                                                              
1831   7                                                              case cmdConfigTim_closeLoopSwConfig:{
1832   8                                                              
1833   8                                                                      paramTX_temp[14] = delayPeriod_closeLoop;
1834   8                                                                      
1835   8                                                              }break;
1836   7                                                              
1837   7                                                              case cmdConfigTim_nightModeSwConfig:{  
1838   8                                                              
1839   8                                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &paramTX_temp[14], 6);      //Ò¹¼äÄ£Ê½¶¨Ê±±í»Ø¸´Ìî×°
1840   8                                                                      
1841   8                                                                      (deviceLock_flag)?(paramTX_temp[12] |= 0x01):(paramTX_temp[12] &= ~0x01);
1842   8                                                                      (ifNightMode_sw_running_FLAG)?(paramTX_temp[12] |= 0x02):(paramTX_temp[12] &= ~0x02);
1843   8                                                                      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 32  

1844   8                                                              }break;
1845   7                                                              
1846   7                                                              default:break;
1847   7                                                      }
1848   6                                                      
1849   6                                                      paramTX_temp[13] = datsParam[13]; //¶¨Ê±×ÓÃüÁîÍ¬²½»Ø¸´
1850   6                                                      
1851   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1852   6                                                      
1853   6                                              }break;
1854   5                                                      
1855   5                                              case FRAME_MtoZIGBCMD_cmdConfigAP:{}break;
1856   5                                                      
1857   5                                              case FRAME_MtoZIGBCMD_cmdBeepsON:{ //Ò¹¼äÄ£Ê½¹Ø
1858   6                                              
1859   6                                                      u8 datsTemp = 0;
1860   6                                                      
1861   6                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
1862   6                                                      datsTemp &= ~0x7f; //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢,È¡ÏûÍ·×Ö½ÚÈ«Õ¼Âú,Ê§ÄÜÈ«Ìì
1863   6                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
1864   6                                                      
1865   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1866   6                                                      
1867   6                                              }break;
1868   5                                                      
1869   5                                              case FRAME_MtoZIGBCMD_cmdBeepsOFF:{ //Ò¹¼äÄ£Ê½¿ª
1870   6                                              
1871   6                                                      u8 datsTemp = 0;
1872   6                                                      
1873   6                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
1874   6                                                      datsTemp |= 0x7f; //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢,Í·×Ö½ÚÈ«Õ¼Âú,Ç¿ÖÆÈ«Ìì
1875   6                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);        
1876   6                                                      
1877   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1878   6                                                      
1879   6                                              }break;
1880   5                                                      
1881   5                                              case FRAME_MtoZIGBCMD_cmdftRecoverRQ:{
1882   6                                              
1883   6                                                      respond_IF = 1;
1884   6                                                      
1885   6                                              }break;
1886   5                                                      
1887   5                                              case FRAME_MtoZIGBCMD_cmdRecoverFactory:{
1888   6                                              
1889   6                                                      Factory_recover();
1890   6                                              
1891   6                                              }break;
1892   5                                                      
1893   5                                              case FRAME_MtoZIGBCMD_cmdCfg_swTim:{
1894   6                                                      
1895   6                                                      u8 loop = 0;
1896   6                                                      
1897   6                                                      switch(datsParam[13]){ //¶¨Ê±Êý¾Ý´¦Àí¼°¸üÐÂ,·ÖÀà´¦Àí
1898   7                                                      
1899   7                                                              case cmdConfigTim_normalSwConfig:{      /*ÆÕÍ¨¶¨Ê±*/
1900   8                                                                      
1901   8                                                                      for(loop = 0; loop < 4; loop ++){
1902   9                                                                      
1903   9                                                                              if(datsParam[14 + loop * 3] == 0x80){   /*Ò»´ÎÐÔ¶¨Ê±ÅÐ¶Ï*///ÖÜÕ¼Î»Îª¿Õ£¬¶ø¶¨Ê±Æ÷±»´ò¿ª£¬ËµÃ÷ÊÇÒ»´ÎÐ
             -Ô
1904  10                                                                              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 33  

1905  10                                                                                      swTim_onShoot_FLAG      |= (1 << loop); //Ò»´ÎÐÔ¶¨Ê±±êÖ¾¿ªÆô
1906  10                                                                                      datsParam[14 + loop * 3] |= (1 << (systemTime_current.time_Week - 1)); //Ç¿ÐÐ½øÐÐµ±Ç°ÖÜÕ¼Î»£¬µ±´
             -ÎÖ´ÐÐÍê±ÏºóÇå³ý
1907  10                                                                              }
1908   9                                                                      }
1909   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_swTimeTab, &datsParam[14], 4 * 3);      //¶¨Ê±±í
1910   8                                                                      
1911   8      #if(DEBUG_LOGOUT_EN == 1)
1912   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1913   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
1914   9                                                                              sprintf(log_buf, ">>>>>>>>timer_tab3 has been set:[%02X-%02X-%02X].\n", (int)datsParam[20], (int)
             -datsParam[21], (int)datsParam[22]);
1915   9                                                                              PrintString1_logOut(log_buf);
1916   9                                                                      }                       
1917   8      #endif  
1918   8                                                              
1919   8                                                              }break;
1920   7                                                              
1921   7                                                              case cmdConfigTim_onoffDelaySwConfig:{  /*¿ª¹ØÑÓÊ±*/
1922   8                                                              
1923   8                                                                      if(datsParam[14]){
1924   9                                                                      
1925   9                                                                              ifDelay_sw_running_FLAG |= (1 << 1);
1926   9                                                                              delayPeriod_onoff               = datsParam[14];
1927   9                                                                              
1928   9                                                                              delayUp_act                             = datsParam[15];
1929   9                                                                              
1930   9                                                                              delayCnt_onoff                  = 0;
1931   9                                                                              
1932   9                                                                      }else{
1933   9                                                                      
1934   9                                                                              ifDelay_sw_running_FLAG &= ~(1 << 1);
1935   9                                                                              delayPeriod_onoff               = 0;
1936   9                                                                              delayCnt_onoff                  = 0;
1937   9                                                                      }
1938   8                                                                      
1939   8                                                              }break;
1940   7                                                              
1941   7                                                              case cmdConfigTim_closeLoopSwConfig:{   /*ÂÌÉ«¹¦ÄÜ(×Ô¶¯Ñ­»·¹Ø±Õ)*/
1942   8                                                              
1943   8                                                                      if(datsParam[14]){
1944   9                                                                      
1945   9                                                                              ifDelay_sw_running_FLAG |= (1 << 0);
1946   9                                                                              delayPeriod_closeLoop   = datsParam[14];
1947   9                                                                              delayCnt_closeLoop              = 0;
1948   9                                                                              
1949   9                                                                      }else{
1950   9                                                                      
1951   9                                                                              ifDelay_sw_running_FLAG &= ~(1 << 0);
1952   9                                                                              delayPeriod_closeLoop   = 0;
1953   9                                                                              delayCnt_closeLoop              = 0;
1954   9                                                                      }
1955   8                                                                      
1956   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_swDelayFLAG, &ifDelay_sw_running_FLAG, 1);
1957   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_periodCloseLoop, &delayPeriod_closeLoop, 1);
1958   8                                                                      
1959   8                                                              }break;         
1960   7      
1961   7                                                              case cmdConfigTim_nightModeSwConfig:{  /*Ò¹¼äÄ£Ê½ ±³¹â°ëÁÁ*/
1962   8                                                              
1963   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsParam[14], 6);   //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢
1964   8                                                                      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 34  

1965   8                                                              }break;
1966   7                                                              
1967   7                                                              default:break;
1968   7                                                      }
1969   6                                                      
1970   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1971   6                                                      
1972   6                                              }break;
1973   5                                              
1974   5                                              case FRAME_MtoZIGBCMD_cmdCfg_ctrlEachO:{
1975   6                                              
1976   6                                                      u8 loop = 0;
1977   6                                                      u8 effective_oprate = datsParam[12]; //ÓÐÐ§²Ù×÷Êý¾ÝÕ¼Î»»ñÈ¡
1978   6                                                      
1979   6                                                      for(loop = 0; loop < clusterNum_usr; loop ++){
1980   7                                                      
1981   7                                                              if((effective_oprate >> loop) & 0x01){ //ÓÐÐ§Êý¾ÝÅÐ¶Ï
1982   8                                                              
1983   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_portCtrlEachOther + loop, &datsParam[14 + loop], 1);
1984   8                                                                      CTRLEATHER_PORT[loop] = datsParam[14 + loop];
1985   8                                                                      reConnectAfterDatsReq_IF = 1; //¼´¿Ì×¢²á»¥¿ØÍ¨Ñ¶´Ø¶Ë¿Ú
1986   8                                                              }
1987   7                                                      }
1988   6                                                      
1989   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1990   6                                              
1991   6                                              }break;
1992   5                                              
1993   5                                              case FRAME_MtoZIGBCMD_cmdQue_ctrlEachO:{
1994   6                                              
1995   6                                                      u8 loop = 0;
1996   6                                                      
1997   6                                                      for(loop = 0; loop < clusterNum_usr; loop ++){
1998   7                                                      
1999   7                                                              EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther + loop, &paramTX_temp[14 + loop], 1);
2000   7                                                      }
2001   6                                                      
2002   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
2003   6                                              
2004   6                                              }break;
2005   5                                                      
2006   5                                              case FRAME_MtoZIGBCMD_cmdCfg_ledBackSet:{
2007   6                                              
2008   6                                                      coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround, &datsParam[14], 1);
2009   6                                                      coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround + 1, &datsParam[15], 1);
2010   6                                                      tipsInsert_swLedBKG_ON  = datsParam[14];
2011   6                                                      tipsInsert_swLedBKG_OFF = datsParam[15];
2012   6                                                      
2013   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
2014   6                                              
2015   6                                              }break;
2016   5                                              
2017   5                                              case FRAME_MtoZIGBCMD_cmdQue_ledBackSet:{
2018   6                                              
2019   6                                                      EEPROM_read_n(EEPROM_ADDR_ledSWBackGround, &paramTX_temp[14], 1);
2020   6                                                      EEPROM_read_n(EEPROM_ADDR_ledSWBackGround + 1, &paramTX_temp[15], 1);
2021   6                                                      
2022   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
2023   6                                              
2024   6                                              }break;
2025   5                                              
2026   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioSet:{
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 35  

2027   5      //                                              
2028   5      //                                              u16 xdata panid_Temp = ZigB_getPanIDCurrent(); //ÅäÖÃ»Ø¸´Ìí¼ÓPANID
2029   5      //                                      
2030   5      //                                              bit opt_result = swScenario_oprateSave(datsParam[12], datsParam[14]);
2031   5      //                                              if(opt_result)paramTX_temp[12] = 0;
2032   5      //                                              else paramTX_temp[12] = 0x0A; //³¡¾°ÉèÖÃÎÞÐ§»Ø¸´£¨³¡¾°´æ´¢ÒÑÂú£©
2033   5      //                                              
2034   5      //                                              paramTX_temp[14] = (u8)((panid_Temp & 0xFF00) >> 8);
2035   5      //                                              paramTX_temp[15] = (u8)((panid_Temp & 0x00FF) >> 0);
2036   5      //                                              
2037   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ£¨±¾µØ´æ´¢ÒÑ±»Õ¼Âú£©
2038   5      //                                      
2039   5      //                                      }break;
2040   5      //                                      
2041   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioCtl:{
2042   5      //                                              
2043   5      //                                              u8 sw_Act = swScenario_oprateCheck(datsParam[12]);
2044   5      //                                              if(sw_Act != SW_SCENCRAIO_ACTINVALID){ //ÈôË÷Òýµ½ÓÐÐ§²Ù×÷Î»
2045   5      //                                                      
2046   5      //                                                      swCommand_fromUsr.actMethod = relay_OnOff;
2047   5      //                                                      swCommand_fromUsr.objRelay = sw_Act;
2048   5      //                                              
2049   5      //                                                      paramTX_temp[12] = 0;
2050   5      //                                                      
2051   5      //                                              }else{ //ÈôÎÞ·¨Ë÷Òýµ½ÓÐÐ§²Ù×÷Î»
2052   5      //                                              
2053   5      //                                                      paramTX_temp[12] = 0x0A; //³¡¾°¿ØÖÆÎÞÐ§»Ø¸´£¨³¡¾°ºÅÎÞ·¨±»Ë÷Òý£©
2054   5      //                                              }
2055   5      //                                      
2056   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
2057   5      //                                      
2058   5      //                                      }break;
2059   5      //                                      
2060   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioDel:{
2061   5      //                                              
2062   5      //                                              swScenario_oprateDele(datsParam[12]);
2063   5      //                                              paramTX_temp[12] = 0;
2064   5      //                                      
2065   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
2066   5      //                                      
2067   5      //                                      }break;
2068   5                                              
2069   5                                              default:{
2070   6                                              
2071   6                                                      respond_IF = 0;
2072   6                                              
2073   6                                              }break;
2074   5                                      }
2075   4                                      
2076   4                                      /*»Ø¸´ÏìÓ¦*/
2077   4                                      if(respond_IF){ //Êý¾Ý°ü»Ø¸´ÏìÓ¦¶¯×÷
2078   5                                      
2079   5                                              u8 datsTX_Len = 0;
2080   5                                              
2081   5                                              respond_IF = 0;
2082   5                                              
2083   5                                              datsTX_Len = dtasTX_loadBasic_CUST(dataFromRemote_IF,
2084   5                                                                                                                 paramTX_temp,
2085   5                                                                                                                 33,
2086   5                                                                                                                 FRAME_TYPE_StoM_RCVsuccess,
2087   5                                                                                                                 datsParam[3],
2088   5                                                                                                                 specialCmd_IF);
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 36  

2089   5                                              
2090   5                                              heartBeatCount += 1; //ÑÓÊ±ÐÔÐ­µ÷ÐÄÌøÖÍºó 1s
2091   5                                              
2092   5                                              datsSend_request.nwkAddr = nwkAddr_from;
2093   5                                              datsSend_request.portPoint = port_from;
2094   5                                              memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
2095   5                                              memcpy(datsSend_request.datsTrans.dats, paramTX_temp, datsTX_Len);
2096   5                                              datsSend_request.datsTrans.datsLen = datsTX_Len;
2097   5                                              datsRcv_respond.datsTrans.datsLen = 0;
2098   5                                              devRemoteDataReqMethod.keepTxUntilCmp_IF = 1; //ËÀ¿Ä
2099   5                                              devRemoteDataReqMethod.datsTxKeep_Period = REMOTE_DATAREQ_TIMEOUT / 8; //ËÀ¿ÄÖÜÆÚ£¬³ý´Î±È µ¥¸ö³¬Ê±ÖÜÆ
             -ÚÄÚ ·¢ 8 ´Î
2100   5                                              devRunning_Status = status_dataTransRequestDatsSend;
2101   5                                              
2102   5      //#if(DEBUG_LOGOUT_EN == 1)
2103   5      //                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2104   5      //                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2105   5      //                                              sprintf(log_buf, ">>>>>>>>standby dataTX_buf_tab3:[%02X-%02X-%02X].\n", (int)datsSend_request.dats
             -Trans.dats[20], (int)datsSend_request.datsTrans.dats[21], (int)datsSend_request.datsTrans.dats[22]);
2106   5      //                                              PrintString1_logOut(log_buf);
2107   5      //                                      }                       
2108   5      //#endif        
2109   5                                      }
2110   4                              }
2111   3                      }break;
2112   2                      
2113   2                      /*ÐÄÌø_Íø¹ØÔÚÏß*/
2114   2                      case ZIGB_FRAMEHEAD_HEARTBEAT:{
2115   3                      
2116   3                              
2117   3                              
2118   3                      }break;
2119   2                      
2120   2                      /*ÐÄÌø_Íø¹ØÀëÏß*///internetÀëÏß£¬²»ÊÇzigbÍøÂçÀëÏß
2121   2                      case ZIGB_FRAMEHEAD_HBOFFLINE:{
2122   3                      
2123   3                              
2124   3                              
2125   3                      }break;
2126   2                      
2127   2      #if(ZIGB_DATATRANS_WORKMODE == DATATRANS_WORKMODE_KEEPACESS) /*ºêÅÐÍ·*///¶¨Ê±ÀàÍ¨Ñ¶Ä£Ê½ÅÐ¶Ï
2128   2                      /*¶¨Ê±Ñ¯·Ã_Íø¹ØÔÚÏß*/
2129   2                      case DTMODEKEEPACESS_FRAMEHEAD_ONLINE:{
2130   3                      
2131   3                              stt_agingDataSet_bitHold code   agingCmd_Temp = {0};
2132   3                              stt_devOpreatDataPonit xdata    dev_dataPointTemp = {0};
2133   3                              
2134   3                              bit frameCodeCheck_PASS = 0; //Ð£ÑéÂë¼ì²éÍ¨¹ý±êÖ¾
2135   3                              bit frameMacCheck_PASS  = 0; //macµØÖ·´ý¼ì²éÍ¨¹ý±êÖ¾
2136   3                              
2137   3      //#if(DEBUG_LOGOUT_EN == 1)
2138   3      //                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2139   3      //                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2140   3      //                              sprintf(log_buf, "periodKeepAcess respondRcv, cmd[%02X], dataLen[%02d].\n", (int)datsParam[8], (int)
             -datsParam[1]);
2141   3      //                              PrintString1_logOut(log_buf);
2142   3      //                      }                       
2143   3      //#endif        
2144   3                              
2145   3                              if(datsParam[datsParam[1] - 1] == frame_Check(&datsParam[1], datsParam[1] - 2))frameCodeCheck_PASS = 1;
2146   3                              if(!memcmp(&datsParam[2], &MAC_ID[1], 5))frameMacCheck_PASS = 1;
2147   3                              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 37  

2148   3                              if(frameCodeCheck_PASS && frameMacCheck_PASS){ 
2149   4                      
2150   4                                      memcpy(&dev_dataPointTemp, &datsParam[15], sizeof(stt_devOpreatDataPonit)); //Êý¾Ý½á¹¹»¯
2151   4                                      
2152   4      //#if(DEBUG_LOGOUT_EN == 1)
2153   4      //                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2154   4      //                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2155   4      //                                      sprintf(log_buf, "agingCmd[%02X], swAging[%d], val[%02X].\n", (int)datsParam[8],
2156   4      //                                                                                                                                                                (int)dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_swOpreat, 
2157   4      //                                                                                                                                                                (int)dev_dataPointTemp.devStatus_Reference.statusRef_swStatus);
2158   4      //                                      PrintString1_logOut(log_buf);
2159   4      //                              }                       
2160   4      //#endif        
2161   4                              
2162   4                                      switch(datsParam[8]){ //Ö¡ÃüÁî
2163   5                                      
2164   5                                              case DTMODEKEEPACESS_FRAMECMD_ASR:{
2165   6                                                      
2166   6                                                      static bit local_ftyRecover_standbyFLG = 0; //»Ö¸´³ö³§ÉèÖÃ²Ù×÷Ô¤¶¯×÷±êÖ¾
2167   6                                      
2168   6                                                      /*·ÇÊ±Ð§ÐÔÃüÁîÅÐ¶Ï*///Êý¾Ý²»Ò»ÖÂÊ±£¬¸üÐÂ»º´æºóÖ´ÐÐ¶¯×÷¼´¿É£¨·ÇÊ±Ð§ÔòÃ¿´Î»ñÈ¡Êý¾ÝÊ±¶¼ÒªÓë±¾µØÊý¾Ý×÷±È
             -½Ï£©
2169   6      //                                              { //ÆÕÍ¨¿ª¹Ø²Ù×÷£¬ÎÞÐèÊ±Ð§
2170   6      //                                              
2171   6      //                                                      if((status_Relay & 0x07) != dev_dataPointTemp.devStatus_Reference.statusRef_swStatus){ 
2172   6      //                                                      
2173   6      //                                                              swCommand_fromUsr.objRelay = dev_dataPointTemp.devStatus_Reference.statusRef_swStatus;
2174   6      //                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2175   6      //                                                              
2176   6      //#if(DEBUG_LOGOUT_EN == 1)
2177   6      //                                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2178   6      //                                                                      
2179   6      //                                                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2180   6      //                                                                      sprintf(log_buf, ">>>>>>>>relayStatus reales:%02X, currentVal:%02X.\n", (int)status_Relay & 0x0
             -7, (int)dev_dataPointTemp.devStatus_Reference.statusRef_swStatus);
2181   6      //                                                                      PrintString1_logOut(log_buf);
2182   6      //                                                              }                       
2183   6      //#endif        
2184   6      //                                                      }
2185   6      //                                              }
2186   6                                                      
2187   6      //                                              { //¿ª¹Ø¶¨Ê±²Ù×÷£¬ÎÞÐèÊ±Ð§
2188   6      //                                              
2189   6      //                                                      timing_Dats xdata timDatsTemp_CalibrateTab[TIMEER_TABLENGTH] = {0};
2190   6      //                                                      
2191   6      //                                                      datsTiming_read_eeprom(timDatsTemp_CalibrateTab);
2192   6      //                                                      if(memcmp(timDatsTemp_CalibrateTab, dev_dataPointTemp.devData_timer, sizeof(timing_Dats) * TIMEER
             -_TABLENGTH)){ //Êý¾Ý²»Ò»ÖÂÔò¸üÐÂeeprom
2193   6      //                                                      
2194   6      //                                                              coverEEPROM_write_n(EEPROM_ADDR_swTimeTab, dev_dataPointTemp.devData_timer, sizeof(timing_Dats) 
             -* TIMEER_TABLENGTH);
2195   6      //                                                      }
2196   6      //                                              }
2197   6                                                      
2198   6      //                                              { //ÂÌÉ«Ä£Ê½²Ù×÷£¬ÎÞÐèÊ±Ð§
2199   6      //                                              
2200   6      //                                                      if(delayPeriod_closeLoop != dev_dataPointTemp.devData_greenMode){
2201   6      //                                                      
2202   6      //                                                              
2203   6      //                                                      }
2204   6      //                                              }
2205   6                                                      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 38  

2206   6      //                                              { //Ò¹¼äÄ£Ê½²Ù×÷£¬ÎÞÐèÊ±Ð§
2207   6      //                                                      
2208   6      //                                                      timing_Dats xdata nightDatsTemp_CalibrateTab[2];
2209   6      //                                                      
2210   6      //                                                      datsTimNight_read_eeprom(nightDatsTemp_CalibrateTab);
2211   6      //                                                      if(memcmp(nightDatsTemp_CalibrateTab, dev_dataPointTemp.devData_nightMode, sizeof(timing_Dats) * 
             -2)){ //Êý¾Ý²»Ò»ÖÂÔò¸üÐÂeeprom
2212   6      //                                                      
2213   6      //                                                              coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, dev_dataPointTemp.devData_nightMode, sizeof(ti
             -ming_Dats) * 2);
2214   6      //                                                      }       
2215   6      //                                              }
2216   6                                                      
2217   6      //                                              { //±³¹âµÆÉèÖÃ²Ù×÷£¬ÎÞÐèÊ±Ð§
2218   6      //                                              
2219   6      //                                                      if(tipsInsert_swLedBKG_ON != dev_dataPointTemp.devData_bkLight[0]){ //¿ªÉ«
2220   6      //                                                      
2221   6      //                                                              
2222   6      //                                                      }
2223   6      //                                                      
2224   6      //                                                      if(tipsInsert_swLedBKG_OFF != dev_dataPointTemp.devData_bkLight[1]){ //¹ØÉ«
2225   6      //                                                      
2226   6      //                                                              
2227   6      //                                                      }
2228   6      //                                              }
2229   6                                                      
2230   6                                                      /*Ê±Ð§ÐÔÃüÁîÅÐ¶Ï*///¸üÐÂÊ±Ð§²Ù×÷ºó£¬Çå¿ÕÊ±Ð§²Ù×÷Î»£¨Ê±Ð§ÊÇÎªÁË½ÚÔ¼ÐÔÄÜ²»ÓÃÃ¿´Î²éÑ¯Ê±¶¼×÷±È½Ï£©
2231   6                                                      if(memcmp(&agingCmd_Temp, &dev_dataPointTemp.devAgingOpreat_agingReference, sizeof(stt_agingDataSet_
             -bitHold))){ //Ò»µ©ÓÐÊ±Ð§Ö¸ÁîÎ»ÖÃ 1 £¬Ö»ÒªÓÐÊ±Ð§Õ¼Î»£¬¾ÍÔ­Î»»Ø·¢
2232   7                                                              
2233   7                                                              heartBeatCount = PERIOD_HEARTBEAT_ASR; //ÓÐÊ±Ð§¿ØÖÆ£¬Ç¿ÐÐÌáÇ°ÐÄÌøÁ¢¼´»ØÂë
2234   7                                                              
2235   7                                                              memcpy(&dev_agingCmd_rcvPassive, &dev_dataPointTemp.devAgingOpreat_agingReference, sizeof(stt_aging
             -DataSet_bitHold)); //±¾µØ±»¶¯Ê±Ð§²Ù×÷»º´æÍ¬²½¸üÐÂ£¬ÓÃÓÚÔ­Î»»Ø·¢
2236   7                                                      
2237   7                                                              /*Ê±Ð§²Ù×÷½âÎö*/                
2238   7      
2239   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_swOpreat){ //¿ª¹Ø×´Ì¬²Ù×÷£¬ÐèÒªÊ±Ð§
2240   8                                                                      
2241   8                                                                      if((status_Relay & 0x07) != dev_dataPointTemp.devStatus_Reference.statusRef_swStatus){ 
2242   9                                                                      
2243   9                                                                              swCommand_fromUsr.objRelay = dev_dataPointTemp.devStatus_Reference.statusRef_swStatus;
2244   9                                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2245   9      #if(DEBUG_LOGOUT_EN == 1)
2246   9                                                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2247  10                                                                                      
2248  10                                                                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2249  10                                                                                      sprintf(log_buf, ">>>>>>>>relayStatus reales:%02X, currentVal:%02X.\n", (int)status_Relay & 0x07
             -, (int)dev_dataPointTemp.devStatus_Reference.statusRef_swStatus);
2250  10                                                                                      PrintString1_logOut(log_buf);
2251  10                                                                              }                       
2252   9      #endif  
2253   9                                                                      }
2254   8                                                              }
2255   7                                                              
2256   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_delaySetOpreat){ //ÑÓÊ±ÉèÖÃ²Ù×÷£¬ÐèÒªÊ±
             -Ð§
2257   8                              
2258   8                                                                      if(dev_dataPointTemp.devData_delayer){ //ÑÓÊ±Ê±¼ä´óÓÚ0¾ÍÊÇ¿ª
2259   9                                                                      
2260   9                                                                              ifDelay_sw_running_FLAG |= (1 << 1); //ÑÓÊ±±êÖ¾¸üÐÂ£¬Æô¶¯
2261   9                                                                              delayPeriod_onoff               = dev_dataPointTemp.devData_delayer; //ÑÓÊ±Ê±¼ä
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 39  

2262   9                                                                              delayUp_act                             = dev_dataPointTemp.devData_delayUpStatus; //ÑÓÊ±µ½´ïÊ±£¬¿ª¹ØÏìÓ¦×´Ì¬
2263   9                                                                              delayCnt_onoff                  = 0; //ÑÓÊ±¼ÆÊýÇåÁã
2264   9      #if(DEBUG_LOGOUT_EN == 1)
2265   9                                                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2266  10                                                                                      
2267  10                                                                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2268  10                                                                                      sprintf(log_buf, ">>>>>>>>delayPeriod:[%d], delayUpAct:[%02X].\n", (int)delayPeriod_onoff, (int)
             -delayUp_act);
2269  10                                                                                      PrintString1_logOut(log_buf);
2270  10                                                                              }                       
2271   9      #endif  
2272   9                                                                              
2273   9                                                                      }else{
2274   9                                                                      
2275   9                                                                              ifDelay_sw_running_FLAG &= ~(1 << 0); //ÑÓÊ±±êÖ¾¸üÐÂ
2276   9                                                                              delayPeriod_onoff               = 0; 
2277   9                                                                              delayCnt_onoff                  = 0; 
2278   9                                                                      }
2279   8                                                              }
2280   7                                                              
2281   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_devResetOpreat){ //³ö³§ÉèÖÃ¸´Î»¶¯×÷£¬Ðè
             -ÒªÊ±Ð§
2282   8                                                                      
2283   8                                                                      local_ftyRecover_standbyFLG = 1; //½ÓÊÕµ½»Ö¸´³ö³§¶¯×÷ºó£¬½«»Ö¸´³ö³§ÉèÖÃ¶¯×÷½øÐÐ¾ÍÐ÷Ì¬¼ÇÂ¼£¬µÈ´ýÊ±Ð
             -§±êÖ¾ÖÃÁãºóÔÙ½øÐÐÊµ¼Ê¶¯×÷                                     
2284   8      #if(DEBUG_LOGOUT_EN == 1)
2285   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2286   9                                                      
2287   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2288   9                                                                              sprintf(log_buf, ">>>>>>>>factory recover standBy!.\n");
2289   9                                                                              PrintString1_logOut(log_buf);
2290   9                                                                      }                       
2291   8      #endif          
2292   8                                                              }
2293   7                                                              
2294   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_devLock){ //Éè±¸ËøÉèÖÃ²Ù×÷£¬ÐèÒªÊ±Ð§
2295   8                                                              
2296   8                                                                      u8 deviceLock_IF = 0; //²Ù×÷×Ö½Ú»º´æ
2297   8                                                                      
2298   8      #if(DEBUG_LOGOUT_EN == 1)
2299   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2300   9                                                                              
2301   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2302   9                                                                              sprintf(log_buf, ">>>>>>>>agingCmd devLock coming, lockIf:[%d].\n", (int)dev_dataPointTemp.devSta
             -tus_Reference.statusRef_devLock);
2303   9                                                                              PrintString1_logOut(log_buf);
2304   9                                                                      }                       
2305   8      #endif  
2306   8                                                                      
2307   8                                                                      if(dev_dataPointTemp.devStatus_Reference.statusRef_devLock){ //Êý¾Ý·ÅÔÚ×´Ì¬Àï
2308   9                                                                      
2309   9                                                                              deviceLock_flag = deviceLock_IF = 1; //ÔËÐÐ»º´æ¸üÐÂ
2310   9                                                                              
2311   9                                                                      }else{
2312   9                                                                      
2313   9                                                                              deviceLock_flag = deviceLock_IF = 0; //ÔËÐÐ»º´æ¸üÐÂ
2314   9                                                                      }
2315   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1); //Ö±½Ó¸üÐÂeepromÊý¾Ý
2316   8                                                              }
2317   7                                                              
2318   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_timerSetOpreat){ //¶¨Ê±Æ÷ÉèÖÃ²Ù×÷£¬ÐèÒª
             -Ê±Ð§
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 40  

2319   8                                                                      
2320   8                                                                      u8 loop = 0;
2321   8      #if(DEBUG_LOGOUT_EN == 1)
2322   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2323   9                                                                              
2324   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2325   9                                                                              sprintf(log_buf, ">>>>>>>>agingCmd timer coming, dataTab3:[%02X-%02X-%02X].\n", (int)dev_dataPoin
             -tTemp.devData_timer[6],
2326   9                                                                                                                                                                                                                                              (int)dev_dataPointTemp.devData_timer[7],
2327   9                                                                                                                                                                                                                                              (int)dev_dataPointTemp.devData_timer[8]);
2328   9                                                                              PrintString1_logOut(log_buf);
2329   9                                                                      }                       
2330   8      #endif  
2331   8                                                                      for(loop = 0; loop < TIMEER_TABLENGTH; loop ++){ //ÔËÐÐ»º´æ¸üÐÂ
2332   9                                                                      
2333   9                                                                              if(dev_dataPointTemp.devData_timer[loop * 3] == 0x80){  /*Ò»´ÎÐÔ¶¨Ê±ÅÐ¶Ï*///ÖÜÕ¼Î»Îª¿Õ£¬¶ø¶¨Ê±Æ÷±»
             -´ò¿ª£¬ËµÃ÷ÊÇÒ»´ÎÐÔ
2334  10                                                                              
2335  10                                                                                      swTim_onShoot_FLAG      |= (1 << loop); //Ò»´ÎÐÔ¶¨Ê±±êÖ¾¿ªÆô
2336  10                                                                                      dev_dataPointTemp.devData_timer[loop * 3] |= (1 << (systemTime_current.time_Week - 1)); //Ç¿ÐÐ½ø
             -ÐÐµ±Ç°ÖÜÕ¼Î»£¬µ±´ÎÖ´ÐÐÍê±ÏºóÇå³ý
2337  10                                                                              }
2338   9                                                                      }
2339   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_swTimeTab, dev_dataPointTemp.devData_timer, sizeof(timing_Dats) * 
             -TIMEER_TABLENGTH); //Ö±½Ó¸üÐÂeepromÊý¾Ý
2340   8                                                              }
2341   7                                                              
2342   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_greenModeSetOpreat){ //ÂÌÉ«Ä£Ê½ÉèÖÃ²Ù×÷
             -£¬ÐèÒªÊ±Ð§
2343   8                                                                      
2344   8      #if(DEBUG_LOGOUT_EN == 1)
2345   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2346   9                                                                              
2347   9                                                                              
2348   9                                                                              sprintf(log_buf, ">>>>>>>>agingCmd greenMode coming, timeSet:%d.\n", (int)dev_dataPointTemp.devDa
             -ta_greenMode);
2349   9                                                                              PrintString1_logOut(log_buf);
2350   9                                                                      }                       
2351   8      #endif  
2352   8                                                              
2353   8                                                                      (dev_dataPointTemp.devData_greenMode)?(ifDelay_sw_running_FLAG |= (1 << 0)):(ifDelay_sw_running_FL
             -AG &= ~(1 << 0)); //¸üÐÂÔËÐÐ»º´æ
2354   8                                                                      delayPeriod_closeLoop = dev_dataPointTemp.devData_greenMode;
2355   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_swDelayFLAG, &ifDelay_sw_running_FLAG, 1); //Ö±½Ó¸üÐÂeepromÊý¾Ý
2356   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_periodCloseLoop, &delayPeriod_closeLoop, 1);
2357   8                                                              }
2358   7                                                              
2359   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_nightModeSetOpreat){ //Ò¹¼äÄ£Ê½ÉèÖÃ²Ù×÷
             -£¬ÐèÒªÊ±Ð§
2360   8                                                                      
2361   8                                                                      u8 dataTemp[6] = {0};
2362   8      #if(DEBUG_LOGOUT_EN == 1)
2363   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2364   9                                                                              
2365   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2366   9                                                                              sprintf(log_buf, ">>>>>>>>agingCmd nightMode coming.\n");
2367   9                                                                              PrintString1_logOut(log_buf);
2368   9                                                                      }                       
2369   8      #endif  
2370   8                                                                      (dev_dataPointTemp.devData_nightMode[0])?(dataTemp[0] |= 0x7f):(dataTemp[0] &= ~0x7f);
2371   8                                                                      (dev_dataPointTemp.devData_nightMode[1])?(dataTemp[0] |= 0x80):(dataTemp[0] &= ~0x80);
2372   8                                                                      dataTemp[1] = dev_dataPointTemp.devData_nightMode[2] << 3; //×Ö½ÚÏÂ±ê2 ¸ß5Î» Ê±
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 41  

2373   8                                                                      dataTemp[2] = dev_dataPointTemp.devData_nightMode[3];      //×Ö½ÚÏÂ±ê3 È«8Î» ·Ö
2374   8                                                                      dataTemp[4] = dev_dataPointTemp.devData_nightMode[4] << 3; //×Ö½ÚÏÂ±ê4 ¸ß5Î» Ê±
2375   8                                                                      dataTemp[5] = dev_dataPointTemp.devData_nightMode[5];      //×Ö½ÚÏÂ±ê5 È«8Î» ·Ö
2376   8                                                                      
2377   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, dataTemp, sizeof(timing_Dats) * 2); //Ö±½Ó¸üÐÂee
             -promÊý¾Ý
2378   8                                                              }
2379   7                                                              
2380   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_bkLightSetOpreat){ //±³¹âµÆÉèÖÃ²Ù×÷£¬Ðè
             -ÒªÊ±Ð§
2381   8                                                                      
2382   8      #if(DEBUG_LOGOUT_EN == 1)
2383   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2384   9                                                                              
2385   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2386   9                                                                              sprintf(log_buf, ">>>>>>>>agingCmd bkLight coming, on-Isrt:%02d, off-Isrt:%02d.\n", (int)dev_data
             -PointTemp.devData_bkLight[0], (int)dev_dataPointTemp.devData_bkLight[1]);
2387   9                                                                              PrintString1_logOut(log_buf);
2388   9                                                                      }                       
2389   8      #endif  
2390   8                                                              
2391   8                                                                      tipsInsert_swLedBKG_ON  = dev_dataPointTemp.devData_bkLight[0]; //¸üÐÂÔËÐÐ»º´æ
2392   8                                                                      tipsInsert_swLedBKG_OFF = dev_dataPointTemp.devData_bkLight[1]; //Ö±½Ó¸üÐÂeepromÊý¾Ý
2393   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround, dev_dataPointTemp.devData_bkLight, 2);
2394   8                                                              }
2395   7                                                              
2396   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_horsingLight){ //ÅÜÂíµÆÉèÖÃ²Ù×÷£¬ÐèÒªÊ±
             -Ð§
2397   8                                                              
2398   8                                                                      
2399   8                                                              }
2400   7                                                              
2401   7                                                              if(dev_dataPointTemp.devAgingOpreat_agingReference.agingCmd_devResetOpreat){ //¿ª¹ØÎ»»¥¿Ø°ó¶¨²Ù×÷Éè
             -ÖÃ²Ù×÷£¬ÐèÒªÊ±Ð§
2402   8                                                              
2403   8                                                                      u8 loop = 0;
2404   8      #if(DEBUG_LOGOUT_EN == 1)
2405   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2406   9                                                                              
2407   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2408   9                                                                              sprintf(log_buf, ">>>>>>>>agingCmd switchBindSet coming, bindData:%02X %02X %02X.\n", (int)dev_da
             -taPointTemp.devData_switchBitBind[0], (int)dev_dataPointTemp.devData_switchBitBind[1], (int)dev_dataPointTemp.devData_sw
             -itchBitBind[2]);
2409   9                                                                              PrintString1_logOut(log_buf);
2410   9                                                                      }       
2411   8                                                                      
2412   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_portCtrlEachOther, dev_dataPointTemp.devData_switchBitBind, cluste
             -rNum_usr);
2413   8                                                                      memcpy(CTRLEATHER_PORT, dev_dataPointTemp.devData_switchBitBind, clusterNum_usr);
2414   8                                                                      reConnectAfterDatsReq_IF = 1; //¼´¿Ì×¢²á»¥¿ØÍ¨Ñ¶´Ø¶Ë¿Ú
2415   8      #endif  
2416   8                                                              }
2417   7                                                      
2418   7                                                      }else{
2419   7                                                      
2420   7                                                              memset(&dev_agingCmd_rcvPassive, 0, sizeof(stt_agingDataSet_bitHold)); //±¾µØ±»¶¯Ê±Ð§²Ù×÷»º´æÇåÁã
2421   7                                                              
2422   7                                                              if(local_ftyRecover_standbyFLG){ //µ±Ê±Ð§±êÖ¾ÖÃÁãºó²ÅÖ´ÐÐ»Ö¸´³ö³§¶¯×÷£¬·ñÔòÉÏÎ»»ú»áÒ»Ö±ÍùÏÂ·¢¸´Î»
2423   8                                                                      
2424   8      #if(DEBUG_LOGOUT_EN == 1)
2425   8                                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2426   9                                                                              
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 42  

2427   9                                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2428   9                                                                              sprintf(log_buf, ">>>>>>>>factory recover doing now!.\n");
2429   9                                                                              PrintString1_logOut(log_buf);
2430   9                                                                      }                       
2431   8      #endif  
2432   8                                                                      local_ftyRecover_standbyFLG = 0;
2433   8                                                                      Factory_recover();
2434   8                                                              }
2435   7                                                      }
2436   6                                                      
2437   6                                              }break;
2438   5                                                      
2439   5                                              case DTMODEKEEPACESS_FRAMECMD_PST:{
2440   6                                                      
2441   6                                                      if(memcmp(&dev_agingCmd_sndInitative, &dev_dataPointTemp.devAgingOpreat_agingReference, sizeof(stt_a
             -gingDataSet_bitHold))){ //±¾µØÖ÷¶¯Ê±Ð§²Ù×÷»º´æÍ¬²½¸üÐÂ£¬Ê±Ð§Õ¼Î»Óë±¾µØ²»Ò»ÖÂ Ñ¯·ÃÃüÁî¾ÍÒ»Ö±ÎªÖ÷¶¯
2442   7                                                      
2443   7                                                              dtModeKeepAcess_currentCmd = DTMODEKEEPACESS_FRAMECMD_PST;
2444   7                                                              
2445   7                                                      }else{
2446   7                                                      
2447   7                                                              heartBeatPeriod = PERIOD_HEARTBEAT_ASR; //ÇÐ»»Îª±»¶¯Ñ¯·Ã£¬ÐÄÌøÖÜÆÚ¸ÄÎª±»¶¯
2448   7                                                              memset(&dev_agingCmd_sndInitative, 0, sizeof(stt_agingDataSet_bitHold)); //±¾µØÖ÷¶¯Ê±Ð§²Ù×÷»º´æÇåÁã
2449   7                                                              dtModeKeepAcess_currentCmd = DTMODEKEEPACESS_FRAMECMD_ASR;
2450   7                                                      }
2451   6                                                      
2452   6                                              }break;
2453   5                                                      
2454   5                                              default:{}break;
2455   5                                      }
2456   4                              }
2457   3                              
2458   3                      }break;
2459   2                      
2460   2                      /*¶¨Ê±Ñ¯·Ã_Íø¹ØÀëÏß*///internetÀëÏß£¬²»ÊÇzigbÍøÂçÀëÏß
2461   2                      case DTMODEKEEPACESS_FRAMEHEAD_OFFLINE:{
2462   3                              
2463   3                              periodDataTrans_momentHang(6); //internetÀëÏßÇé¿öÏÂ£¬ÖÜÆÚÍ¨Ñ¶¾ÍÃ»ÓÃÁË£¬Í¨ÐÅÆµ´ÎÏÂ½µµ½ 6s/´Î
2464   3      #if(DEBUG_LOGOUT_EN == 1)
2465   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2466   4                                      
2467   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2468   4                                      sprintf(log_buf, ">>>>>>>>internet offline.\n");
2469   4                                      PrintString1_logOut(log_buf);
2470   4                              }       
2471   3      #endif
2472   3                      }break;
2473   2                      
2474   2      #endif /*ºêÅÐÎ²*///¶¨Ê±ÀàÍ¨Ñ¶Ä£Ê½ÅÐ¶Ï
2475   2                      
2476   2                      default:{}break;
2477   2              }
2478   1      }
2479          
2480          /*zigbeeÖ÷Ïß³Ì*///¶¯×÷×èÈû´óÓÚ200msµÄº¯Êý¶¼ÉèÎª×´Ì¬»úÔËÐÐ£¬ÆäËüÐ¡ÓÚ200msº¯Êý£¬×èÈûÎ¬³Ö£¬·ñÔò×´Ì¬»ú¸´ÔÓ¶È¼Ó
             -´ó
2481          void thread_dataTrans(void){
2482   1              
2483   1              u8 code cmd_datsComing[2] = {0x44, 0x81}; //Ô¶¶ËÊý¾ÝÖ¡Ö¸Áî
2484   1              u8 code cmd_nwkOpenNote[2] = {0x45, 0xCB}; //ÍøÂç¿ª·ÅÍ¨Öª
2485   1      
2486   1      #define dataLen_zigbDatsTrans 96
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 43  

2487   1              u8 xdata paramTX_temp[dataLen_zigbDatsTrans] = {0};
2488   1              u8 xdata paramRX_temp[dataLen_zigbDatsTrans] = {0};
2489   1              
2490   1              static bit heartBeat_cmdFLG = 0; //ÐÄÌøÆæÅ¼±êÖ¾
2491   1              
2492   1              /*zigbÖ÷Ïß³ÌÏµÍ³Ê±¼ä¸üÐÂ*/
2493   1              if(!sysTimeReales_counter){ 
2494   2              
2495   2                      sysTimeReales_counter = PERIOD_SYSTIMEREALES;
2496   2                      getSystemTime_reales();
2497   2              }
2498   1              
2499   1              /*zigbÖ÷Ïß³Ì×´Ì¬»ú£º¸ù¾Ý×´Ì¬±êÖ¾ÔËÐÐ*/
2500   1              switch(devRunning_Status){
2501   2              
2502   2                      case status_passiveDataRcv:{
2503   3                              
2504   3                              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
2505   4                              
2506   4                                      devStatus_switch.statusChange_IF = 0;
2507   4                                      devRunning_Status = devStatus_switch.statusChange_standBy;
2508   4                                      
2509   4                                      break;
2510   4                              }
2511   3                              
2512   3                              {/*³õÊ¼»¯Ê±¼ä¸³Öµ*///½ö¿ª»ú¸³ÖµÒ»´Î£¬²»×öÊ±Çøµ÷Õû
2513   4                                      static bit FLG_timeSetInit = 1;
2514   4                                      
2515   4                                      if(FLG_timeSetInit){
2516   5                                      
2517   5                                              FLG_timeSetInit = 0;
2518   5                                              zigB_sysTimeSet(1533810700UL - 946713600UL, 0); //zigbeeÊ±¼ä´Á´Óunix¼ÍÔª946713600<2000/01/01 00:00:00
             ->¿ªÊ¼¼ÆËã
2519   5                                      }
2520   4                              }
2521   3                              
2522   3                              if(devTips_status == status_tipsNwkFind)tips_statusChangeToNormal(); //tips¸´Ô­(ÍøÂçÒÑ¼ÓÈë£¬»Ö¸´Õý³£tip
             -s)
2523   3              
2524   3                              //--------------------------------Ö÷×´Ì¬£ºÐÄÌø--------------------------------------------------------/
             -/
2525   3                              if(heartBeatCycle_FLG && !heartBeatHang_timeCnt){ //ÐÄÌø´¥·¢±êÖ¾ ¼° ¹ÒÆðÊ±¼ä ÅÐ¶Ï
2526   4                                      
2527   4                                      u8 xdata frame_dataLen = 0; //´ý·¢ËÍÊý¾ÝÖ¡³¤¶È
2528   4                              
2529   4                                      heartBeatCycle_FLG = 0;
2530   4                                      heartBeat_cmdFLG = !heartBeat_cmdFLG;
2531   4                                      
2532   4                                      memset(paramTX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans); //Çå»º´æ
2533   4                                      
2534   4      #if(ZIGB_DATATRANS_WORKMODE == DATATRANS_WORKMODE_HEARTBEAT) //Ô­¼´Ê±Í¨Ñ¶»úÖÆÐÄÌø
                                              
                                              frame_dataLen = 14;
                                              paramTX_temp[0] = ZIGB_FRAMEHEAD_HEARTBEAT;
                                              paramTX_temp[1] = frame_dataLen ;
                                              (heartBeat_cmdFLG)?(paramTX_temp[2] = FRAME_HEARTBEAT_cmdOdd):(paramTX_temp[2] = FRAME_HEARTBEAT_cmdEv
             -en);
                                              memcpy(&paramTX_temp[4], &MAC_ID[1], 5);
                                              
                                              if(heartBeat_cmdFLG){ //Ææ°ü
                                              
                                                      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 44  

                                              
                                              }else{ //Å¼°ü
                                              
                                                      
                                              }
              #elif(ZIGB_DATATRANS_WORKMODE == DATATRANS_WORKMODE_KEEPACESS)  //ÐÂÖÜÆÚÑ¯·Ã»úÖÆÑ¯·ÃÖÜÆÚ
2551   4                                      
2552   4                                      //×´Ì¬Ìî×°-ÊµÊ±Öµ
2553   4                                      dev_currentDataPoint.devStatus_Reference.statusRef_swStatus     = status_Relay; //ÖÜÆÚÑ¯·Ã±¾µØÊý¾Ýµã ¿ª¹Ø
             -×´Ì¬¸üÐÂ
2554   4                                      dev_currentDataPoint.devStatus_Reference.statusRef_timer                = ifTim_sw_running_FLAG; //ÖÜÆÚÑ¯·Ã±¾µØÊý¾Ý
             -µã ¶¨Ê±Æ÷×´Ì¬¸üÐÂ
2555   4                                      dev_currentDataPoint.devStatus_Reference.statusRef_devLock              = deviceLock_flag;
2556   4                                      dev_currentDataPoint.devStatus_Reference.statusRef_delay                = (ifDelay_sw_running_FLAG & 0x02) >> 1;
2557   4                                      dev_currentDataPoint.devStatus_Reference.statusRef_greenMode    = (ifDelay_sw_running_FLAG & 0x01) >> 0;
2558   4                                      dev_currentDataPoint.devStatus_Reference.statusRef_nightMode    = ifNightMode_sw_running_FLAG;
2559   4                                      dev_currentDataPoint.devStatus_Reference.statusRef_horsingLight = 0;
2560   4                                      
2561   4                                      //ÊôÐÔÖµÌî×°-ÊµÊ±Öµ
2562   4                                      EEPROM_read_n(EEPROM_ADDR_swTimeTab, &dev_currentDataPoint.devData_timer, 24); //¶¨Ê±Êý¾Ý
2563   4                                      dev_currentDataPoint.devData_delayer            = delayPeriod_onoff - (delayCnt_onoff / 60); //ÑÓÊ±Êý¾Ý
2564   4                                      dev_currentDataPoint.devData_delayUpStatus      = delayUp_act; //ÑÓÊ±ÏìÓ¦×´Ì¬Êý¾Ý
2565   4                                      dev_currentDataPoint.devData_greenMode          = delayPeriod_closeLoop; //ÂÌÉ«Ä£Ê½×´Ì¬Êý¾Ý
2566   4                                      { //Ò¹¼äÄ£Ê½Êý¾ÝÌØÊâ×ª»»
2567   5                                              
2568   5                                              timing_Dats xdata nightDatsTemp_CalibrateTab[2] = {0};
2569   5                                              
2570   5                                              datsTimNight_read_eeprom(nightDatsTemp_CalibrateTab);
2571   5                                              ((nightDatsTemp_CalibrateTab[0].Week_Num & 0x7F) == 0x7F)?(dev_currentDataPoint.devData_nightMode[0] 
             -= 1):(dev_currentDataPoint.devData_nightMode[0] = 0);
2572   5                                              (nightDatsTemp_CalibrateTab[0].if_Timing)?(dev_currentDataPoint.devData_nightMode[1] = 1):(dev_curren
             -tDataPoint.devData_nightMode[1] = 0);
2573   5                                              dev_currentDataPoint.devData_nightMode[2] = nightDatsTemp_CalibrateTab[0].Hour;
2574   5                                              dev_currentDataPoint.devData_nightMode[3] = nightDatsTemp_CalibrateTab[0].Minute;
2575   5                                              dev_currentDataPoint.devData_nightMode[4] = nightDatsTemp_CalibrateTab[1].Hour;
2576   5                                              dev_currentDataPoint.devData_nightMode[5] = nightDatsTemp_CalibrateTab[1].Minute;
2577   5                                      }
2578   4                                      EEPROM_read_n(EEPROM_ADDR_ledSWBackGround, &dev_currentDataPoint.devData_bkLight, 2); //±³¾°µÆÊý¾Ý
2579   4                                      dev_currentDataPoint.devData_devReset = 0;
2580   4                                      EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther, dev_currentDataPoint.devData_switchBitBind, clusterNum_us
             -r); //»¥¿Ø°ó¶¨Êý¾Ý
2581   4                                      
2582   4                                      //Ê±Ð§²Ù×÷Õ¼Î»Ö¸ÁîÌî×°
2583   4                                      switch(dtModeKeepAcess_currentCmd){
2584   5                                      
2585   5                                              case DTMODEKEEPACESS_FRAMECMD_ASR:{
2586   6                                              
2587   6                                                      memcpy(&dev_currentDataPoint.devAgingOpreat_agingReference, &dev_agingCmd_rcvPassive, sizeof(stt_agi
             -ngDataSet_bitHold));
2588   6                                              
2589   6                                              }break;
2590   5                                                      
2591   5                                              case DTMODEKEEPACESS_FRAMECMD_PST:{
2592   6                                              
2593   6                                                      memcpy(&dev_currentDataPoint.devAgingOpreat_agingReference, &dev_agingCmd_sndInitative, sizeof(stt_a
             -gingDataSet_bitHold));
2594   6                                              
2595   6                                              }break;
2596   5                                                      
2597   5                                              default:{}break;
2598   5                                      }
2599   4                                      
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 45  

2600   4                                      //Êý¾ÝÖ¡×ÜÊý¾ÝÌî×°
2601   4                                      frame_dataLen                                   = 0;
2602   4                                      paramTX_temp[frame_dataLen ++]  = DTMODEKEEPACESS_FRAMEHEAD_ONLINE; //Ö¡Í·
2603   4                                      paramTX_temp[frame_dataLen ++]  = 0;  //Ö¡³¤ÔÝÌî0£¬×îºó¸üÐÂ
2604   4                                      memcpy(&paramTX_temp[frame_dataLen], &MAC_ID[1], 5); //MAC
2605   4                                      frame_dataLen += 6; //¿Õ³ö1Byte MAC
2606   4                                      paramTX_temp[frame_dataLen ++]  = dtModeKeepAcess_currentCmd; //ÃüÁî
2607   4                                      paramTX_temp[frame_dataLen ++]  = SWITCH_TYPE; //¿ª¹ØÐÅÏ¢
2608   4                                      paramTX_temp[frame_dataLen ++]  = 0; //devVersion_reserve
2609   4                                      paramTX_temp[frame_dataLen ++]  = 0; //devVersion_reserve
2610   4                                      paramTX_temp[frame_dataLen ++]  = 0; //devVersion_reserve
2611   4                                      paramTX_temp[frame_dataLen ++]  = sysTimeZone_H; //Ê±Çø_Ê±
2612   4                                      paramTX_temp[frame_dataLen ++]  = sysTimeZone_M; //Ê±Çø_·Ö
2613   4                                      memcpy(&paramTX_temp[frame_dataLen], &dev_currentDataPoint, sizeof(stt_devOpreatDataPonit)); //Ö±½ÓÊý¾
             -ÝÖ¸Õë¶ÔÆë,Êý¾ÝµãÏòÊý¾ÝÖ¡´ý·¢»º´æÇ¿í¡
2614   4                                      frame_dataLen += sizeof(stt_devOpreatDataPonit);
2615   4                                      frame_dataLen ++;
2616   4                                      paramTX_temp[1]                                 = frame_dataLen;
2617   4                                      paramTX_temp[frame_dataLen - 1] = frame_Check(&paramTX_temp[1], frame_dataLen - 2); //Ð£ÑéÂë×îºóËã
2618   4                                      
2619   4      //#if(DEBUG_LOGOUT_EN == 1)
2620   4      //                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2621   4      //                                      u8 xdata log_buf[64];
2622   4      //                                      
2623   4      //                                      sprintf(log_buf, "package_num:[%02d], check_num[%02X].\n", (int)frame_dataLen, (int)paramTX_temp[fr
             -ame_dataLen - 1]);
2624   4      //                                      PrintString1_logOut(log_buf);
2625   4      //                              }                       
2626   4      //#endif        
2627   4                              
2628   4      #endif                          
2629   4                                      datsSend_request.nwkAddr = 0; //½ö¶ÔÍø¹Ø·¢ËÍ£¬½øÐÐÊý¾Ý×ª·¢
2630   4                                      datsSend_request.portPoint = ZIGB_ENDPOINT_CTRLNORMAL; //³£¹æÊý¾Ý×ª·¢×¨ÓÃ¶Ë¿Ú
2631   4                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
2632   4                                      memcpy(datsSend_request.datsTrans.dats, paramTX_temp, frame_dataLen );
2633   4                                      datsSend_request.datsTrans.datsLen = frame_dataLen ;
2634   4                                      datsRcv_respond.datsTrans.datsLen = 0;
2635   4                                      devRemoteDataReqMethod.keepTxUntilCmp_IF = 1; //ËÀ¿Ä
2636   4                                      devRemoteDataReqMethod.datsTxKeep_Period = REMOTE_DATAREQ_TIMEOUT / 4; //ËÀ¿ÄÖÜÆÚ£¬³ý´Î±È µ¥¸ö³¬Ê±ÖÜÆÚ
             -ÄÚ ·¢ 4´Î
2637   4                                      devRunning_Status = status_dataTransRequestDatsSend;
2638   4                                      
2639   4                                      return; //Ô½¹ý±¾´Îµ÷¶È£¬Õ¼ÓÃÊý¾Ý·¢ËÍ×´Ì¬¸ü¸ÄÈ¨£¬ÏÈµ½ÏÈµÃ£¬ÆäËüÐèÒª¸ü¸ÄÊý¾Ý·¢ËÍÈ¨µÄÒµÎñ£¬·¢ËÍ×´Ì¬±£³Ö£¬
             -µÈ´ýÏÈÐÐÒµÎñÊý¾Ý·¢ËÍÍê±Ï
2640   4                              }
2641   3                              
2642   3                              //------------------------------Ö÷×´Ì¬£º±¾µØ¿ª¹ØÊÜ¼¯Èº¿ØÖÆ×´Ì¬Î»ÖÜÆÚÐÔÂÖÑ¯<°üÀ¨ÓÐ»¥¿ØºÍ³¡¾°>---------//
2643   3      #if(COLONYINFO_QUERYPERIOD_EN == ENABLE) /*ºêÅÐÍ·*///¼¯Èº¿ØÖÆÐÅÏ¢ÖÜÆÚ²éÑ¯Ê¹ÄÜ
                                      if(!colonyCtrlGet_queryCounter && !colonyCtrlGetHang_timeCnt){ //ÖÜÆÚÑ¯²é ¼° ¹ÒÆðÊ±¼äÅÐ¶Ï
                                      
                                              colonyCtrlGet_queryCounter = COLONYCTRLGET_QUERYPERIOD;
                                              
                                              /*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>frame reference<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
             -<<<<<<<<<<<<<<<<<<<<<<*/
                                              /*----------------------------------------------------------------------------------------------------
             -----------------------*/
                                              /*      frame_data[0]           |       frame_data[1]           |       frame_data[2...6]       |       frame_data[7]                   |       frame_data[8...10]      |
                                              /*----------------------------------------------------------------------------------------------------
             -----------------------*/
                                              /*      ÃüÁî                            |       Êý¾Ý³¤¶È                        |       ±¾»úMACµØÖ·                     |       ³¡¾°ËµÃ÷(ÔÝÎÞËµÃ÷)              |       »¥¿ØËµÃ÷(µ±Ç°×éºÅ)      |               
                                              /*----------------------------------------------------------------------------------------------------
             -----------------------*/
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 46  

                                              memset(paramTX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans); //Çå»º´æ
                                              paramTX_temp[0] = ZIGB_SYSCMD_COLONYPARAM_REQPERIOD; //ÃüÁî
                                              paramTX_temp[1] = clusterNum_usr + 5 + 1; //Êý¾Ý³¤¶ÈËµÃ÷
                                              memcpy(&paramTX_temp[2], &MAC_ID[1], 5); //MACµØÖ·Ìî×°
                                              paramTX_temp[7] = 0; //³¡¾°ËµÃ÷×°ÔØ(ÎÞËµÃ÷£¬0Ìî³ä)
                                              memcpy(&paramTX_temp[8], CTRLEATHER_PORT, clusterNum_usr); //»¥¿ØËµÃ÷×°ÔØ(ËµÃ÷¶Ë¿ÚºÅ)
                                              
                                              datsSend_request.nwkAddr = 0; //½ö¶ÔÍø¹Ø·¢ËÍ
                                              datsSend_request.portPoint = ZIGB_ENDPOINT_CTRLSYSZIGB; //zigbÏµÍ³½»»¥×¨ÓÃ¶Ë¿Ú
                                              memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
                                              memcpy(datsSend_request.datsTrans.dats, paramTX_temp, paramTX_temp[1] + 2); 
                                              datsSend_request.datsTrans.datsLen = paramTX_temp[1] + 2;
                                              datsRcv_respond.datsTrans.datsLen = 0; //²»ÐèÒªÔ¶¶ËÓ¦´ð
                                              devRunning_Status = status_dataTransRequestDatsSend;
                                              
                                              return; //Ô½¹ý±¾´Îµ÷¶È£¬Õ¼ÓÃÊý¾Ý·¢ËÍ×´Ì¬¸ü¸ÄÈ¨£¬ÏÈµ½ÏÈµÃ£¬ÆäËüÐèÒª¸ü¸ÄÊý¾Ý·¢ËÍÈ¨µÄÒµÎñ£¬·¢ËÍ×´Ì¬±£³Ö£¬
             -µÈ´ýÏÈÐÐÒµÎñÊý¾Ý·¢ËÍÍê±Ï
                                      }
              #endif /*ºêÅÐÎ²*///¼¯Èº¿ØÖÆÐÅÏ¢ÖÜÆÚ²éÑ¯Ê¹ÄÜ
2672   3                              
2673   3                              //--------------------------------Ö÷×´Ì¬£ºÊý¾ÝÍÆËÍ---------------------------------------------------//
             -        
2674   3                              if(devActionPush_IF.push_IF){
2675   4                                      
2676   4                                      const bit dataFromRemote_IF = 1; //Ô¶³ÌÍÆËÍ
2677   4                                      const bit specialCmd_IF = 0; //·ÇÌØÊâÕ¼Î»
2678   4                                      
2679   4                                      u8 xdata datsTX_Len = 0;
2680   4                                      
2681   4                                      devActionPush_IF.push_IF = 0;
2682   4                                      
2683   4      #if(ZIGB_DATATRANS_WORKMODE == DATATRANS_WORKMODE_HEARTBEAT) //Ô­¼´Ê±Í¨Ñ¶»úÖÆÐÄÌø
                                              
                                              memset(paramTX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans); //Çå»º´æ
                                              
                                              paramTX_temp[11] = devActionPush_IF.dats_Push; //ÍÆËÍÐÅÏ¢Ìî×°
              
              #if(DEBUG_LOGOUT_EN == 1)
                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
                                                      u8 xdata log_buf[64];
                                                      
                                                      sprintf(log_buf, "swData push:%02X.\n", (int)devActionPush_IF.dats_Push);
                                                      PrintString1_logOut(log_buf);
                                              }                       
              #endif  
                                              datsTX_Len = dtasTX_loadBasic_CUST(dataFromRemote_IF,
                                                                                                                 paramTX_temp,
                                                                                                                 33,
                                                                                                                 FRAME_TYPE_StoM_RCVsuccess,
                                                                                                                 FRAME_MtoZIGBCMD_cmdControl,
                                                                                                                 specialCmd_IF);
                                      
                                              datsSend_request.nwkAddr = 0; //½ö¶ÔÍø¹Ø·¢ËÍ£¬½øÐÐÊý¾Ý×ª·¢
                                              datsSend_request.portPoint = ZIGB_ENDPOINT_CTRLNORMAL; //³£¹æÊý¾Ý×ª·¢×¨ÓÃ¶Ë¿Ú
                                              memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
                                              memcpy(datsSend_request.datsTrans.dats, paramTX_temp, datsTX_Len);
                                              datsSend_request.datsTrans.datsLen = datsTX_Len;
                                              datsRcv_respond.datsTrans.datsLen = 0; //ÎÞÐèÔ¶¶ËÓ¦´ð
                                              devRunning_Status = status_dataTransRequestDatsSend; //Ö±½ÓÇÐ»»£¨²»×öÔ¤±¸¶¯×÷£©
                                              
              #elif(ZIGB_DATATRANS_WORKMODE == DATATRANS_WORKMODE_KEEPACESS) //ÖÜÆÚÑ¯·Ã»úÖÆÎÞÐèÍÆËÍ£¬Ö»Ðè´¥·¢Ö÷¶¯Ê±Ð§ÃüÁ
             -î¼´¿É
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 47  

2713   4                                      
2714   4                                      dev_currentDataPoint.devStatus_Reference.statusRef_swPush = (devActionPush_IF.dats_Push & 0xE0) >> 5; 
             -//ÊôÐÔÖµÌî×°
2715   4                                      dev_agingCmd_sndInitative.agingCmd_swOpreat = 1; //¶ÔÓ¦Ö÷¶¯ÉÏ´«Ê±Ð§Õ¼Î»ÖÃÒ»
2716   4                                      dtModeKeepAcess_currentCmd = DTMODEKEEPACESS_FRAMECMD_PST;
2717   4                                      
2718   4                                      heartBeatPeriod = PERIOD_HEARTBEAT_PST; //Ö÷¶¯Ñ¯·ÃÇÐ»»£¬ÐÄÌøÖÜÆÚ¸ÄÎªÖ÷¶¯
2719   4                                      heartBeatCount  = heartBeatPeriod; 
2720   4      #endif
2721   4      
2722   4                                      return; //Ô½¹ý±¾´Îµ÷¶È£¬Õ¼ÓÃÊý¾Ý·¢ËÍ×´Ì¬¸ü¸ÄÈ¨£¬ÏÈµ½ÏÈµÃ£¬ÆäËüÐèÒª¸ü¸ÄÊý¾Ý·¢ËÍÈ¨µÄÒµÎñ£¬·¢ËÍ×´Ì¬±£³Ö£¬
             -µÈ´ýÏÈÐÐÒµÎñÊý¾Ý·¢ËÍÍê±Ï
2723   4                              }
2724   3                              
2725   3                              //--------------------------------Ö÷×´Ì¬£º»¥¿ØÍ¬²½---------------------------------------------------//
2726   3                              if(EACHCTRL_realesFLG){ //¹ã²¥»¥¿ØÖµ
2727   4                              
2728   4                                      if(devRunning_Status == status_passiveDataRcv){
2729   5                                      
2730   5                                              u8 idata loop;
2731   5                                              
2732   5                                              for(loop = 0; loop < clusterNum_usr; loop ++){ //Èý¸ö¿ª¹ØÎ»·Ö±ðÅÐ¶¨
2733   6                                              
2734   6                                                      if(EACHCTRL_realesFLG & (1 << loop)){ //»¥¿ØÓÐÐ§Î»ÅÐ¶Ï
2735   7                                                      
2736   7                                                              EACHCTRL_realesFLG &= ~(1 << loop); //»¥¿ØÓÐÐ§Î»ÇåÁã
2737   7                                                              
2738   7                                                              paramTX_temp[0] = (status_Relay >> loop) & 0x01; //¿ª¹Ø×´Ì¬Ìî×°
2739   7                                                              
2740   7                                                              if((CTRLEATHER_PORT[loop] > CTRLEATHER_PORT_NUMSTART) && CTRLEATHER_PORT[loop] < CTRLEATHER_PORT_NU
             -MTAIL){ //ÊÇ·ñÎªÓÐÐ§»¥¿Ø¶Ë¿Ú
2741   8                                                                      
2742   8                                                                      (paramTX_temp[0])?(colonyCtrlGet_statusLocalEaCtrl[loop] = STATUSLOCALEACTRL_VALMASKRESERVE_ON):(c
             -olonyCtrlGet_statusLocalEaCtrl[loop] = STATUSLOCALEACTRL_VALMASKRESERVE_OFF); //±¾µØ»¥¿Ø×´Ì¬¸üÐÂ
2743   8                                                                      colonyCtrlGet_queryCounter = COLONYCTRLGET_QUERYPERIOD; //¼¯ÈºÐÅÏ¢²éÑ¯Ö÷¶¯ÖÍºó£¬ÒÔ·ÀÓëÖ÷»ú¼¯ÈºÐÅÏ¢
             -Î´¸üÐÂ£¬µ¼ÖÂÓë±¾µØÐÅÏ¢³åÍ»
2744   8                                                              
2745   8                                                                      datsSend_request.nwkAddr = 0xffff; //¼ä½Ó×é²¥£¨¶Ô»¥¿Ø×¨ÓÃ¶Ë¿Ú½øÐÐ¹ã²¥£©
2746   8                                                                      datsSend_request.portPoint = CTRLEATHER_PORT[loop]; //»¥¿ØÎ»¶ÔÓ¦°ó¶¨¶Ë¿Ú
2747   8                                                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
2748   8                                                                      memcpy(datsSend_request.datsTrans.dats, paramTX_temp, 1);
2749   8                                                                      datsSend_request.datsTrans.datsLen = 1;
2750   8                                                                      datsRcv_respond.datsTrans.datsLen = 0; //ÎÞÐèÔ¶¶ËÓ¦´ð
2751   8                                                                      
2752   8                                                                      devRemoteDataReqMethod.keepTxUntilCmp_IF = 1; //ËÀ¿Ä
2753   8                                                                      devRemoteDataReqMethod.datsTxKeep_Period = REMOTE_DATAREQ_TIMEOUT / 10; //ËÀ¿ÄÖÜÆÚ£¬³ý´Î±È µ¥¸ö³¬Ê
             -±ÖÜÆÚÄÚ ·¢ 10 ´Î
2754   8                                                                      
2755   8                                                                      EACHCTRL_reportFLG = 1; //ÏòÍø¹Ø»ã±¨
2756   8                                                                      
2757   8                                                                      devRunning_Status = status_dataTransRequestDatsSend; //Ö±½ÓÇÐ»»£¨²»×öÔ¤±¸¶¯×÷£©
2758   8                                                                      
2759   8                                                                      return; //Ô½¹ý±¾´Îµ÷¶È£¬Õ¼ÓÃÊý¾Ý·¢ËÍ×´Ì¬¸ü¸ÄÈ¨£¬ÏÈµ½ÏÈµÃ£¬ÆäËüÐèÒª¸ü¸ÄÊý¾Ý·¢ËÍÈ¨µÄÒµÎñ£¬·¢ËÍ×´Ì¬±£
             -³Ö£¬µÈ´ýÏÈÐÐÒµÎñÊý¾Ý·¢ËÍÍê±Ï
2760   8                                                              }
2761   7                                                      }
2762   6                                              }
2763   5                                      }       
2764   4                              }
2765   3      
2766   3      #if(COLONYINFO_QUERYPERIOD_EN == ENABLE) /*ºêÅÐÍ·*///¼¯Èº¿ØÖÆÐÅÏ¢ÖÜÆÚ²éÑ¯Ê¹ÄÜ   
                                      if(EACHCTRL_reportFLG){ //ÏòÍø¹Øµ¥²¥µ±Ç°ËùÓÐ»¥¿Ø×éºÅ¶ÔÓ¦µÄ¿ª¹Ø×´Ì¬Öµ
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 48  

                                      
                                              EACHCTRL_reportFLG = 0;
                                              
                                              /*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>frame reference<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
             -<<<<<<*/
                                              /*----------------------------------------------------------------------------------------------------
             -------*/
                                              /*      frame_data[0]           |       frame_data[1]           |       frame_data[2/4/6]       |               frame_data[3/5/7]                       |
                                              /*----------------------------------------------------------------------------------------------------
             -------*/
                                              /*      ÃüÁî                            |       Êý¾Ý³¤¶È                        |       ±¾µØ»¥¿Ø¶Ë¿ÚºÅ          |       ±¾µØ»¥¿Ø¶Ë¿ÚºÅ¶ÔÓ¦¿ª¹Ø×´Ì¬Öµ    |
                                              /*----------------------------------------------------------------------------------------------------
             -------*/
                                              {
                                                      u8 code remote_responseFrame[3] = {ZIGB_SYSCMD_EACHCTRL_REPORT, 0x01, 0x00}; //Ô¶¶ËÏìÓ¦Ö¡<È·±£Ö÷»úÊÕµ
             -½>
                                                      
              #if(DEBUG_LOGOUT_EN == 1)
                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
                                                              u8 xdata log_buf[64];
                                                              
                                                              sprintf(log_buf, "current eaCtrl insrt[2] is: %02X.\n", (int)colonyCtrlGet_statusLocalEaCtrl[1]);
                                                              PrintString1_logOut(log_buf);
                                                      }                       
              #endif  
                                                      
                                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
                                                      datsSend_request.datsTrans.dats[0]      = ZIGB_SYSCMD_EACHCTRL_REPORT;
                                                      datsSend_request.datsTrans.dats[1]      = 6;
                                                      datsSend_request.datsTrans.dats[2]      = CTRLEATHER_PORT[0];
                                                      datsSend_request.datsTrans.dats[3]      = colonyCtrlGet_statusLocalEaCtrl[0];
                                                      datsSend_request.datsTrans.dats[4]      = CTRLEATHER_PORT[1];
                                                      datsSend_request.datsTrans.dats[5]      = colonyCtrlGet_statusLocalEaCtrl[1];
                                                      datsSend_request.datsTrans.dats[6]      = CTRLEATHER_PORT[2];
                                                      datsSend_request.datsTrans.dats[7]      = colonyCtrlGet_statusLocalEaCtrl[2];
                                                      datsSend_request.datsTrans.datsLen      = 8;
                                                      datsSend_request.nwkAddr                        = 0;
                                                      datsSend_request.portPoint                      = ZIGB_ENDPOINT_CTRLSYSZIGB;
                                                      
                                                      memset(datsRcv_respond.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8)); //ÐèÒªÔ¶¶ËÏìÓ¦
                                                      memcpy(datsRcv_respond.datsTrans.dats, remote_responseFrame, 3); //Ô¶¶ËÏìÓ¦Ö¡¼ÓÔØ
                                                      datsRcv_respond.datsTrans.datsLen       = 3;
                                                      datsRcv_respond.nwkAddr                         = 0;
                                                      datsRcv_respond.portPoint                       = ZIGB_ENDPOINT_CTRLSYSZIGB;
                                                      
                                                      devRunning_Status = status_dataTransRequestDatsSend; //Ö±½ÓÇÐ»»£¨²»×öÔ¤±¸¶¯×÷£©
                                              }
                                              
                                              return; //Ô½¹ý±¾´Îµ÷¶È£¬Õ¼ÓÃÊý¾Ý·¢ËÍ×´Ì¬¸ü¸ÄÈ¨£¬ÏÈµ½ÏÈµÃ£¬ÆäËüÐèÒª¸ü¸ÄÊý¾Ý·¢ËÍÈ¨µÄÒµÎñ£¬·¢ËÍ×´Ì¬±£³Ö£¬
             -µÈ´ýÏÈÐÐÒµÎñÊý¾Ý·¢ËÍÍê±Ï
                                      }
              #endif /*ºêÅÐÎ²*///¼¯Èº¿ØÖÆÐÅÏ¢ÖÜÆÚ²éÑ¯Ê¹ÄÜ
2814   3                              
2815   3                              //--------------------------------Ö÷×´Ì¬£ºÊý¾Ý½âÎöÏìÓ¦-----------------------------------------------//
2816   3                              if(uartRX_toutFLG){ //Êý¾Ý½ÓÊÕ(Ö¡³¬Ê±)
2817   4                                      
2818   4                                      uartRX_toutFLG = 0;
2819   4                                      
2820   4      //                              if(datsRcv_ZIGB.rcvDats[0] != ZIGB_FRAME_HEAD){ //Ö¡Í·²»¶Ô£¬´òÓ¡Êä³ö
2821   4      //                              
2822   4      //#if(DEBUG_LOGOUT_EN == 1)
2823   4      //                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 49  

2824   4      //                                                      u8 xdata log_buf[64];
2825   4      //                                                      
2826   4      //                                                      sprintf(log_buf, "err frameHead:%02X.\n", (int)datsRcv_ZIGB.rcvDats[0]);
2827   4      //                                                      PrintString1_logOut(log_buf);
2828   4      //                                              }                       
2829   4      //#endif        
2830   4      //                              }
2831   4                                      
2832   4                                      /*ZigbeeÒ»¼¶Ð­ÒéºË¶Ô½âÎö*/
2833   4                                      if((datsRcv_ZIGB.rcvDats[0] == ZIGB_FRAME_HEAD) &&
2834   4                                              !memcmp(&datsRcv_ZIGB.rcvDats[2], cmd_datsComing, 2)){ //Ô¶¶ËÊý¾Ýµ½À´Ö¸Áî
2835   5                                              
2836   5                                              u16 idata datsFrom_addr = ((u16)(datsRcv_ZIGB.rcvDats[9]) << 8) | ((u16)(datsRcv_ZIGB.rcvDats[8]) << 
             -0); //Êý¾Ý·¢ËÍ·½ÍøÂçµØÖ·
2837   5                                              u8      idata srcPoint =  datsRcv_ZIGB.rcvDats[10];     //Ô´¶Ë
2838   5                                              u8      idata dstPoint =  datsRcv_ZIGB.rcvDats[11];     //Ô¶¶Ë
2839   5                                                      
2840   5                                              devTips_nwkZigb = nwkZigb_Normal; //zigbTips×´Ì¬ÏìÓ¦£¬Ö»Òª½ÓÊÕµ½zigbÊý¾Ý£¬tips×´Ì¬¾ÍÇÐ»»ÖÁÕý³£
2841   5                                              
2842   5                                              memset(paramRX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans);
2843   5                                              memcpy(paramRX_temp, &(datsRcv_ZIGB.rcvDats[21]), datsRcv_ZIGB.rcvDats[20]);
2844   5                                                      
2845   5                                              if(srcPoint > CTRLEATHER_PORT_NUMSTART && srcPoint < CTRLEATHER_PORT_NUMTAIL){ /*»¥¿Ø¶Ë¿Ú*/
2846   6                                                      
2847   6                                                      u8 idata statusRelay_temp = status_Relay; //µ±Ç°¿ª¹Ø×´Ì¬»º´æ
2848   6                                                      
2849   6                                                      colonyCtrlGet_queryCounter = COLONYCTRLGET_QUERYPERIOD; //¼¯ÈºÐÅÏ¢²éÑ¯Ö÷¶¯ÖÍºó£¬ÒÔ·ÀÓëÖ÷»ú¼¯ÈºÐÅÏ¢Î´
             -¸üÐÂ£¬µ¼ÖÂÓë±¾µØÐÅÏ¢³åÍ»
2850   6                                                      
2851   6      #if(DEBUG_LOGOUT_EN == 1)
2852   6                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
2853   7                                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
2854   7                                                              sprintf(log_buf, "ctrl eachOther cmd coming, cluster:%02d.\n", (int)srcPoint);
2855   7                                                              PrintString1_logOut(log_buf);
2856   7                                                      }                       
2857   6      #endif  
2858   6                                                      if((srcPoint == CTRLEATHER_PORT[0]) && (0 != CTRLEATHER_PORT[0])){ //¿ª¹ØÎ»1 »¥¿Ø°ó¶¨ÅÐ¶Ï
2859   7                                                      
2860   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2861   7                                                              statusRelay_temp &= ~(1 << 0); //¶¯×÷Î»»º´æÇåÁã
2862   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 0; //bit0 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
2863   7                                                              (paramRX_temp[0])?(colonyCtrlGet_statusLocalEaCtrl[0] = STATUSLOCALEACTRL_VALMASKRESERVE_ON):(colon
             -yCtrlGet_statusLocalEaCtrl[0] = STATUSLOCALEACTRL_VALMASKRESERVE_OFF); //±¾µØ»¥¿ØÂÖÑ¯Öµ¸üÐÂ
2864   7                                                              if((status_Relay & 0x01) != (paramRX_temp[0] & 0x01))dataSendRemote_straightforward(0xffff, srcPoin
             -t, &paramRX_temp[0], 1); //»¥¿Ø¹ã²¥¶þ´Î²¹³ä£¨Óë±¾µØ×´Ì¬²»Í¬Ê±²Å×ö²¹³ä£¬·ÀÖ¹²¹³ä·ºÀÄ£©
2865   7                                                      }
2866   6                                                      else
2867   6                                                      if((srcPoint == CTRLEATHER_PORT[1]) && (0 != CTRLEATHER_PORT[1])){ //¿ª¹ØÎ»2 »¥¿Ø°ó¶¨ÅÐ¶Ï
2868   7                                                      
2869   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2870   7                                                              statusRelay_temp &= ~(1 << 1); //¶¯×÷Î»»º´æÇåÁã
2871   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 1; //bit1 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
2872   7                                                              (paramRX_temp[0])?(colonyCtrlGet_statusLocalEaCtrl[1] = STATUSLOCALEACTRL_VALMASKRESERVE_ON):(colon
             -yCtrlGet_statusLocalEaCtrl[1] = STATUSLOCALEACTRL_VALMASKRESERVE_OFF); //±¾µØ»¥¿ØÂÖÑ¯Öµ¸üÐÂ
2873   7                                                              if((status_Relay & 0x02) != (paramRX_temp[0] & 0x02))dataSendRemote_straightforward(0xffff, srcPoin
             -t, &paramRX_temp[0], 1); //»¥¿Ø¹ã²¥¶þ´Î²¹³ä£¨Óë±¾µØ×´Ì¬²»Í¬Ê±²Å×ö²¹³ä£¬·ÀÖ¹²¹³ä·ºÀÄ£©
2874   7                                                      }
2875   6                                                      else
2876   6                                                      if((srcPoint == CTRLEATHER_PORT[2]) && (0 != CTRLEATHER_PORT[2])){ //¿ª¹ØÎ»3 »¥¿Ø°ó¶¨ÅÐ¶Ï
2877   7                                                      
2878   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2879   7                                                              statusRelay_temp &= ~(1 << 2); //¶¯×÷Î»»º´æÇåÁã
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 50  

2880   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 2; //bit2 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
2881   7                                                              (paramRX_temp[0])?(colonyCtrlGet_statusLocalEaCtrl[2] = STATUSLOCALEACTRL_VALMASKRESERVE_ON):(colon
             -yCtrlGet_statusLocalEaCtrl[2] = STATUSLOCALEACTRL_VALMASKRESERVE_OFF); //±¾µØ»¥¿ØÂÖÑ¯Öµ¸üÐÂ
2882   7                                                              if((status_Relay & 0x04) != (paramRX_temp[0] & 0x04))dataSendRemote_straightforward(0xffff, srcPoin
             -t, &paramRX_temp[0], 1); //»¥¿Ø¹ã²¥¶þ´Î²¹³ä£¨Óë±¾µØ×´Ì¬²»Í¬Ê±²Å×ö²¹³ä£¬·ÀÖ¹²¹³ä·ºÀÄ£©
2883   7                                                      }
2884   6                                                      
2885   6                                                      devActionPush_IF.push_IF = 1; //ÍÆËÍÊ¹ÄÜ
2886   6                                              
2887   6                                              }else{ /*·Ç»¥¿Ø¶Ë¿Ú*///Ê£ÏÂ¾ÍÊÇÏµÍ³×¨ÓÃµÄ15¸ö¶Ë¿Ú
2888   6                                              
2889   6                                                      switch(srcPoint){
2890   7                                                              
2891   7                                                              /*³¡¾°¼¯Èº¶Ë¿Ú*/
2892   7                                                              case ZIGB_ENDPOINT_CTRLSECENARIO:{      
2893   8                                                              
2894   8                                                                      dataParing_scenarioCtrl(paramRX_temp); //³¡¾°¼¯Èº¿ØÖÆ½âÎö
2895   8                                                                      
2896   8                                                              }break;
2897   7                                                      
2898   7                                                              /*³£¹æ¿ØÖÆ×ª·¢¶Ë¿Ú*/
2899   7                                                              case ZIGB_ENDPOINT_CTRLNORMAL:{ 
2900   8                                                              
2901   8                                                                      if(datsFrom_addr == ZIGB_NWKADDR_CORDINATER){ //À´×ÔÐ­µ÷Æ÷
2902   9                                                                      
2903   9                                                                              dataParing_Nomal(paramRX_temp, datsFrom_addr, srcPoint); //³£¹æ½âÎö
2904   9                                                                      }
2905   8                                                                      
2906   8                                                              }break;
2907   7                                                              
2908   7                                                              /*zigbÏµÍ³½»»¥¶Ë¿Ú*/
2909   7                                                              case ZIGB_ENDPOINT_CTRLSYSZIGB:{        
2910   8                                                              
2911   8                                                                      dataParing_zigbSysCtrl(paramRX_temp); //ÏµÍ³¿ØÖÆ½âÎö
2912   8                                                                      
2913   8                                                              }break;
2914   7                                                                      
2915   7                                                              default:{
2916   8                                                              
2917   8                                                                      
2918   8                                                                      
2919   8                                                              }break;
2920   7                                                      }
2921   6                                              }
2922   5                                              
2923   5                                      }else
2924   4                                      if((datsRcv_ZIGB.rcvDats[0] == ZIGB_FRAME_HEAD) &&
2925   4                                         !memcmp(&datsRcv_ZIGB.rcvDats[2], cmd_nwkOpenNote, 2)){ //ÍøÂç¿ª·ÅÍ¨Öª
2926   5                                              
2927   5                                              tips_statusChangeToZigbNwkOpen(datsRcv_ZIGB.rcvDats[4]); //tips´¥·¢
2928   5                                      }
2929   4                              }
2930   3                              
2931   3                      }break;
2932   2                      
2933   2                      case status_nwkREQ:{
2934   3                      
2935   3                              //--------------------------------Ð­×´Ì¬£ºÍøÂçÇëÇó-----------------------------------------------//
2936   3                              devTips_nwkZigb = nwkZigb_nwkREQ;
2937   3                              zigB_nwkJoinRequest(1); //·Ç×èÈûÖ÷¶¯¼ÓÈë¸½½ü¿ª·ÅÍøÂç
2938   3                              
2939   3                      }break;
C51 COMPILER V9.54   DATATRANS                                                             11/09/2018 14:49:55 PAGE 51  

2940   2                              
2941   2                      case status_nwkReconnect:{
2942   3                      
2943   3                              //--------------------------------Ð­×´Ì¬£ºµôÏß´¦Àí-----------------------------------------------//
2944   3                              devTips_nwkZigb = nwkZigb_reConfig;
2945   3                              zigB_nwkJoinRequest(0); //·Ç×èÈûÖØÁ¬
2946   3                              
2947   3                      }break;
2948   2                      
2949   2                      case status_dataTransRequestDatsSend:{
2950   3                              
2951   3                              //--------------------------------Ð­×´Ì¬£ºÊý¾ÝÇëÇó-----------------------------------------------//
2952   3                              dataTransRequest_datsSend(); //·Ç×èÈûÔ¶¶ËÊý¾Ý´«Êä
2953   3                      
2954   3                      }break;
2955   2                      
2956   2                      case status_devNwkHold:{
2957   3                      
2958   3                              //--------------------------------Ð­×´Ì¬£ºÍøÂç¹ÒÆð-----------------------------------------------//
2959   3                              devTips_nwkZigb = nwkZigb_hold;
2960   3                              function_devNwkHold();
2961   3                              
2962   3                      }break;
2963   2                              
2964   2                      default:{
2965   3                      
2966   3                              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
2967   4                              
2968   4                                      devStatus_switch.statusChange_IF = 0;
2969   4                                      devRunning_Status = devStatus_switch.statusChange_standBy;
2970   4                                      
2971   4                                      break;
2972   4                              }
2973   3                      
2974   3                      }break;
2975   2              }
2976   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10176    ----
   CONSTANT SIZE    =   3913    ----
   XDATA SIZE       =    364    1144
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9     144
   IDATA SIZE       =   ----      10
   BIT SIZE         =      8      17
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
