C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DATATRANS
OBJECT MODULE PLACED IN .\Output\dataTrans.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE dataTrans\dataTrans.c OMF2 ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(
                    -.\Usr;.\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\dataTrans.lst) OBJECT(.\Out
                    -put\dataTrans.obj)

line level    source

   1          #include "dataTrans.h"
   2          
   3          #include "string.h"
   4          #include "stdio.h"
   5          
   6          #include "eeprom.h"
   7          #include "USART.h"
   8          #include "delay.h"
   9          #include "Relay.h"
  10          
  11          #include "timerAct.h"
  12          #include "pars_Method.h"
  13          #include "dataManage.h"
  14          #include "Tips.h"
  15          
  16          /**********************±¾µØÎÄ¼þ±äÁ¿¶¨ÒåÇø************************/
  17          datsAttr_datsTrans xdata datsSend_request;//Ô¶¶ËÊý¾Ý´«ÊäÇëÇó»º´æ
  18          datsAttr_datsTrans xdata datsRcv_respond;//Ô¶¶ËÊý¾Ý´«ÊäÇëÇóµÈ´ýÏìÓ¦»º´æ»º´æ
  19          
  20          //zigbeeÔËÐÐ×´Ì¬ÇÐ»»±êÖ¾
  21          stt_statusChange xdata devStatus_switch = {0, status_NULL};
  22          //Êý¾ÝÇëÇóÍê³ÉºóÊÇ·ñÐèÒªÖØÆôÍøÂç
  23          bit reConnectAfterDatsReq_IF = 0; //ÓÃÓÚ»¥¿ØÍ¨Ñ¶´Ø¼´¿Ì×¢²áÌØÊâÇé¿öÏÂÊ¹ÓÃ
  24          
  25          bit coordinatorOnline_IF = 0; //Ð­µ÷Æ÷ÔÚÏß±êÖ¾
  26          
  27          //zigbÍøÂç¶¯×÷×¨ÓÃÊ±¼ä¼ÆÊý
  28          u16 xdata zigbNwkAction_counter = 0;
  29          
  30          //zigbÉè±¸ÍøÂç¹ÒÆðÊôÐÔ²ÎÊý
  31          attr_devNwkHold xdata devNwkHoldTime_Param = {0};
  32          
  33          //ÐÄÌø
  34          bit heartBeatCycle_FLG = 0;     //ÐÄÌøÖÜÆÚ´¥·¢
  35          u8      heartBeatCount     = 0; //ÐÄÌøÖÜÆÚ¼ÆÊý
  36          
  37          //´®¿Ú½ÓÊÕ³¬Ê±±êÖ¾
  38          bit uartRX_toutFLG      = 0;
  39          //´®¿Ú½ÓÊÕ³¬Ê±¼ÆÊý
  40          bit rxTout_count_EN = 0;
  41          u8  rxTout_count        = 0;
  42          //´®¿ÚÊý¾Ý»º´æ
  43          u8      datsRcv_length  = 0;
  44          uartTout_datsRcv xdata datsRcv_ZIGB = {{0}, 0};
  45          
  46          //zigbeeÍ¨ÐÅÏß³Ìµ±Ç°ÔËÐÐ×´Ì¬±êÖ¾
  47          threadRunning_Status devRunning_Status = status_NULL;
  48          
  49          void zigbUart_pinInit(void){
  50   1      
  51   1              //TXÍÆÍìÊä³ö
  52   1              P3M1 &= 0xFD;   
  53   1              P3M0 |= 0x02;   
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 2   

  54   1              
  55   1              //RX¸ß×èÊäÈë
  56   1              P3M1 |= 0x01;
  57   1              P3M0 &= 0xFE;
  58   1              
  59   1              //TXÍÆÍìÊä³ö
  60   1              P2M1 &= ~0x08;
  61   1              P2M0 |= 0x08;
  62   1      }
  63                  
  64          /*--------------------------------------------------------------*/
  65          void uartObjZigb_Init(void){
  66   1      
  67   1              EA = 0;
  68   1      
  69   1              PS = 1;
  70   1              SCON = (SCON & 0x3f) | UART_8bit_BRTx;
  71   1      
  72   1      {
  73   2              u32 j = (MAIN_Fosc / 4) / ZIGB_BAUND;   //°´1T¼ÆËã
  74   2                      j = 65536UL - j;
  75   2              
  76   2              TH2 = (u8)(j>>8);
  77   2              TL2 = (u8)j;
  78   2      }
  79   1              AUXR &= ~(1<<4);        //Timer stop
  80   1              AUXR |= 0x01;           //S1 BRT Use Timer2;
  81   1              AUXR &= ~(1<<3);        //Timer2 set As Timer
  82   1              AUXR |=  (1<<2);        //Timer2 set as 1T mode
  83   1      
  84   1              IE2  &= ~(1<<2);        //½ûÖ¹ÖÐ¶Ï
  85   1              AUXR &= ~(1<<3);        //¶¨Ê±
  86   1              AUXR |=  (1<<4);        //Timer run enable
  87   1      
  88   1              ES        = 1;
  89   1              REN   = 1;
  90   1              P_SW1 = (P_SW1 & 0x3f) | (UART1_SW_P30_P31 & 0xc0);
  91   1              
  92   1              memset(TX1_Buffer, 0, sizeof(char) * COM_TX1_Lenth);
  93   1      
  94   1              EA = 1;
  95   1      
  96   1              PrintString1("i'm UART1 for wifi data translate !!!\n");
  97   1              PrintString1_logOut("i'm UART1 for datsLog !!!\n");
  98   1      }
  99          
 100          ///*----------------------------
 101          //·¢ËÍ´®¿ÚÊý¾Ý
 102          //----------------------------*/
 103          //void uartObjWIFI_Send_Byte(u8 dat)    //´®¿Ú1
 104          //{
 105          //      TX1_write2buff(dat);
 106          //}
 107          
 108          //void uartObjWIFI_Send_String(char *s,unsigned char ucLength){  //´®¿Ú1
 109          //      
 110          //      uart1_datsSend(s, ucLength);
 111          //}
 112          
 113          //void rxBuff_WIFI_Clr(void){
 114          
 115          //      memset(rxBuff_WIFI, 0xff, sizeof(char) * COM_RX1_Lenth);
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 3   

 116          //      COM1.RX_Cnt = 0;
 117          //}
 118          
 119          /********************* UART1(WIIF)ÖÐ¶Ïº¯Êý_×Ô¶¨ÒåÖØ¹¹************************/
 120          void UART1_Rountine (void) interrupt UART1_VECTOR
 121          {
 122   1              
 123   1              if(RI)
 124   1              {
 125   2                      RI = 0;
 126   2                      if(COM1.B_RX_OK == 0)
 127   2                      {
 128   3                              
 129   3      //                      if(COM1.RX_Cnt >= COM_RX1_Lenth)        COM1.RX_Cnt = 0;
 130   3      //                      RX1_Buffer[COM1.RX_Cnt++] = SBUF;
 131   3      //                      COM1.RX_TimeOut = TimeOutSet1;
 132   3                              
 133   3                              if(!rxTout_count_EN){
 134   4                              
 135   4                                      rxTout_count_EN = 1;
 136   4                                      rxTout_count    = 0;
 137   4                                      datsRcv_length  = 0;
 138   4                                      
 139   4                                      memset(RX1_Buffer, 0xff, sizeof(char) * COM_RX1_Lenth);
 140   4                              }
 141   3                              
 142   3                              
 143   3                              RX1_Buffer[datsRcv_length ++]   = SBUF;
 144   3                              rxTout_count = 0;
 145   3                      }
 146   2              }
 147   1      
 148   1              if(TI)
 149   1              {
 150   2                      TI = 0;
 151   2                      if(COM1.TX_read != COM1.TX_write)
 152   2                      {
 153   3                              SBUF = TX1_Buffer[COM1.TX_read];
 154   3                              if(++COM1.TX_read >= COM_TX1_Lenth)             COM1.TX_read = 0;
 155   3                      }
 156   2                      else    COM1.B_TX_busy = 0;
 157   2              }
 158   1      }
 159          
 160          /* ×Ô¶¨ÒåÐ£Ñé*///×Ô¼Ò²úÆ·Ð­Òé²ã
 161          static 
 162          unsigned char frame_Check(unsigned char frame_temp[], u8 check_num){
 163   1        
 164   1              unsigned char loop              = 0;
 165   1              unsigned char val_Check = 0;
 166   1              
 167   1              for(loop = 0; loop < check_num; loop ++){
 168   2              
 169   2                      val_Check += frame_temp[loop];
 170   2              }
 171   1              
 172   1              val_Check  = ~val_Check;
 173   1              val_Check ^= 0xa7;
 174   1              
 175   1              return val_Check;
 176   1      }
 177          
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 4   

 178          /*´ËÊý¾Ý·â×°±ØÐëÔÚÊý¾Ý°ü·¢ËÍÇ°×îºóµ÷ÓÃ£¬×Ô¶¨Òå¶ÔÏó½øÐÐÊý¾Ý·â×°*///±ÜÃâÐ£Ñé±»ÌáÇ°¶ø³ö´í
 179          static 
 180          u8 dtasTX_loadBasic_CUST(bit ifRemoteDats,
 181                                                       u8 dats_Tx[],
 182                                                       u8 datsLen_TX,
 183                                                       u8 frame_Type,
 184                                                       u8 frame_CMD,
 185                                                       bit ifSpecial_CMD){
 186   1                                                         
 187   1              dats_Tx[2]      = frame_Type;
 188   1              dats_Tx[3]      = frame_CMD;
 189   1              
 190   1              if(!ifSpecial_CMD)dats_Tx[10] = SWITCH_TYPE;    //¿ª¹ØÀàÐÍÌî³ä
 191   1              
 192   1              memcpy(&dats_Tx[5], &MAC_ID[1], 5);     //MACÌî³ä
 193   1                                                        
 194   1              dats_Tx[4]      = frame_Check(&dats_Tx[5], 28);
 195   1                                                                 
 196   1              if(ifRemoteDats){
 197   2                      
 198   2                      u8 xdata dats_Temp[64] = {0};
 199   2              
 200   2                      dats_Tx[0] = ZIGB_FRAMEHEAD_CTRLREMOTE;
 201   2                      dats_Tx[1]      = datsLen_TX + 12;
 202   2                      
 203   2                      memcpy(dats_Temp, &dats_Tx[1], datsLen_TX - 13);
 204   2                      memset(&dats_Tx[1], 0, datsLen_TX - 1);
 205   2                      memcpy(&dats_Tx[13], dats_Temp, datsLen_TX - 13);
 206   2                      memcpy(&dats_Tx[1], MAC_ID_DST, 6);
 207   2                      memcpy(&dats_Tx[8], &MAC_ID[1], 5);
 208   2                      
 209   2                      return 45;
 210   2                      
 211   2              }else{
 212   2              
 213   2                      dats_Tx[0]      = ZIGB_FRAMEHEAD_CTRLLOCAL;
 214   2                      dats_Tx[1]      = datsLen_TX;
 215   2                      
 216   2                      return 33;
 217   2              }
 218   1      }
 219          
 220          /*Êý¾ÝÒì»òÐ£Ñé*///ZNPÐ­Òé²ã
 221          static 
 222          u8 XORNUM_CHECK(u8 buf[], u8 length){
 223   1      
 224   1              u8 loop = 0;
 225   1              u8 valXOR = buf[0];
 226   1              
 227   1              for(loop = 1;loop < length;loop ++)valXOR ^= buf[loop];
 228   1              
 229   1              return valXOR;
 230   1      }
 231          
 232          /*zigbeeÊý¾ÝÖ¡¼ÓÔØ*/
 233          static 
 234          u8 ZigB_TXFrameLoad(u8 frame[],u8 cmd[],u8 cmdLen,u8 dats[],u8 datsLen){                
 235   1      
 236   1              const u8 frameHead = ZIGB_FRAME_HEAD;   //ZNP,SOFÖ¡Í·
 237   1              u8 xor_check = datsLen;                                 //Òì»òÐ£Ñé£¬Ö¡Î²
 238   1              u8 loop = 0;
 239   1              u8 ptr = 0;
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 5   

 240   1              
 241   1              frame[ptr ++] = frameHead;
 242   1              frame[ptr ++] = datsLen;
 243   1              
 244   1              memcpy(&frame[ptr],cmd,cmdLen);
 245   1              ptr += cmdLen;
 246   1              for(loop = 0;loop < cmdLen;loop ++)xor_check ^= cmd[loop];
 247   1      
 248   1              memcpy(&frame[ptr],dats,datsLen);
 249   1              ptr += datsLen;
 250   1              for(loop = 0;loop < datsLen;loop ++)xor_check ^= dats[loop];    
 251   1              
 252   1              frame[ptr ++] = xor_check;
 253   1              
 254   1              return ptr;
 255   1      }
 256          
 257          /*zigbeeµ¥Ö¸ÁîÊý¾ÝÇëÇó£¬·µ»ØÓ¦´ðÊý¾Ý³¤¶È*/
 258          static 
 259          u8 zigb_datsRequest( u8 frameREQ[],             //ÇëÇóÖ¡
 260                                                   u8 frameREQ_Len,       //ÇëÇóÖ¡³¤
 261                                                   u8 resp_cmd[2],        //ËùÐèÓ¦´ðÖ¸Áî
 262                                                   u8 resp_dats[],        //Ó¦´ðÊý¾Ý»º´æ
 263                                                   u8 loopReapt,u16 timeWait){    //Ñ­»·´ÎÊý£¬µ¥´ÎµÈ´ýÊ±¼ä
 264   1                                                
 265   1              u16 Local_Delay = timeWait;             
 266   1              u8      loop = 0;
 267   1                                                       
 268   1              for(loop = 0;loop < loopReapt;loop ++){
 269   2              
 270   2                      uartRX_toutFLG = 0;
 271   2                      zigbNwkAction_counter = timeWait;       
 272   2                  uartZigB_datsSend(frameREQ, frameREQ_Len);
 273   2                      
 274   2                      while(zigbNwkAction_counter){ //¶¨Ê±Æ÷ÖÐ¶ÏÄÚ½øÐÐµ¹¼ÆÊ±
 275   3      
 276   3                              if(uartRX_toutFLG){
 277   4                              
 278   4                                      uartRX_toutFLG = 0;
 279   4                                      
 280   4                                      if(!memcmp(&(datsRcv_ZIGB.rcvDats[2]), resp_cmd, 2)){
 281   5                                      
 282   5                                              memcpy(resp_dats, datsRcv_ZIGB.rcvDats, datsRcv_ZIGB.rcvDatsLen);
 283   5                                              return datsRcv_ZIGB.rcvDatsLen;
 284   5                                              
 285   5                                      }
 286   4                              }
 287   3                      }
 288   2              }       
 289   1      
 290   1              return 0;
 291   1      }
 292          
 293          /*zigbeeµ¥Ö¸ÁîÏÂ·¢¼°ÏìÓ¦ÑéÖ¤*///×èÈû
 294          bit zigb_VALIDA_INPUT(u8 REQ_CMD[2],            //Ö¸Áî
 295                                                    u8 REQ_DATS[],                //Êý¾Ý
 296                                                    u8 REQdatsLen,                //Êý¾Ý³¤¶È
 297                                                    u8 ANSR_frame[],              //ÏìÓ¦Ö¡
 298                                                    u8 ANSRdatsLen,               //ÏìÓ¦Ö¡³¤¶È
 299                                                    u8 times,u16 timeDelay){      //Ñ­»·´ÎÊý£¬µ¥´ÎµÈ´ýÊ±¼ä
 300   1                                                 
 301   1      #define dataLen_validaInput     96
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 6   

 302   1              u8 xdata dataTXBUF[dataLen_validaInput] = {0};
 303   1              u8      loop = 0;
 304   1              u8      datsTX_Len;
 305   1      
 306   1              datsTX_Len = ZigB_TXFrameLoad(dataTXBUF,REQ_CMD, 2, REQ_DATS, REQdatsLen);
 307   1      
 308   1              for(loop = 0;loop < times;loop ++){
 309   2              
 310   2                      uartRX_toutFLG = 0;
 311   2                      zigbNwkAction_counter = timeDelay;
 312   2                      uartZigB_datsSend(dataTXBUF, datsTX_Len);
 313   2                      
 314   2                      while(zigbNwkAction_counter){ //¶¨Ê±Æ÷ÖÐ¶ÏÄÚ½øÐÐµ¹¼ÆÊ±
 315   3                              
 316   3                              if(uartRX_toutFLG){
 317   4                              
 318   4                                      uartRX_toutFLG = 0;
 319   4                                      
 320   4                                      if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ANSR_frame, ANSRdatsLen)){
 321   5                                      
 322   5                                              delayMs(2);
 323   5                                              return 1;
 324   5                                      }
 325   4                              }
 326   3                      }
 327   2              }
 328   1              
 329   1              return 0;
 330   1      }
 331          
 332          ///*zigbeeÍ¨ÐÅ´ØÉèÖÃ*///×èÈû
 333          //bit zigb_clusterSet(u16 deviveID, u8 endPoint){
 334          
 335          //      datsAttr_ZigbInit code default_param = {{0x24,0x00},{0x0E,0x0D,0x00,0x0D,0x00,0x0D,0x00,0x01,0x00,0x00,
             -0x01,0x00,0x00},0x0D,{0xFE,0x01,0x64,0x00,0x00,0x65},0x06,300};       //Êý¾Ý´Ø×¢²á,Ä¬ÈÏ²ÎÊý
 336          //      u8 code frameResponse_Subs[6] = {0xFE,0x01,0x64,0x00,0xB8,0xDD}; //ÏìÓ¦Ö¡Ìæ²¹£¬ÈôÊý¾Ý´ØÒÑ¾­×¢²á
 337          //              
 338          //#define       dataLen_zigbClusterSet  64
 339          //      u8 xdata paramTX_temp[dataLen_zigbClusterSet] = {0};
 340          //      
 341          //      bit setResult = 0;
 342          //      
 343          //      memcpy(paramTX_temp, default_param.zigbInit_reqDAT, default_param.reqDAT_num);
 344          //      paramTX_temp[0] = endPoint;
 345          //      paramTX_temp[3] = (u8)((deviveID & 0x00ff) >> 0);
 346          //      paramTX_temp[4] = (u8)((deviveID & 0xff00) >> 8);
 347          //      
 348          //      setResult =  zigb_VALIDA_INPUT( (u8 *)default_param.zigbInit_reqCMD,
 349          //                                                                      (u8 *)paramTX_temp,
 350          //                                                                      default_param.reqDAT_num,
 351          //                                                                      (u8 *)default_param.zigbInit_REPLY,
 352          //                                                                      default_param.REPLY_num,
 353          //                                                                      2,              //2´ÎÒÔÄÚÃ»ÓÐÕýÈ·ÏìÓ¦¾ÍÊ§°Ü
 354          //                                                                      default_param.timeTab_waitAnsr);
 355          //      
 356          //      if(setResult)return setResult;
 357          //      else{
 358          //      
 359          //              return zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 360          //                                                               (u8 *)paramTX_temp,
 361          //                                                               default_param.reqDAT_num,
 362          //                                                               (u8 *)frameResponse_Subs,
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 7   

 363          //                                                               6,
 364          //                                                               2,             //2´ÎÒÔÄÚÃ»ÓÐÕýÈ·ÏìÓ¦¾ÍÊ§°Ü
 365          //                                                               default_param.timeTab_waitAnsr);
 366          //      }
 367          //}
 368          
 369          ///*zigbeeÖØÐÂÈëÍø*///×èÈûº¯Êý£¬½ö¹©²âÊÔÊ¹ÓÃ
 370          //bit ZigB_NwkJoin(u16 PANID, u8 CHANNELS){
 371          
 372          //#define       cmdNum_zigbNwkJoin      8       
 373          //      
 374          //#define        loop_PANID             5
 375          //#define        loop_CHANNELS  6
 376          
 377          //      datsAttr_ZigbInit code ZigbInit_dats[cmdNum_zigbNwkJoin] = {
 378          //              
 379          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¸´Î»
 380          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¸´Î»
 381          //              {       {0x26,0x05},    {0x03,0x01,0x03},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //¼Ä´æÆ÷³
             -õÊ¼»¯£¬È«²¿Çå¿Õ
 382          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¶þ´Î¸´Î»
 383          //              
 384          ////            {       {0x26,0x05},    {0x87,0x01,0x00},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«É
             -èÖÃ£¨Ð­µ÷Æ÷£©
 385          //              {       {0x26,0x05},    {0x87,0x01,0x01},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨Â·ÓÉÆ÷£©
 386          ////            {       {0x26,0x05},    {0x87,0x01,0x02},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«É
             -èÖÃ£¨ÖÕ¶Ë£©
 387          //              
 388          //              {       {0x27,0x02},    {0x34,0x12},                    0x02,   {0xFE,0x01,0x67,0x02,0x00,0x64},                                                        0x06,   500             },      //PAN_ID¼Ä´æÆ
             -÷ÉèÖÃ
 389          //              {       {0x27,0x03},    {0x00,0x80,0x00,0x00},  0x04,   {0xFE,0x01,0x67,0x03,0x00,0x65},                                                        0x06,   500             },      //ÐÅµ
             -À¼Ä´æÆ÷ÅäÖÃ
 390          ////            {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x09,0x8D},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È
             -¶¨½ÇÉ«Ð­µ÷Æ÷£¨Ð­µ÷Æ÷ÏìÓ¦£©
 391          //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x07,0x83},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨Â·ÓÉÆ÷ÏìÓ¦£©
 392          ////            {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x06,0x82},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È
             -¶¨½ÇÉ«Ð­µ÷Æ÷£¨ÖÕ¶ËÏìÓ¦£©
 393          //      };
 394          //      
 395          //#define       dataLen_zigbNwkJoin 64
 396          //      u8 xdata paramTX_temp[dataLen_zigbNwkJoin] = {0};
 397          //      
 398          //      u8  loop;
 399          //      u32 chnl_temp = 0x00000800UL << CHANNELS;
 400          //      
 401          //      for(loop = 1; loop < cmdNum_zigbNwkJoin; loop ++){
 402          //              
 403          //              memset(paramTX_temp, 0, dataLen_zigbNwkJoin * sizeof(u8));
 404          //              
 405          //              switch(loop){   //×ÔÑ¡²ÎÊý&Ä¬ÈÏ²ÎÊý
 406          //              
 407          //                      case loop_PANID:{
 408          //                      
 409          //                              paramTX_temp[0] = (u8)((PANID & 0x00ff) >> 0);
 410          //                              paramTX_temp[1] = (u8)((PANID & 0xff00) >> 8);
 411          //                              
 412          //                      }break;
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 8   

 413          //                      
 414          //                      case loop_CHANNELS:{
 415          //                      
 416          //                              paramTX_temp[0] = (u8)((chnl_temp & 0x000000ff) >>  0);
 417          //                              paramTX_temp[1] = (u8)((chnl_temp & 0x0000ff00) >>  8);
 418          //                              paramTX_temp[2] = (u8)((chnl_temp & 0x00ff0000) >> 16);
 419          //                              paramTX_temp[3] = (u8)((chnl_temp & 0xff000000) >> 24);
 420          //                              
 421          //                      }break;
 422          //                      
 423          //                      default:{
 424          //                      
 425          //                              memcpy(paramTX_temp,ZigbInit_dats[loop].zigbInit_reqDAT,ZigbInit_dats[loop].reqDAT_num);
 426          //                              
 427          //                      }break;
 428          //              }
 429          //      
 430          //              delayMs(100);
 431          //              if(0 == zigb_VALIDA_INPUT((u8 *)ZigbInit_dats[loop].zigbInit_reqCMD,
 432          //                                                                (u8 *)paramTX_temp,
 433          //                                                                ZigbInit_dats[loop].reqDAT_num,
 434          //                                                                (u8 *)ZigbInit_dats[loop].zigbInit_REPLY,
 435          //                                                                ZigbInit_dats[loop].REPLY_num,
 436          //                                                                3,
 437          //                                                                ZigbInit_dats[loop].timeTab_waitAnsr)
 438          //                                                               )loop = 0;
 439          //      }
 440          //      
 441          //      return zigb_clusterSet(13, 13); //Éè±¸ID 13£¬ÖÕ¶Ëµã 13£»
 442          //}
 443          
 444          /*zigbee Ö÷¶¯¿ª·ÅÍøÂç*///×èÈû
 445          bit ZigB_nwkOpen(bit openIF, u8 openTime){
 446   1      
 447   1              datsAttr_ZigbInit code default_param = {{0x26,0x08}, {0xFC,0xFF,0x00}, 0x03, {0xFE,0x01,0x66,0x08,0x00,0x
             -6F}, 0x06, 150}; //zigbeeÖ¸ÁîÏÂ´ïÄ¬ÈÏ²ÎÊý
 448   1              
 449   1              bit resultSet = 0;
 450   1              
 451   1              u8 openTime_temp = 0;
 452   1              
 453   1      #define paramLen_zigbNwkOpen 3
 454   1              u8 xdata paramTX_temp[paramLen_zigbNwkOpen] = {0xFC,0xFF,0x00};
 455   1              
 456   1              (openIF)?(paramTX_temp[2] = openTime):(paramTX_temp[2] = 0);
 457   1              
 458   1              resultSet = zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 459   1                                                                        (u8 *)paramTX_temp,
 460   1                                                                        default_param.reqDAT_num,
 461   1                                                                        (u8 *)default_param.zigbInit_REPLY,
 462   1                                                                        default_param.REPLY_num,
 463   1                                                                        2,    //2´ÎÎÞ»Ø¸´ÎªÊ§°Ü
 464   1                                                                        default_param.timeTab_waitAnsr);
 465   1      
 466   1      #if(DEBUG_LOGOUT_EN == 1)       
 467   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 468   1      //              u8 xdata log_buf[64];
 469   1      //              
 470   1      //              sprintf(log_buf, "nwkOpen result:%d.\n", (int)resultSet);
 471   1      //              PrintString1_logOut(log_buf);
 472   1      //      }
 473   1      #endif
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 9   

 474   1              
 475   1              return resultSet;
 476   1      }
 477          
 478          /*zigbee PANID»ñÈ¡*///×èÈû
 479          static u16 ZigB_getPanIDCurrent(void){
 480   1      
 481   1              u16 PANID_temp = 0;
 482   1              
 483   1      #define paramLen_zigbPanIDGet 32
 484   1              u8 xdata paramTX_temp[paramLen_zigbPanIDGet] = {0};
 485   1              
 486   1              u8 code frameREQ_zigbPanIDGet[6] = {0xFE, 0x01, 0x26, 0x06, 0x06, 0x27};        //zigb PANID»ñÈ¡Ö¸ÁîÖ¡
 487   1              u8 code cmdResp_zigbPanIDGet[2]  = {0x66, 0x06};        //zigb PANID»ñÈ¡Ô¤ÆÚÏìÓ¦Ö¸Áî
 488   1              u8 datsResp_Len = 0;
 489   1      
 490   1              datsResp_Len = zigb_datsRequest(frameREQ_zigbPanIDGet, 6, cmdResp_zigbPanIDGet, paramTX_temp, 2, 300);
 491   1      
 492   1              if(datsResp_Len){
 493   2      
 494   2                      PANID_temp |= (((u16)(paramTX_temp[5]) << 0) & 0x00FF);
 495   2                      PANID_temp |= (((u16)(paramTX_temp[6]) << 8) & 0xFF00);
 496   2      
 497   2      //              printf_datsHtoA("[Tips_uartZigb]: resultDats:", local_datsParam->frameResp, local_datsParam->frameResp
             -Len);
 498   2              }
 499   1      
 500   1              return PANID_temp;
 501   1      }
 502          
 503          /*zigbeeÏµÍ³Ê±¼ä»ñÈ¡²¢¸üÐÂ*///×èÈû
 504          static bit getSystemTime_reales(void){
 505   1              
 506   1              bit resultOpreat = 0;
 507   1      
 508   1      #define paramLen_zigbSystimeGet 32
 509   1              u8 xdata paramTX_temp[paramLen_zigbSystimeGet] = {0};
 510   1              
 511   1              u8 code frameREQ_zigbSystimeGet[5] = {0xFE, 0x00, 0x21, 0x11, 0x30};    //zigb PANID»ñÈ¡Ö¸ÁîÖ¡
 512   1              u8 code cmdResp_zigbSystimeGet[2]  = {0x61, 0x11};      //zigb PANID»ñÈ¡Ô¤ÆÚÏìÓ¦Ö¸Áî
 513   1              u8 datsResp_Len = 0;
 514   1      
 515   1              datsResp_Len = zigb_datsRequest(frameREQ_zigbSystimeGet, 5, cmdResp_zigbSystimeGet, paramTX_temp, 2, 300)
             -;
 516   1              
 517   1              if(!datsResp_Len)resultOpreat = 0;
 518   1              else{
 519   2                      
 520   2                      u16 Y_temp16 = ((u16)paramTX_temp[13] << 0) | ((u16)paramTX_temp[14] << 8);
 521   2                      u8  Y_temp8 = 0;
 522   2                      u8  M_temp8 = 0;
 523   2                      
 524   2                      u8 Y = (u8)(Y_temp16 % 2000);
 525   2                      u8 M = paramTX_temp[11];
 526   2                      u8 D = paramTX_temp[12];
 527   2                      u8 W = 0;
 528   2                      
 529   2                      /*¼ÆËã»º´æ¸³Öµ*/
 530   2                      Y_temp8 = Y;
 531   2                      if(M == 1 || M == 2){ //Ò»ÔÂºÍ¶þÔÂµ±×÷ÉÏÒ»ÄêÊ®ÈýÔÂºÍÊ®ËÄÔÂ
 532   3                      
 533   3                              M_temp8 = M + 12;
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 10  

 534   3                              Y_temp8 --;
 535   3                      }
 536   2                      else M_temp8 = M;
 537   2                      
 538   2                      /*¿ªÊ¼¼ÆËã*/
 539   2                      W =      Y_temp8 + (Y_temp8 / 4) + 5 - 40 + (26 * (M_temp8 + 1) / 10) + D - 1;  //²ÌÀÕ¹«Ê½
 540   2                      W %= 7; 
 541   2                      
 542   2                      /*¼ÆËã½á¹û¸³Öµ*/
 543   2                      W?(systemTime_current.time_Week = W):(systemTime_current.time_Week = 7);
 544   2                      
 545   2                      systemTime_current.time_Month =         M;
 546   2                      systemTime_current.time_Day =           D;
 547   2                      systemTime_current.time_Year =          Y;
 548   2                      
 549   2                      systemTime_current.time_Hour =          paramTX_temp[8];
 550   2                      systemTime_current.time_Minute =        paramTX_temp[9];
 551   2                      systemTime_current.time_Second =        paramTX_temp[10];
 552   2                      
 553   2                      /*±¾µØÊ±¼äÎ¬³Ö¼ÆÊýÖµÐ£×¼¸üÐÂ*/
 554   2                      sysTimeKeep_counter = systemTime_current.time_Minute * 60 + systemTime_current.time_Second; //ÏµÍ³Ê±¼äÎ¬
             -³Ö¼ÆÊýÖµ¸üÐÂ
 555   2                      
 556   2                      resultOpreat = 1;
 557   2              }
 558   1              
 559   1      #if(DEBUG_LOGOUT_EN == 1)       
 560   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 561   1      //              u8 xdata log_buf[64];
 562   1      //              
 563   1      //              sprintf(log_buf, "sysTime reales result:%d.\n", (int)resultOpreat);
 564   1      //              PrintString1_logOut(log_buf);
 565   1      //      }
 566   1      #endif
 567   1              
 568   1              return resultOpreat;
 569   1      }
 570          
 571          /*zigbeeÏµÍ³Ê±¼äÉèÖÃ*///×èÈû
 572          static
 573          bit zigB_sysTimeSet(u32 timeStamp, bit timeZoneAdjust_IF){
 574   1      
 575   1              datsAttr_ZigbInit code default_param = {{0x21,0x10},{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
             -00},0x0B,{0xFE,0x01,0x61,0x10,0x00},0x05,100}; //zigbeeÖ¸ÁîÏÂ´ïÄ¬ÈÏ²ÎÊý
 576   1              u8 xdata timeStampArray[0x0B] = {0};
 577   1              bit resultSet = 0;
 578   1              u32 timeStamp_temp = timeStamp;
 579   1              
 580   1              if(timeZoneAdjust_IF){ //ÊÇ·ñÐèÒªÊ±Çøµ÷Õû
 581   2              
 582   2                      if(sysTimeZone_H <= 12){
 583   3                      
 584   3                              timeStamp_temp += (3600UL * (long)sysTimeZone_H + 60UL * (long)sysTimeZone_M); //Ê±ÇøÕý
 585   3                              
 586   3                      }else
 587   2                      if(sysTimeZone_H > 12 && sysTimeZone_H <= 24){
 588   3                      
 589   3                              timeStamp_temp -= (3600UL * (long)(sysTimeZone_H - 12) + 60UL * (long)sysTimeZone_M); //Ê±Çø¸º
 590   3                              
 591   3                      }else
 592   2                      if(sysTimeZone_H >= 30){
 593   3                      
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 11  

 594   3                              timeStamp_temp += (3600UL * (long)(sysTimeZone_H - 17) + 60UL * (long)sysTimeZone_M); //Ê±ÇøÌØÊâ
 595   3                      }
 596   2              }
 597   1      
 598   1              timeStampArray[0] = (u8)((timeStamp_temp & 0x000000ff) >> 0);
 599   1              timeStampArray[1] = (u8)((timeStamp_temp & 0x0000ff00) >> 8);
 600   1              timeStampArray[2] = (u8)((timeStamp_temp & 0x00ff0000) >> 16);
 601   1              timeStampArray[3] = (u8)((timeStamp_temp & 0xff000000) >> 24);
 602   1              
 603   1              resultSet = zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 604   1                                                                        (u8 *)timeStampArray,
 605   1                                                                        default_param.reqDAT_num,
 606   1                                                                        (u8 *)default_param.zigbInit_REPLY,
 607   1                                                                        default_param.REPLY_num,
 608   1                                                                        2,    //2´ÎÎÞ»Ø¸´ÎªÊ§°Ü
 609   1                                                                        default_param.timeTab_waitAnsr);
 610   1              
 611   1      #if(DEBUG_LOGOUT_EN == 1)       
 612   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 613   1      //              u8 xdata log_buf[64];
 614   1      //              
 615   1      //              sprintf(log_buf, "sysTime set result:%d.\n", (int)resultSet);
 616   1      //              PrintString1_logOut(log_buf);
 617   1      //      }
 618   1      #endif
 619   1              
 620   1              return resultSet;
 621   1      }
 622          
 623          ///*zigbeeÓ²¼þ¸´Î»³õÊ¼»¯*///×èÈû
 624          //bit ZigB_resetInit(void){
 625          
 626          //#define zigbInit_loopTry              3
 627          //#define zigbInit_onceWait     5000
 628          
 629          //      u8 code initCmp_Frame[11] = {0xFE, 0x06, 0x41, 0x80, 0x01, 0x02, 0x00, 0x02, 0x06, 0x03, 0xC3};
 630          //      
 631          //      u8      loop = 0;
 632          //      u16 timeWait = 0;
 633          //      
 634          //      for(loop = 0; loop < zigbInit_loopTry; loop ++){
 635          //      
 636          //              zigbPin_RESET = 0;
 637          //              delayMs(100);
 638          //              zigbPin_RESET = 1;
 639          //              
 640          //              timeWait = zigbInit_onceWait;
 641          //              while(timeWait --){
 642          //              
 643          //                      delayMs(2);     //±ØÐëÑÓÊ±
 644          //                      if(uartRX_toutFLG){
 645          //                      
 646          //                              uartRX_toutFLG = 0;
 647          //                              
 648          //                              if(!memcmp(datsRcv_ZIGB.rcvDats, initCmp_Frame, 11)){
 649          //                              
 650          //                                      return 1;
 651          //                                      
 652          //                              }else{
 653          //                                      
 654          //                                      delayMs(1);     //±ØÐëÑÓÊ±
 655          //                              }
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 12  

 656          //                      }
 657          //              }
 658          //      }
 659          //      
 660          //      return 0;
 661          //}
 662          
 663          ///*zigbee³õÊ¼»¯×Ô¼ì*///×èÈû
 664          //bit ZigB_inspectionSelf(void){        
 665          //      
 666          //#define       paramLen_zigbInspection 64
 667          //      u8 xdata paramTX_temp[paramLen_zigbInspection] = {0};
 668          //      
 669          ////    bit REQResult = 0;
 670          //      
 671          ////    u8 code frameREQ_zigbStatusCheck[5] = {0xFE, 0x00, 0x27, 0x00, 0x27};   //zigb×´Ì¬²éÑ¯Ö¸ÁîÖ¡
 672          ////    u8 code cmdResp_zigbStatusCheck[2]      = {0x67, 0x00}; //zigb×´Ì¬²éÑ¯ÏìÓ¦Ö¸Áî
 673          //      u8 code frameREQ_zigbJoinNWK[5]         = {0xFE, 0x00, 0x26, 0x00, 0x26};       //zigb¼¤»îÍøÂçÖ¸ÁîÖ¡
 674          //      u8 code cmdResp_zigbJoinNWK[2]          = {0x45, 0xC0}; //zigb¼¤»îÍøÂçÏìÓ¦Ö¸Áî
 675          //      u8 datsResp_Len = 0;
 676          //      
 677          ////    datsResp_Len = zigb_datsRequest(frameREQ_zigbStatusCheck, 5, cmdResp_zigbStatusCheck, paramTX_temp, 2
             -, 500);
 678          ////    if(paramTX_temp[16] == 0x07)REQResult
 679          //      
 680          //      datsResp_Len = zigb_datsRequest(frameREQ_zigbJoinNWK, 5, cmdResp_zigbJoinNWK, paramTX_temp, 2, 5000);
 681          //      if(paramTX_temp[4] == 0x07)return (zigb_clusterSet(13, 13) & zigb_clusterSet(13, 14));  //Éè±¸ID 13£¬ÖÕ¶
             -Ëµã 13£»        
 682          //      else{
 683          //      
 684          //              return 0;
 685          //      }
 686          //}
 687          
 688          /*zigbee·Ç×èÈûÈëÍøÇëÇó×´Ì¬»ú*///·Ç×èÈû ---ÐÅµÀÄ¬ÈÏµÚËÄÐÅµÀ
 689          static 
 690          void zigB_nwkJoinRequest(bit reJoin_IF){
 691   1      
 692   1      #define cmdNum_zigbNwkREQ       9       
 693   1      
 694   1              datsAttr_ZigbInit code ZigbInit_dats[cmdNum_zigbNwkREQ] = {
 695   1      
 696   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¸´Î»(Ó²¼þ)
 697   1      //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x00,0x02,0x00,0x02,0x06,0x03,0xC2},       0x0B,   4000    },      
             -//¸´Î»(Ìæ²¹)
 698   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¸´Î»(Èí¼þ)
 699   1                      {       {0x26,0x05},    {0x03,0x01,0x03},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //¼Ä´æÆ÷³õÊ
             -¼»¯£¬È«²¿Çå¿Õ
 700   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¶þ´Î¸´Î»(Èí¼þ)
 701   1                      
 702   1      //              {       {0x26,0x05},    {0x87,0x01,0x00},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨Ð­µ÷Æ÷£©
 703   1                      {       {0x26,0x05},    {0x87,0x01,0x01},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖÃ£
             -¨Â·ÓÉÆ÷£©
 704   1      //              {       {0x26,0x05},    {0x87,0x01,0x02},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨ÖÕ¶Ë£©
 705   1                      
 706   1                      {       {0x27,0x02},    {0xFF,0xFF},                    0x02,   {0xFE,0x01,0x67,0x02,0x00,0x64},                                                        0x06,   500             },      //PAN_ID¼Ä´æÆ÷É
             -èÖÃ
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 13  

 707   1                      {       {0x27,0x03},    {0x00,0x80,0x00,0x00},  0x04,   {0xFE,0x01,0x67,0x03,0x00,0x65},                                                        0x06,   500             },      //ÐÅµÀ¼
             -Ä´æÆ÷ÅäÖÃ
 708   1      //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x09,0x8D},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨Ð­µ÷Æ÷ÏìÓ¦£©
 709   1                      {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x07,0x83},                                                        0x06,   8000    },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨½ÇÉ
             -«Ð­µ÷Æ÷£¨Â·ÓÉÆ÷ÏìÓ¦£©
 710   1      //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x06,0x82},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨ÖÕ¶ËÏìÓ¦£©
 711   1                      {       {0x26,0x08},    {0xFC,0xFF,0x00},               0x03,   {0xFE,0x01,0x66,0x08,0x00,0x6F},                                                        0x06,   150             },  //¹Ø±Õ
             -ÍøÂç
 712   1              };
 713   1              
 714   1              datsAttr_ZigbInit code defaultParam_clusterRegister = {{0x24,0x00},{0x0E,0x0D,0x00,0x0D,0x00,0x0D,0x00,0x
             -01,0x00,0x00,0x01,0x00,0x00},0x0D,{0xFE,0x01,0x64,0x00,0x00,0x65},0x06,500};  //Êý¾Ý´Ø×¢²á,Ä¬ÈÏ²ÎÊý
 715   1              u8 code frameResponseSubs_clusterRegister[6] = {0xFE,0x01,0x64,0x00,0xB8,0xDD}; //ÏìÓ¦Ö¡Ìæ²¹£¬ÈôÊý¾Ý´ØÒÑ¾
             -­×¢²á
 716   1              
 717   1      #define clusterNum_default 3
 718   1              datsAttr_clusterREG code cluster_Default[clusterNum_default] = {
 719   1              
 720   1                      {ZIGB_ENDPOINT_CTRLSECENARIO, zigbDatsDefault_ClustID}, 
 721   1                      {ZIGB_ENDPOINT_CTRLNORMAL, zigbDatsDefault_ClustID}, 
 722   1                      {ZIGB_ENDPOINT_CTRLSYSZIGB, zigbDatsDefault_ClustID}
 723   1              };
 724   1              
 725   1      #define dataLen_zigbNwkREQ 64
 726   1              u8 xdata paramTX_temp[dataLen_zigbNwkREQ] = {0};
 727   1              
 728   1              static u8 step_CortexA = 0,
 729   1                                step_CortexB = 0;
 730   1              static u8 reactionLoop = 0;
 731   1              
 732   1              u8 datsTX_Len = 0;
 733   1              
 734   1              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
 735   2              
 736   2                      devStatus_switch.statusChange_IF = 0;
 737   2                      devRunning_Status = devStatus_switch.statusChange_standBy;
 738   2                      
 739   2                      step_CortexA = 0;
 740   2                      step_CortexB = 0;
 741   2                      reactionLoop = 0;
 742   2                      zigbPin_RESET = 1;
 743   2                      
 744   2                      return;
 745   2              }
 746   1              
 747   1              if(step_CortexA > (cmdNum_zigbNwkREQ + clusterNum_usr + clusterNum_default)){ //ÄÚ²¿×´Ì¬Íê³É
 748   2              
 749   2                      step_CortexA = 0;
 750   2                      step_CortexB = 0;
 751   2                      reactionLoop = 0;
 752   2                      zigbPin_RESET = 1;
 753   2                      
 754   2                      sysTimeReales_counter = PERIOD_SYSTIMEREALES; //systime¸üÐÂÖÜÆÚÖØÖÃ£¬·ÀÖ¹¶àÖ¸Áî¶ÂÈû³åÍ»
 755   2                      
 756   2                      devRunning_Status = status_passiveDataRcv; //Íâ²¿×´Ì¬ÇÐ»»
 757   2                      devTips_status = status_Normal; //Éè±¸ÏµÍ³tips×´Ì¬ÇÐ»»
 758   2                      
 759   2                      return;
 760   2              }
 761   1              
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 14  

 762   1              if(!reJoin_IF)if(step_CortexA == 0)step_CortexA = 7; //ÊÇ·ñÎªÖØÐÂÖ÷¶¯¼ÓÈëÐÂÍøÂç£¬·ñÔò²»½øÐÐÓ²¼þ¸´Î»(Ó²¼þ¸
             -´Î»½«µ¼ÖÂ±¾µØÊ±¼ä±»ÖØÖÃ)
 763   1              if((step_CortexA == 7) || (step_CortexA == 0))sysTimeReales_counter     = PERIOD_SYSTIMEREALES; //·Ç×èÈû¹Ø¼üÖ
             -¸Áî²»ÄÜ±»×èÈûÖ¸Áî´ò¶Ï£¨Ó²¼þ¸´Î» ºÍ ÈëÍøÊ± ÖÐ¶Ï×èÈûÖ¸ÁîÏÂ´ï£©
 764   1              if(step_CortexA == 0){ //ÌØÊâÖ¸Áî_Ó²¼þ¸´Î»:<0>
 765   2              
 766   2                      switch(step_CortexA){
 767   3                      
 768   3                              case 0:{ //Ê×ÌõÖ¸Áî£¬Ó²¼þ¸´Î»
 769   4                              
 770   4                                      switch(step_CortexB){
 771   5                                      
 772   5                                              case 0:{ //²½ÖèÒ»£ºÓ²¼þÀ­µÍ100ms
 773   6                                              
 774   6                                                      zigbPin_RESET = 0;
 775   6                                                      zigbNwkAction_counter = 200;
 776   6                                                      step_CortexB = 1;
 777   6                                              
 778   6                                              }break;
 779   5                                      
 780   5                                              case 1:{ //²½Öè¶þ£ºÓ²¼þÀ­µÍÍê±ÏºóÈ·ÈÏÓ¦´ðÖ¡Ê±³¤
 781   6                                              
 782   6                                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý
 783   7                                                      
 784   7                                                              zigbPin_RESET = 1;
 785   7                                                              zigbNwkAction_counter = 6000;
 786   7                                                              step_CortexB = 2;
 787   7                                                      }
 788   6                                                      
 789   6                                              }break;
 790   5                                              
 791   5                                              case 2:{ //²½Öè¶þ£ºÈ·ÈÏÓ¦´ðÖ¡
 792   6                                                      
 793   6                                                      if(!zigbNwkAction_counter)step_CortexB = 0; //·Ç×èÈûµÈ´ýÏìÓ¦
 794   6                                              
 795   6                                                      if(uartRX_toutFLG){
 796   7                                                      
 797   7                                                              uartRX_toutFLG = 0;
 798   7                                                              
 799   7                                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ZigbInit_dats[0].zigbInit_REPLY, ZigbInit_dats[0].RE
             -PLY_num)){
 800   8                              
 801   8                                                                      step_CortexB = 0;
 802   8                                                                      reactionLoop = 0;
 803   8                                                                      step_CortexA ++;
 804   8                                                              }
 805   7                                                      }
 806   6                                                      
 807   6                                              }break;
 808   5                                      }
 809   4                                      
 810   4                              }break;
 811   3                      }
 812   2              }else
 813   1              if(step_CortexA > 0 && step_CortexA < cmdNum_zigbNwkREQ){ //³£¹æÖ¸Áî:<1 - 9>
 814   2                      
 815   2      //              if(!reJoin_IF)if(step_CortexA == 2)step_CortexA = 7;    //ÊÇ·ñÎªÖØÐÂÖ÷¶¯¼ÓÈëÐÂÍøÂç£¬·ñÔòÖ»½øÐÐ±»¶¯ÍøÂç¼¤»
             -î
 816   2      
 817   2                      switch(step_CortexB){
 818   3                      
 819   3                              case 0:{
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 15  

 820   4                                      
 821   4                                      if(reactionLoop > 2){
 822   5                                              
 823   5                                              reactionLoop = 0;
 824   5                                              step_CortexA = 0;
 825   5                                              break;
 826   5                                      }
 827   4                                      
 828   4                                      datsTX_Len = ZigB_TXFrameLoad(paramTX_temp, 
 829   4                                                                                                ZigbInit_dats[step_CortexA].zigbInit_reqCMD, 
 830   4                                                                                                2, 
 831   4                                                                                                ZigbInit_dats[step_CortexA].zigbInit_reqDAT, 
 832   4                                                                                                ZigbInit_dats[step_CortexA].reqDAT_num);
 833   4                                      
 834   4                                      uartZigB_datsSend(paramTX_temp, datsTX_Len);
 835   4                                      
 836   4                                      zigbNwkAction_counter = ZigbInit_dats[step_CortexA].timeTab_waitAnsr;
 837   4                                      step_CortexB = 1;
 838   4                                      
 839   4                              }break;
 840   3                                      
 841   3                              case 1:{
 842   4                                      
 843   4                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ýÏìÓ¦
 844   5                                      
 845   5                                              reactionLoop ++;
 846   5                                              step_CortexB = 0;
 847   5                                      }
 848   4                                      else
 849   4                                      if(uartRX_toutFLG){
 850   5                                      
 851   5                                              uartRX_toutFLG = 0;
 852   5                                              
 853   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ZigbInit_dats[step_CortexA].zigbInit_REPLY, ZigbInit_d
             -ats[step_CortexA].REPLY_num)){
 854   6                                              
 855   6                                                      step_CortexB = 0;
 856   6                                                      reactionLoop = 0;
 857   6                                                      step_CortexA ++;
 858   6                                              }
 859   5                                      }
 860   4                                      
 861   4                              }break;
 862   3                      }
 863   2                      
 864   2              }else
 865   1              if(step_CortexA >= cmdNum_zigbNwkREQ){ //ÌØÊâÖ¸Áî_³£¹æÍ¨ÐÅ´Ø×¢²á:<10 - n>
 866   2                      
 867   2                      u8 datsREG_cluster[16] = {0};
 868   2                      memcpy(datsREG_cluster, defaultParam_clusterRegister.zigbInit_reqDAT, defaultParam_clusterRegister.reqDA
             -T_num);
 869   2                      if(step_CortexA < (cmdNum_zigbNwkREQ + clusterNum_default)){ //Ä¬ÈÏ×¨ÓÃÍ¨ÐÅ´Ø²ÎÊýÌî×°
 870   3                      
 871   3                              datsREG_cluster[0] = cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].endpoint;
 872   3                              datsREG_cluster[3] = (u8)((cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].devID & 0x00ff) >> 0);
 873   3                              datsREG_cluster[4] = (u8)((cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].devID & 0xff00) >> 8);
 874   3                              
 875   3                      }else{  //ÓÃ»§Í¨ÐÅ´Ø£¨»¥¿Ø£©×¢²á²ÎÊýÌî×°
 876   3                      
 877   3                              if((CTRLEATHER_PORT[step_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr] >= 0x10) && (CTRLEATHER_PORT[ste
             -p_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr] < 255)){ //Í¨ÐÅ´Ø¶Ë¿ÚºÏ·¨ÐÔÅÐ¶Ï
 878   4                              
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 16  

 879   4                                      datsREG_cluster[0] = CTRLEATHER_PORT[step_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr];
 880   4                                      datsREG_cluster[3] = zigbDatsDefault_ClustID; //Ä¬ÈÏ´ØID <LSB>
 881   4                                      datsREG_cluster[4] = 0; //Ä¬ÈÏ´ØID <MSB>
 882   4                                      
 883   4                              }else{
 884   4                              
 885   4                                      step_CortexA ++;
 886   4                                      return;
 887   4                              }
 888   3                      }
 889   2              
 890   2                      switch(step_CortexB){
 891   3                      
 892   3                              case 0:{
 893   4                                      
 894   4                                      if(reactionLoop > 2){
 895   5                                              
 896   5                                              reactionLoop = 0;
 897   5                                              step_CortexA = 0;
 898   5                                              break;
 899   5                                      }
 900   4                                      
 901   4                                      datsTX_Len = ZigB_TXFrameLoad(paramTX_temp, 
 902   4                                                                                                defaultParam_clusterRegister.zigbInit_reqCMD, 
 903   4                                                                                                2, 
 904   4                                                                                                datsREG_cluster, 
 905   4                                                                                                defaultParam_clusterRegister.reqDAT_num);
 906   4                                      
 907   4                                      uartZigB_datsSend(paramTX_temp, datsTX_Len);
 908   4                                      
 909   4                                      zigbNwkAction_counter = defaultParam_clusterRegister.timeTab_waitAnsr;
 910   4                                      step_CortexB = 1;
 911   4                                      
 912   4                              }break;
 913   3                                      
 914   3                              case 1:{
 915   4                                      
 916   4                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ýÏìÓ¦
 917   5                                      
 918   5                                              reactionLoop ++;
 919   5                                              step_CortexB = 0;
 920   5                                      }
 921   4                                      else
 922   4                                      if(uartRX_toutFLG){
 923   5                                      
 924   5                                              uartRX_toutFLG = 0;
 925   5                                              
 926   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, defaultParam_clusterRegister.zigbInit_REPLY, defaultPa
             -ram_clusterRegister.REPLY_num) || //Ô¤ÆÚÏìÓ¦
 927   5                                                 memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, frameResponseSubs_clusterRegister, 6)){ //Ìæ²¹ÏìÓ¦
 928   6                                              
 929   6                                                      step_CortexB = 0;
 930   6                                                      reactionLoop = 0;
 931   6                                                      step_CortexA ++;
 932   6                                              }
 933   5                                      }
 934   4                                      
 935   4                              }break;
 936   3                      }
 937   2              }
 938   1      }
 939          
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 17  

 940          /*zigbeeÍøÂçÊý¾Ý·¢ËÍ¸ñÊ½»¯Ìî×°*/
 941          static 
 942          u8 zigb_datsLoad_datsSend(u8  frame_Temp[NORMALDATS_DEFAULT_LENGTH],
 943                                                            u16 DstAddr,
 944                                                            u8  portPoint,
 945                                                            u8  dats[],
 946                                                            u8  datsLen){
 947   1              
 948   1              u8 code zigbCMD_DatsSend[2] = {0x24, 0x01};
 949   1              
 950   1      #define zigbDatsSend_datsTransLen       72
 951   1              u8 xdata buf_datsLOAD[zigbDatsSend_datsTransLen] = {0};
 952   1              u8 datsTX_Len = 0;
 953   1                                                                
 954   1              memset(frame_Temp, 0, NORMALDATS_DEFAULT_LENGTH * sizeof(u8));  
 955   1      
 956   1              //·¢ËÍÖ¡Ìî×°
 957   1              buf_datsLOAD[0] = (u8)((DstAddr & 0x00ff) >> 0);
 958   1              buf_datsLOAD[1] = (u8)((DstAddr & 0xff00) >> 8);
 959   1              buf_datsLOAD[2] = portPoint;
 960   1              buf_datsLOAD[3] = portPoint;
 961   1              buf_datsLOAD[4] = zigbDatsDefault_ClustID;
 962   1              buf_datsLOAD[6] = zigbDatsDefault_TransID;
 963   1              buf_datsLOAD[7] = zigbDatsDefault_Option;
 964   1              buf_datsLOAD[8] = zigbDatsDefault_Radius;
 965   1              buf_datsLOAD[9] = datsLen;
 966   1              memcpy(&buf_datsLOAD[10], dats, datsLen);       
 967   1              
 968   1              return ZigB_TXFrameLoad(frame_Temp, (u8 *)zigbCMD_DatsSend, 2, buf_datsLOAD, datsLen + 10);
 969   1      }
 970          
 971          /*zigbeeÎÞÊÓÏìÓ¦»Ø¸´Ö±½Ó·¢ËÍÊý¾Ý*///×èÈû
 972          static
 973          void dataSendRemote_straightforward( u16 DstAddr, //Ô¶¶ËÍøÂç¶ÌµØÖ·
 974                                                                                    u8 port,       //¶Ëµã¿Ú
 975                                                                                    u8 dats[], //Êý¾Ý
 976                                                                                    u8 datsLen ){ //Êý¾Ý³¤¶È
 977   1                                                                                                                                                
 978   1              u8 xdata buf_datsTX[NORMALDATS_DEFAULT_LENGTH] = {0};
 979   1              u8 datsTX_Len = 0;
 980   1              
 981   1              datsTX_Len = zigb_datsLoad_datsSend(buf_datsTX, DstAddr, port, dats, datsLen);
 982   1              
 983   1              uartZigB_datsSend(buf_datsTX, datsTX_Len);
 984   1      }
 985          
 986          /*zigbeeÍøÂçÊý¾Ý·¢ËÍÇëÇó×´Ì¬»ú*///·Ç×èÈû
 987          static
 988          void dataTransRequest_datsSend(void){
 989   1      
 990   1              u8 xdata buf_datsTX[NORMALDATS_DEFAULT_LENGTH] = {0};
 991   1              u8 datsTX_Len = 0;
 992   1              
 993   1      #define zigbDatsSend_datsRespLen        64
 994   1              u8 xdata buf_datsRX[zigbDatsSend_datsRespLen] = {0};
 995   1              u8 datsRX_Len = 0;
 996   1              
 997   1      #define zigbDatsSend_ASR_datsLen        3
 998   1              u8              ASR_dats[zigbDatsSend_ASR_datsLen] = {0};
 999   1              u8 code ASR_cmd[2] = {0x44,0x80};       //±¾µØZNPÐ­Òé²ãÈ·ÈÏ·¢ËÍÏìÓ¦
1000   1              
1001   1      #define resCODE_datsSend_NOROUTER 0xCD  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-Â·ÓÉÊ§Áª£¬Í¨Ñ¶Ã½½é¶ªÊ§
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 18  

1002   1      #define resCODE_datsSend_NOREMOTE 0xE9  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-¶Ô·½²»ÔÚÏß£¬Ä¿±êµØÖ·½ÚµãÉè±¸²»´æÔÚ
1003   1      #define resCODE_datsSend_TIMEOUT  0x01  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-·¢ËÍ³¬Ê±
1004   1      #define resCODE_datsSend_SUCCESS  0x00  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-·¢ËÍ³É¹¦
1005   1              static u8 datsTrans_respondCode = 0; //·¢ËÍÍê³ÉÏìÓ¦Âë
1006   1              
1007   1              static u8 step = 0;
1008   1              static u8 reactionLoop = 0;
1009   1              
1010   1              if(devStatus_switch.statusChange_IF){   //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
1011   2              
1012   2                      devStatus_switch.statusChange_IF = 0;
1013   2                      devRunning_Status = devStatus_switch.statusChange_standBy;
1014   2                      
1015   2                      step = 0;
1016   2                      reactionLoop = 0;
1017   2                      
1018   2                      return;
1019   2              }
1020   1              
1021   1              //½ÓÊÕÖ¡Ìî×°_±¾µØ
1022   1              ASR_dats[0] = resCODE_datsSend_SUCCESS; //·¢ËÍ³É¹¦ÏìÓ¦´úÂë
1023   1              ASR_dats[1] = datsSend_request.portPoint;
1024   1              ASR_dats[2] = zigbDatsDefault_TransID;
1025   1              datsRX_Len = ZigB_TXFrameLoad(buf_datsRX, (u8 *)ASR_cmd, 2, ASR_dats, zigbDatsSend_ASR_datsLen);
1026   1              
1027   1              datsTX_Len = zigb_datsLoad_datsSend(buf_datsTX, datsSend_request.nwkAddr, datsSend_request.portPoint, dat
             -sSend_request.datsTrans.dats, datsSend_request.datsTrans.datsLen);
1028   1              
1029   1              switch(step){
1030   2              
1031   2                      case 0:{ //ÏìÓ¦½ÓÊÕ¾ÍÐ÷£¬ÉèÖÃÏìÓ¦Ê±¼ä
1032   3                              
1033   3                              if(reactionLoop > 3){ //ÖØ·¢´ÎÊýÒÑ³¬³ö
1034   4                                      
1035   4                                      datsTrans_respondCode = resCODE_datsSend_TIMEOUT; //ÏìÓ¦Âë¸ÄÎª³¬Ê±
1036   4                                      
1037   4                                      reactionLoop = 0;
1038   4                                      step = 4;
1039   4                                      
1040   4                                      break;
1041   4                              }
1042   3                      
1043   3                              zigbPin_RESET = 1; //±£ÏÕÆð¼û£¬¸´Î»À­¸ß
1044   3                              uartZigB_datsSend(buf_datsTX, datsTX_Len);
1045   3                              zigbNwkAction_counter = 1000; //Ä¬ÈÏÐ­Òé²ãÏìÓ¦Ê±¼ä<Ê±¼äÌ«¶ÌÎÞ·¨ÊÕµ½ºóÃæµÄ½ÓÊÕ×´Ì¬ÏìÓ¦Ö¸Áî£¬Ö»ÄÜÊÕµ½ÏµÍ³
             -ÏìÓ¦>
1046   3                              step = 1;
1047   3                              
1048   3                      }break;
1049   2                      
1050   2                      case 1:{ //·Ç×èÈûµÈ´ýÏµÍ³ÏìÓ¦
1051   3                      
1052   3                              if(!zigbNwkAction_counter){
1053   4                              
1054   4                                      reactionLoop ++;
1055   4                                      step = 0;
1056   4                              }
1057   3                              else{
1058   4                                      
1059   4                                      if(uartRX_toutFLG){
1060   5                                      
1061   5                                              uartRX_toutFLG = 0;
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 19  

1062   5      
1063   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, buf_datsRX, datsRX_Len)){ //Ó¦´ðÖ¸ÁîºÍÓ¦´ðÂë¶¼ÕýÈ·
1064   6                                              
1065   6                                                      if(datsRcv_respond.datsTrans.datsLen == 0){
1066   7                                                      
1067   7                                                              step = 3;
1068   7                                                              
1069   7                                                      }else{
1070   7                                                      
1071   7                                                              step = 2;
1072   7                                                              zigbNwkAction_counter = 500; //Ä¬ÈÏÔ¶¶ËÏìÓ¦Ê±¼ä<¶Ô·½½ÚµãÏìÓ¦>
1073   7                                                      }
1074   6                                                      
1075   6                                              }else{  
1076   6                                                      
1077   6                                                      if(!memcmp(&datsRcv_ZIGB.rcvDats[2], ASR_cmd, 2)){ //Ó¦´ðÖ¸ÁîÕýÈ·£¬µ«Ó¦´ðÂë´íÎó£¬ÔòÈ¡³ö´íÎóÂë
1078   7                                                      
1079   7                                                              datsTrans_respondCode = datsRcv_ZIGB.rcvDats[4]; //´íÎóÏìÓ¦Âë×°ÔØ
1080   7                                                              step = 4; //ÓÐÓ¦´ðÖ¸Áî£¬ÌøÖÁÊ§°Ü²½Öè
1081   7                                                      }
1082   6                                                      
1083   6      //#if(DEBUG_LOGOUT_EN == 1)
1084   6      //                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1085   6      //                                                      u8 xdata log_buf[64]; //Êý¾Ý´«ÊäÊ§°ÜÐ­Òé²ãÏìÓ¦´úÂë´òÓ¡
1086   6      //                                                      
1087   6      //                                                      sprintf(log_buf, "dats_TX fail code: %02X %02X %02X.\n", (int)datsRcv_ZIGB.rcvDats[2], (int)datsR
             -cv_ZIGB.rcvDats[3], (int)datsRcv_ZIGB.rcvDats[4]);
1088   6      //                                                      PrintString1_logOut(log_buf);
1089   6      //                                              }       
1090   6      //#endif                                
1091   6                                              }
1092   5                                      }
1093   4                              }
1094   3                              
1095   3                      }break;
1096   2                      
1097   2                      case 2:{ //·Ç×èÈûµÈ´ýÔ¶¶ËÏìÓ¦
1098   3      
1099   3                              if(!zigbNwkAction_counter){
1100   4                              
1101   4                                      reactionLoop ++;
1102   4                                      step = 0;
1103   4                              }
1104   3                              else{
1105   4                                      
1106   4                                      if(uartRX_toutFLG){
1107   5                                              
1108   5                                              u16 idata datsFrom_addr = ((u16)(datsRcv_ZIGB.rcvDats[9]) << 8) | ((u16)(datsRcv_ZIGB.rcvDats[8]) << 
             -0); //Êý¾Ý·¢ËÍ·½ÍøÂçµØÖ·
1109   5                                              u8      idata dstPoint =  datsRcv_ZIGB.rcvDats[11];     //Ô¶¶Ë  
1110   5                                              
1111   5                                              uartRX_toutFLG = 0;
1112   5      
1113   5                                              if(!memcmp(&(datsRcv_ZIGB.rcvDats[21]), datsRcv_respond.datsTrans.dats, datsRcv_respond.datsTrans.dat
             -sLen) && 
1114   5                                                 (datsRcv_respond.nwkAddr == datsFrom_addr) &&
1115   5                                                      (datsRcv_respond.portPoint == dstPoint)){
1116   6                                              
1117   6                                                      step = 3;
1118   6                                              }
1119   5                                      }
1120   4                              }
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 20  

1121   3                              
1122   3                      }break;
1123   2                      
1124   2                      case 3:{ //ÏìÓ¦³É¹¦
1125   3                      
1126   3                              if(reConnectAfterDatsReq_IF){ //Õë¶Ô¼´¿Ì×¢²á»¥¿ØÌØÊâÇé¿ö ×´Ì¬ÇÐ»»
1127   4                              
1128   4                                      reConnectAfterDatsReq_IF = 0;
1129   4                                      devRunning_Status = status_nwkReconnect;
1130   4                                      
1131   4                              }else{ 
1132   4                              
1133   4                                      devRunning_Status = status_passiveDataRcv;
1134   4                              }
1135   3                              
1136   3                              reactionLoop = 0;
1137   3                              step = 0;
1138   3                              
1139   3                      }break;
1140   2                      
1141   2                      case 4:{ //ÏìÓ¦Ê§°Ü
1142   3                      
1143   3                              if(reConnectAfterDatsReq_IF){ //Õë¶Ô¼´¿Ì×¢²á»¥¿ØÌØÊâÇé¿ö ×´Ì¬ÇÐ»»
1144   4                              
1145   4                                      reConnectAfterDatsReq_IF = 0;
1146   4                                      devRunning_Status = status_nwkReconnect;
1147   4                                      
1148   4                              }else{ 
1149   4                              
1150   4                                      devRunning_Status = status_passiveDataRcv;
1151   4                              }
1152   3                              
1153   3                              //Õë¶ÔÊý¾Ý´«ÊäÊ§°ÜÏìÓ¦´úÂëÇé¿ö½øÐÐÑ¡ÔñÐÔÖØÁ¬£¬·ñÔò½öÊ±ÇøÐ­µ÷Æ÷Éè±¸¾Ígg
1154   3                              if(datsTrans_respondCode){ 
1155   4                                      
1156   4      #if(DEBUG_LOGOUT_EN == 1)                               
1157   4                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1158   5                                              u8 xdata log_buf[64];
1159   5                                              
1160   5                                              sprintf(log_buf, "remote dataRequest fail, code:[0x%02X].\n", (int)datsTrans_respondCode);
1161   5                                              PrintString1_logOut(log_buf);
1162   5                                      }
1163   4      #endif  
1164   4                                      
1165   4                                      switch(datsTrans_respondCode){ //ÏìÓ¦Ê§°ÜÂë·ÖÎö
1166   5                                      
1167   5                                              case resCODE_datsSend_NOROUTER:
1168   5                                              case resCODE_datsSend_NOREMOTE:
1169   5                                              case resCODE_datsSend_SUCCESS:{
1170   6                                              
1171   6                                                      devTips_nwkZigb = nwkZigb_outLine; //ÔÝÊ±Ö»×öÊ§°ÜÌáÊ¾£¬²»×öÆäËû¶¯×÷
1172   6                                                      
1173   6                                              }break;
1174   5                                              
1175   5                                              default:{
1176   6                                              
1177   6                                                      devTips_nwkZigb = nwkZigb_outLine; //ÔÝÊ±Ö»×öÊ§°ÜÌáÊ¾£¬²»×öÆäËû¶¯×÷
1178   6                                                      
1179   6                                              }break;
1180   5                                      }
1181   4                                      
1182   4                                      datsTrans_respondCode = 0;
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 21  

1183   4                              }
1184   3                              
1185   3                              reactionLoop = 0;
1186   3                              step = 0;
1187   3                              
1188   3                      }break;
1189   2                              
1190   2                      default:{
1191   3                      
1192   3                              step = 4;
1193   3                              
1194   3                      }break;
1195   2              }
1196   1      }
1197          
1198          /*Éè±¸Êý¾Ý´«ÊäÖ÷×´Ì¬ÇÐ»»ÖÁÍøÂç¹ÒÆð*/
1199          void devStatusChangeTo_devHold(bit zigbNwkSysNote_IF){ //Éè±¸ÍøÂç¹ÒÆð
1200   1      
1201   1              devNwkHoldTime_Param.devHoldTime_counter = DEVHOLD_TIME_DEFAULT;
1202   1              if(zigbNwkSysNote_IF)devNwkHoldTime_Param.zigbNwkSystemNote_IF = 1;
1203   1              
1204   1              devStatus_switch.statusChange_standBy = status_devNwkHold; //Êý¾Ý´«Êä×´Ì¬»ú¸ü±ä
1205   1              devStatus_switch.statusChange_IF = 1;
1206   1              
1207   1              devTips_status = status_devHold; //tips¸ü±ä
1208   1              
1209   1      #if(DEBUG_LOGOUT_EN == 1)                               
1210   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1211   2                      u8 xdata log_buf[64];
1212   2                      
1213   2                      sprintf(log_buf, "devHold start right now.\n");
1214   2                      PrintString1_logOut(log_buf);
1215   2              }
1216   1      #endif  
1217   1      }
1218          
1219          /*Éè±¸ÍøÂç¹ÒÆðÍ£Ö¹£¬Ê¹ÌáÇ°½áÊø*/
1220          void devHoldStop_makeInAdvance(void){ //Í£Ö¹Éè±¸ÍøÂç¹ÒÆð£¨ÌáÇ°£©
1221   1      
1222   1              if(devNwkHoldTime_Param.devHoldTime_counter)devNwkHoldTime_Param.devHoldTime_counter = 0;
1223   1      }
1224          
1225          /*zigbeeÉè±¸ÍøÂç¹ÒÆð×´Ì¬»ú*///·Ç×èÈû
1226          static 
1227          void function_devNwkHold(void){
1228   1              
1229   1              static status_Step = 0; //µ±Ç°×´Ì¬»ú²½Öè×´Ì¬Ö¸Ê¾
1230   1              
1231   1              if(devNwkHoldTime_Param.devHoldTime_counter){ //Ö±µ½¹ÒÆðÊ±¼ä½áÊø
1232   2              
1233   2                      if(devNwkHoldTime_Param.zigbNwkSystemNote_IF){ //Í¨Öªµ±Ç°ÍøÂçÄÚ×ÓÉè±¸¹ÒÆð,±¨Ò»´Î
1234   3                              
1235   3                              u8 xdata dats_Note[3] = {ZIGB_SYSCMD_DEVHOLD, 1, 0}; //ÃüÁî¡¢Êý¾Ý³¤¶È¡¢Êý¾Ý
1236   3                      
1237   3                              devNwkHoldTime_Param.zigbNwkSystemNote_IF = 0; //Í¨ÖªÊ¹ÄÜ¸´Î»
1238   3                              
1239   3                              dataSendRemote_straightforward( 0xFFFF, //¹ã²¥Í¨ÖªÍøÄÚËùÓÐ×ÓÉè±¸¹ÒÆð
1240   3                                                                                              ZIGB_ENDPOINT_CTRLSYSZIGB,
1241   3                                                                                              dats_Note,
1242   3                                                                                              3 );
1243   3                              
1244   3                              delayMs(50); //±ØÐèÑÓÊ±£¬·ñÔòÊý¾Ý»¹Ã»·¢ËÍ³öÈ¥£¬¾ÍÅÜµ½ÏÂÒ»²½¸´Î»ÁË
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 22  

1245   3                      }
1246   2                      
1247   2                      { //Éè±¸¹ÒÆð,Ñ­»·¸´Î»
1248   3                              
1249   3                              switch(status_Step){
1250   4                              
1251   4                                      case 0:{ //¸´Î»200ms
1252   5                                      
1253   5                                              zigbPin_RESET = 0;
1254   5                                              zigbNwkAction_counter = 200;
1255   5                                              status_Step = 1;
1256   5                                      
1257   5                                      }break;
1258   4                                              
1259   4                                      case 1:{ //Ã¿6s¸´Î»Ò»´Î
1260   5                                      
1261   5                                              if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý
1262   6                                              
1263   6                                                      zigbPin_RESET = 1;
1264   6                                                      zigbNwkAction_counter = 6000;
1265   6                                                      status_Step = 2;
1266   6                                              }
1267   5                                      
1268   5                                      }break;
1269   4                                      
1270   4                                      case 2:{
1271   5                                      
1272   5                                              if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý
1273   6                                              
1274   6                                                      status_Step = 0;
1275   6                                                      
1276   6      #if(DEBUG_LOGOUT_EN == 1)                               
1277   6                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1278   7                                                              u8 xdata log_buf[64];
1279   7                                                              
1280   7                                                              sprintf(log_buf, "devHold time count remind: %02d s.\n", (int)devNwkHoldTime_Param.devHoldTime_coun
             -ter);
1281   7                                                              PrintString1_logOut(log_buf);
1282   7                                                      }
1283   6      #endif
1284   6                                              }
1285   5                                      
1286   5                                      }break;
1287   4                                      
1288   4                                      default:{
1289   5                                              
1290   5                                              status_Step = 0;
1291   5                                              
1292   5                                      }break;
1293   4                              }
1294   3                      }
1295   2      
1296   2              }else{
1297   2              
1298   2                      //¹ÒÆðÊ±¼ä½áÊø,Ö÷×´Ì¬»Ö¸´ÖÁÖØÁ¬£¬±¾µØ×´Ì¬»Ö¸´
1299   2                      status_Step = 0;
1300   2                      zigbPin_RESET = 1;
1301   2                      
1302   2                      devRunning_Status = status_nwkReconnect; //Ö±½Ó½«Ö÷×´Ì¬ÇÐ»»ÖÁÍøÂçÖØÁ¬,²»×ßstandbyÁ÷³Ì
1303   2                      devTips_status = status_Normal; //tips¸ü±ä
1304   2              
1305   2      #if(DEBUG_LOGOUT_EN == 1)                               
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 23  

1306   2                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1307   3                              u8 xdata log_buf[64];
1308   3                              
1309   3                              sprintf(log_buf, "devHold stop.\n");
1310   3                              PrintString1_logOut(log_buf);
1311   3                      }
1312   2      #endif  
1313   2              }
1314   1      }
1315          
1316          /*zigbee¼¯Èº¿ØÖÆÊý¾Ý½âÎö*/
1317          static 
1318          void dataParing_scenarioCtrl(u8 datsFrame[]){
1319   1      
1320   1              swCommand_fromUsr.objRelay = datsFrame[0]; //¼ÌµçÆ÷ÏìÓ¦¼´¿É
1321   1              swCommand_fromUsr.actMethod = relay_OnOff;
1322   1              
1323   1      #if(DEBUG_LOGOUT_EN == 1)
1324   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1325   2                      u8 xdata log_buf[64];
1326   2                      
1327   2                      sprintf(log_buf, "cmdScenarioCtrl comming, statusData:%02X.\n", (int)datsFrame[0]);
1328   2                      PrintString1_logOut(log_buf);
1329   2              }                       
1330   1      #endif          
1331   1      }
1332          
1333          /*zigbeeÏµÍ³½»»¥Êý¾Ý½âÎö*/
1334          static 
1335          void dataParing_zigbSysCtrl(u8 datsFrame[]){
1336   1      
1337   1              frame_zigbSysCtrl xdata dats = {0};
1338   1              
1339   1              dats.command = datsFrame[0];
1340   1              memcpy(dats.dats, &datsFrame[2], datsFrame[1]);
1341   1              dats.datsLen = datsFrame[1];
1342   1              
1343   1              switch(dats.command){
1344   2              
1345   2                      case ZIGB_SYSCMD_NWKOPEN:{ //ÍøÂç¿ª·Å
1346   3                              
1347   3                              bit resultSet = 0;
1348   3                              
1349   3                              resultSet = ZigB_nwkOpen(1, dats.dats[0]); //¹¦ÄÜ´¥·¢
1350   3                              tips_statusChangeToZigbNwkOpen(ZIGBNWK_OPNETIME_DEFAULT); //tips´¥·¢
1351   3                              
1352   3      #if(DEBUG_LOGOUT_EN == 1)
1353   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1354   4                                      u8 xdata log_buf[64];
1355   4                                      
1356   4                                      sprintf(log_buf, "master cmdComing:nwkOpen:%02ds.\n", (int)dats.dats[0]);
1357   4                                      PrintString1_logOut(log_buf);
1358   4                              }                       
1359   3      #endif          
1360   3                              
1361   3                      }break;
1362   2                      
1363   2                      case ZIGB_SYSCMD_TIMESET:{ //ÏµÍ³Ê±¼äÉè¶¨
1364   3                      
1365   3                              bit resultSet = 0;
1366   3                              bit timeZoneAdjust_needIF = 0;
1367   3                              u32 time_Temp = 0UL;
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 24  

1368   3                              
1369   3                              time_Temp |= (u32)dats.dats[0] << 0;
1370   3                              time_Temp |= (u32)dats.dats[1] << 8;
1371   3                              time_Temp |= (u32)dats.dats[2] << 16;
1372   3                              time_Temp |= (u32)dats.dats[3] << 24;
1373   3                              if((sysTimeZone_H != dats.dats[4]) || (sysTimeZone_M != dats.dats[5])){ //Ê±ÇøÍ¬²½
1374   4                              
1375   4                                      sysTimeZone_H = dats.dats[4];
1376   4                                      sysTimeZone_M = dats.dats[5];
1377   4                                      coverEEPROM_write_n(EEPROM_ADDR_timeZone_H, &sysTimeZone_H, 1);
1378   4                                      coverEEPROM_write_n(EEPROM_ADDR_timeZone_M, &sysTimeZone_M, 1);
1379   4                              }
1380   3                              
1381   3                              if(dats.dats[6])timeZoneAdjust_needIF = 1; //Ê±Çø²¹³¥Ê¹ÄÜÅÐ¶Ï
1382   3                              if(time_Temp > ZIGB_UTCTIME_START)resultSet = zigB_sysTimeSet(time_Temp - ZIGB_UTCTIME_START, timeZoneA
             -djust_needIF); //zigbee ±¾µØÏµÍ³Ê±¼äÉèÖÃ<UTC¸º²¹³¥>
1383   3                              
1384   3      #if(DEBUG_LOGOUT_EN == 1)
1385   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1386   4                                      u8 xdata log_buf[64];
1387   4                                      
1388   4                                      sprintf(log_buf, "master UTC coming:[0x%02X%02X%02X%02X].\n", (int)dats.dats[3], (int)dats.dats[2], (i
             -nt)dats.dats[1], (int)dats.dats[0]);
1389   4                                      PrintString1_logOut(log_buf);
1390   4                              }                       
1391   3      #endif  
1392   3                      }break;
1393   2                      
1394   2                      case ZIGB_SYSCMD_DEVHOLD:{ //ÍøÂç¿ª·Å£¨ÓÃ×÷Íø¹ØÇÐ»»£©
1395   3                              
1396   3      #if(DEBUG_LOGOUT_EN == 1)
1397   3                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1398   4                                      u8 xdata log_buf[64];
1399   4                                      
1400   4                                      sprintf(log_buf, "node cmdComing:devNwk hold.\n");
1401   4                                      PrintString1_logOut(log_buf);
1402   4                              }                       
1403   3      #endif  
1404   3                              devStatusChangeTo_devHold(0); //Éè±¸ÍøÂç±»¶¯¹ÒÆð,²»½øÐÐÍøÂçÍ¨Öª
1405   3                              
1406   3                      }break;
1407   2                              
1408   2                      default:break;
1409   2              }
1410   1      }
1411          
1412          /*zigbee³£¹æ¿ØÖÆ×ª·¢Êý¾Ý½âÎö*/
1413          static 
1414          void dataParing_Nomal(u8 datsParam[], u16 nwkAddr_from, u8 port_from){
1415   1              
1416   1      #define dataLen_dataParingNomal 96
1417   1              u8 xdata paramTX_temp[dataLen_dataParingNomal] = {0};
1418   1              
1419   1              bit dataFromRemote_IF = 0;      //ÊÇ·ñÎª·þÎñÆ÷¶ËÊý¾Ý±êÖ¾
1420   1      
1421   1              /*²úÆ·¶þ¼¶Ð­ÒéºË¶Ô_³£¹æ¿ØÖÆ*///¿ØÖÆÏÂ´ï
1422   1              switch(datsParam[0]){
1423   2              
1424   2                      /*Ô¶¶Ë*/
1425   2                      case ZIGB_FRAMEHEAD_CTRLREMOTE:{
1426   3                              
1427   3                              dataFromRemote_IF = 1;
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 25  

1428   3                              
1429   3                              memcpy(MAC_ID_DST, &datsParam[7], 6);
1430   3                              memcpy(&datsParam[1], &datsParam[13], datsRcv_ZIGB.rcvDats[20] - 13);
1431   3                      }
1432   2                      
1433   2                      /*±¾µØ*/
1434   2                      case ZIGB_FRAMEHEAD_CTRLLOCAL:{
1435   3                              
1436   3                              bit frameCheck_Done = 0; //Êý¾Ý¼ì²âºÏ¸ñ±êÖ¾
1437   3                              
1438   3                              {
1439   4                                      bit frameCodeCheck_PASS = 0; //Ð£ÑéÂë¼ì²éÍ¨¹ý±êÖ¾
1440   4                                      bit frameMacCheck_PASS  = 0; //macµØÖ·´ý¼ì²éÍ¨¹ý±êÖ¾
1441   4                                      
1442   4                                      if(datsParam[4] == frame_Check(&datsParam[5], 28))frameCodeCheck_PASS = 1; //Ð£ÑéÂë¼ì²â
1443   4                                      if(!memcmp(&datsParam[5], &MAC_ID[1], 5))frameMacCheck_PASS = 1; //MAC¼ì²â
1444   4      
1445   4                                      if(datsParam[3] == FRAME_MtoZIGBCMD_cmdConfigSearch){ //ÌØÊâÖ¸Áî²»×öMAC¼ì²â
1446   5                                      
1447   5                                              frameMacCheck_PASS = 1;
1448   5                                              
1449   5                                      }else
1450   4                                      if((datsParam[3] == FRAME_MtoZIGBCMD_cmdCfg_swTim) || //ÌØÊâÖ¸Áî²»×öÐ£ÑéÂë¼ì²â
1451   4                                         (datsParam[3] == FRAME_MtoZIGBCMD_cmdswTimQuery)){
1452   5                                         
1453   5                                              frameCodeCheck_PASS = 1;
1454   5                                      }
1455   4                                         
1456   4                                      if(frameCodeCheck_PASS && frameCodeCheck_PASS)frameCheck_Done = 1;
1457   4                              }
1458   3                                 
1459   3                              if(frameCheck_Done){ //Ö¡¼ì²éÍ¨¹ý£¬¿ªÊ¼½âÎö¡¢¶¯×÷¼°ÏìÓ¦
1460   4                                      
1461   4                                      bit respond_IF          = 0;    //ÊÇ·ñ»Ø¸´
1462   4                                      bit specialCmd_IF       = 0;    //ÊÇ·ñÎªÌØÊâÖ¸Áî£¨ÌØÊâÖ¸ÁîÕ¼ÓÃ¿ª¹ØÀàÐÍÄÇÒ»¸ö×Ö½Ú£©
1463   4                                      
1464   4      #if(DEBUG_LOGOUT_EN == 1)
1465   4                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1466   5                                              u8 xdata log_buf[64];
1467   5                                              
1468   5                                              sprintf(log_buf, "cmdComing:%02X.\n", (int)datsParam[3]);
1469   5                                              PrintString1_logOut(log_buf);
1470   5                                      }                       
1471   4      #endif          
1472   4                                      memset(paramTX_temp, 0, sizeof(u8) * dataLen_dataParingNomal);
1473   4                              
1474   4                                      switch(datsParam[3]){
1475   5                                      
1476   5                                              case FRAME_MtoZIGBCMD_cmdConfigSearch:{
1477   6                                                      
1478   6                                                      if(!deviceLock_flag){ //Éè±¸ÊÇ·ñÉÏËø
1479   7                                                              
1480   7                                                              u16 xdata panid_Temp = ZigB_getPanIDCurrent(); //ÅäÖÃ»Ø¸´Ìí¼ÓPANID
1481   7                                                              
1482   7                                                              paramTX_temp[14] = (u8)((panid_Temp & 0xFF00) >> 8);
1483   7                                                              paramTX_temp[15] = (u8)((panid_Temp & 0x00FF) >> 0);
1484   7                                                              
1485   7                                                              sysTimeZone_H = datsParam[12];
1486   7                                                              sysTimeZone_M = datsParam[13];
1487   7                                                              coverEEPROM_write_n(EEPROM_ADDR_timeZone_H, &sysTimeZone_H, 1);
1488   7                                                              coverEEPROM_write_n(EEPROM_ADDR_timeZone_M, &sysTimeZone_M, 1);
1489   7                                                      
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 26  

1490   7                                                              respond_IF              = 1; //ÏìÓ¦»Ø¸´
1491   7                                                              specialCmd_IF   = 0;
1492   7                                                              
1493   7                                                      }else{
1494   7                                                      
1495   7                                                              
1496   7                                                      }
1497   6                                                      
1498   6                                              }break;
1499   5                                              
1500   5                                              case FRAME_MtoZIGBCMD_cmdControl:{
1501   6      
1502   6                                                      paramTX_temp[11] = 0;
1503   6                                                      paramTX_temp[11] |= (datsParam[11] & 0x07);     //×´Ì¬Î»Ìî×°
1504   6                                                      if(             (datsParam[11] & 0x01) != (status_Relay & 0x01))paramTX_temp[11] |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÒ»Î»
1505   6                                                      else if((datsParam[11] & 0x02) != (status_Relay & 0x02))paramTX_temp[11] |= 0x40; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ
             -»>µÚ¶þÎ»
1506   6                                                      else if((datsParam[11] & 0x04) != (status_Relay & 0x04))paramTX_temp[11] |= 0x80; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ
             -»>µÚÈýÎ»
1507   6                                                      
1508   6                                                      swCommand_fromUsr.objRelay = datsParam[11];
1509   6                                                      swCommand_fromUsr.actMethod = relay_OnOff;
1510   6      
1511   6                                                      respond_IF              = 1; //ÏìÓ¦»Ø¸´
1512   6                                                      specialCmd_IF   = 0;                                                    
1513   6                                                      
1514   6                                              }break;
1515   5                                                      
1516   5                                              case FRAME_MtoZIGBCMD_cmdQuery:{}break;
1517   5                                                      
1518   5                                              case FRAME_MtoZIGBCMD_cmdInterface:{}break;
1519   5                                                      
1520   5                                              case FRAME_MtoZIGBCMD_cmdReset:{}break;
1521   5                                                      
1522   5                                              case FRAME_MtoZIGBCMD_cmdDevLockON:{
1523   6                                              
1524   6                                                      //Êý¾Ý´¦Àí¼°¶¯×÷ÏìÓ¦
1525   6                                                      {
1526   7                                                              u8 deviceLock_IF = 1;
1527   7                                                              
1528   7                                                              deviceLock_flag  = 1;
1529   7                                                              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
1530   7                                                      }               
1531   6                                                      
1532   6                                              }break;
1533   5                                                      
1534   5                                              case FRAME_MtoZIGBCMD_cmdDevLockOFF:{
1535   6                                              
1536   6                                                      //Êý¾Ý´¦Àí¼°¶¯×÷ÏìÓ¦
1537   6                                                      {
1538   7                                                              u8 deviceLock_IF = 0;
1539   7                                                              
1540   7                                                              deviceLock_flag  = 0;
1541   7                                                              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
1542   7                                                      }       
1543   6                                              
1544   6                                              }break;
1545   5                                                      
1546   5                                              case FRAME_MtoZIGBCMD_cmdswTimQuery:{
1547   6                                              
1548   6                                                      //·ÖÀà»Ø¸´
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 27  

1549   6                                                      switch(datsParam[13]){ //×ÓÃüÁî½âÎö
1550   7                                                      
1551   7                                                              case 0: /*ÉÏÎ»»úÔÚ¶¨Ê±µÄÊ±ºò¸ø0£¬´ýÐ­ÉÌ*/
1552   7                                                              case cmdConfigTim_normalSwConfig:{
1553   8                                                              
1554   8                                                                      u8 loop = 0;
1555   8                                                              
1556   8                                                                      //Êý¾ÝÏìÓ¦¼°»Ø¸´
1557   8                                                                      EEPROM_read_n(EEPROM_ADDR_swTimeTab, &paramTX_temp[14], 12);    //¶¨Ê±±í»Ø¸´Ìî×°
1558   8                                                                      
1559   8                                                                      //»Ø¸´Êý¾Ý¶þ´Î´¦Àí£¨Õë¶ÔÒ»´ÎÐÔ¶¨Ê±Êý¾Ý£©
1560   8                                                                      for(loop = 0; loop < 4; loop ++){
1561   9                                                                      
1562   9                                                                              if(swTim_onShoot_FLAG & (1 << loop)){
1563  10                                                                                      
1564  10                                                                                      paramTX_temp[14 + loop * 3] &= 0x80;
1565  10                                                                              }
1566   9                                                                      }
1567   8                                                                                      
1568   8                                                                      specialCmd_IF = 1; //ÌØÊâÕ¼Î»Ö¸Áî
1569   8                                                                      
1570   8                                                              }break;
1571   7                                                              
1572   7                                                              case cmdConfigTim_onoffDelaySwConfig:{
1573   8                                                              
1574   8                                                                      if(!delayCnt_onoff)paramTX_temp[14] = 0;
1575   8                                                                      else paramTX_temp[14] = delayPeriod_onoff - (u8)(delayCnt_onoff / 60);
1576   8                                                                      paramTX_temp[15] = delayUp_act;
1577   8                                                                      
1578   8                                                              }break;
1579   7                                                              
1580   7                                                              case cmdConfigTim_closeLoopSwConfig:{
1581   8                                                              
1582   8                                                                      paramTX_temp[14] = delayPeriod_closeLoop;
1583   8                                                                      
1584   8                                                              }break;
1585   7                                                              
1586   7                                                              case cmdConfigTim_nightModeSwConfig:{  
1587   8                                                              
1588   8                                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &paramTX_temp[14], 6);      //Ò¹¼äÄ£Ê½¶¨Ê±±í»Ø¸´Ìî×°
1589   8                                                                      
1590   8                                                                      (deviceLock_flag)?(paramTX_temp[12] |= 0x01):(paramTX_temp[12] &= ~0x01);
1591   8                                                                      (ifNightMode_sw_running_FLAG)?(paramTX_temp[12] |= 0x02):(paramTX_temp[12] &= ~0x02);
1592   8                                                                      
1593   8                                                              }break;
1594   7                                                              
1595   7                                                              default:break;
1596   7                                                      }
1597   6                                                      
1598   6                                                      paramTX_temp[13] = datsParam[13]; //¶¨Ê±×ÓÃüÁîÍ¬²½»Ø¸´
1599   6                                                      
1600   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1601   6                                                      
1602   6                                              }break;
1603   5                                                      
1604   5                                              case FRAME_MtoZIGBCMD_cmdConfigAP:{}break;
1605   5                                                      
1606   5                                              case FRAME_MtoZIGBCMD_cmdBeepsON:{ //Ò¹¼äÄ£Ê½¹Ø
1607   6                                              
1608   6                                                      u8 datsTemp = 0;
1609   6                                                      
1610   6                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 28  

1611   6                                                      datsTemp &= ~0x7f; //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢,È¡ÏûÍ·×Ö½ÚÈ«Õ¼Âú,Ê§ÄÜÈ«Ìì
1612   6                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
1613   6                                                      
1614   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1615   6                                                      
1616   6                                              }break;
1617   5                                                      
1618   5                                              case FRAME_MtoZIGBCMD_cmdBeepsOFF:{ //Ò¹¼äÄ£Ê½¿ª
1619   6                                              
1620   6                                                      u8 datsTemp = 0;
1621   6                                                      
1622   6                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
1623   6                                                      datsTemp |= 0x7f; //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢,Í·×Ö½ÚÈ«Õ¼Âú,Ç¿ÖÆÈ«Ìì
1624   6                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);        
1625   6                                                      
1626   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1627   6                                                      
1628   6                                              }break;
1629   5                                                      
1630   5                                              case FRAME_MtoZIGBCMD_cmdftRecoverRQ:{
1631   6                                              
1632   6                                                      respond_IF = 1;
1633   6                                                      
1634   6                                              }break;
1635   5                                                      
1636   5                                              case FRAME_MtoZIGBCMD_cmdRecoverFactory:{
1637   6                                              
1638   6                                                      Factory_recover();
1639   6                                              
1640   6                                              }break;
1641   5                                                      
1642   5                                              case FRAME_MtoZIGBCMD_cmdCfg_swTim:{
1643   6                                                      
1644   6                                                      u8 loop = 0;
1645   6                                                      
1646   6                                                      switch(datsParam[13]){ //¶¨Ê±Êý¾Ý´¦Àí¼°¸üÐÂ,·ÖÀà´¦Àí
1647   7                                                      
1648   7                                                              case cmdConfigTim_normalSwConfig:{      /*ÆÕÍ¨¶¨Ê±*/
1649   8                                                                      
1650   8                                                                      for(loop = 0; loop < 4; loop ++){
1651   9                                                                      
1652   9                                                                              if(datsParam[14 + loop * 3] == 0x80){   /*Ò»´ÎÐÔ¶¨Ê±ÅÐ¶Ï*///ÖÜÕ¼Î»Îª¿Õ£¬¶ø¶¨Ê±Æ÷±»´ò¿ª£¬ËµÃ÷ÊÇÒ»´ÎÐ
             -Ô
1653  10                                                                              
1654  10                                                                                      swTim_onShoot_FLAG      |= (1 << loop); //Ò»´ÎÐÔ¶¨Ê±±êÖ¾¿ªÆô
1655  10                                                                                      datsParam[14 + loop * 3] |= (1 << (systemTime_current.time_Week - 1)); //Ç¿ÐÐ½øÐÐµ±Ç°ÖÜÕ¼Î»£¬µ±´
             -ÎÖ´ÐÐÍê±ÏºóÇå³ý
1656  10                                                                              }
1657   9                                                                      }
1658   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_swTimeTab, &datsParam[14], 12); //¶¨Ê±±í
1659   8      
1660   8                                                              }break;
1661   7                                                              
1662   7                                                              case cmdConfigTim_onoffDelaySwConfig:{  /*¿ª¹ØÑÓÊ±*/
1663   8                                                              
1664   8                                                                      if(datsParam[14]){
1665   9                                                                      
1666   9                                                                              ifDelay_sw_running_FLAG |= (1 << 1);
1667   9                                                                              delayPeriod_onoff               = datsParam[14];
1668   9                                                                              
1669   9                                                                              delayUp_act                             = datsParam[15];
1670   9                                                                              
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 29  

1671   9                                                                              delayCnt_onoff                  = 0;
1672   9                                                                              
1673   9                                                                      }else{
1674   9                                                                      
1675   9                                                                              ifDelay_sw_running_FLAG &= ~(1 << 1);
1676   9                                                                              delayPeriod_onoff               = 0;
1677   9                                                                              delayCnt_onoff                  = 0;
1678   9                                                                      }
1679   8                                                                      
1680   8                                                              }break;
1681   7                                                              
1682   7                                                              case cmdConfigTim_closeLoopSwConfig:{   /*ÂÌÉ«¹¦ÄÜ(×Ô¶¯Ñ­»·¹Ø±Õ)*/
1683   8                                                              
1684   8                                                                      if(datsParam[14]){
1685   9                                                                      
1686   9                                                                              ifDelay_sw_running_FLAG |= (1 << 0);
1687   9                                                                              delayPeriod_closeLoop   = datsParam[14];
1688   9                                                                              delayCnt_closeLoop              = 0;
1689   9                                                                      }else{
1690   9                                                                      
1691   9                                                                              ifDelay_sw_running_FLAG &= ~(1 << 0);
1692   9                                                                              delayPeriod_closeLoop   = 0;
1693   9                                                                              delayCnt_closeLoop              = 0;
1694   9                                                                      }
1695   8                                                                      
1696   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_swDelayFLAG, &ifDelay_sw_running_FLAG, 1);
1697   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_periodCloseLoop, &delayPeriod_closeLoop, 1);
1698   8                                                                      
1699   8                                                              }break;         
1700   7      
1701   7                                                              case cmdConfigTim_nightModeSwConfig:{  /*Ò¹¼äÄ£Ê½ ±³¹â°ëÁÁ*/
1702   8                                                              
1703   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsParam[14], 6);   //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢
1704   8                                                                      
1705   8                                                              }break;
1706   7                                                              
1707   7                                                              default:break;
1708   7                                                      }
1709   6                                                      
1710   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1711   6                                                      
1712   6                                              }break;
1713   5                                              
1714   5                                              case FRAME_MtoZIGBCMD_cmdCfg_ctrlEachO:{
1715   6                                              
1716   6                                                      u8 loop = 0;
1717   6                                                      u8 effective_oprate = datsParam[12]; //ÓÐÐ§²Ù×÷Êý¾ÝÕ¼Î»»ñÈ¡
1718   6                                                      
1719   6                                                      for(loop = 0; loop < clusterNum_usr; loop ++){
1720   7                                                      
1721   7                                                              if((effective_oprate >> loop) & 0x01){ //ÓÐÐ§Êý¾ÝÅÐ¶Ï
1722   8                                                              
1723   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_portCtrlEachOther + loop, &datsParam[14 + loop], 1);
1724   8                                                                      CTRLEATHER_PORT[loop] = datsParam[14 + loop];
1725   8                                                                      reConnectAfterDatsReq_IF = 1; //¼´¿Ì×¢²á»¥¿ØÍ¨Ñ¶´Ø¶Ë¿Ú
1726   8                                                              }
1727   7                                                      }
1728   6                                                      
1729   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1730   6                                              
1731   6                                              }break;
1732   5                                              
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 30  

1733   5                                              case FRAME_MtoZIGBCMD_cmdQue_ctrlEachO:{
1734   6                                              
1735   6                                                      u8 loop = 0;
1736   6                                                      
1737   6                                                      for(loop = 0; loop < clusterNum_usr; loop ++){
1738   7                                                      
1739   7                                                              EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther + loop, &paramTX_temp[14 + loop], 1);
1740   7                                                      }
1741   6                                                      
1742   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1743   6                                              
1744   6                                              }break;
1745   5                                                      
1746   5                                              case FRAME_MtoZIGBCMD_cmdCfg_ledBackSet:{
1747   6                                              
1748   6                                                      coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround, &datsParam[14], 1);
1749   6                                                      coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround + 1, &datsParam[15], 1);
1750   6                                                      tipsInsert_swLedBKG_ON  = datsParam[14];
1751   6                                                      tipsInsert_swLedBKG_OFF = datsParam[15];
1752   6                                                      
1753   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1754   6                                              
1755   6                                              }break;
1756   5                                              
1757   5                                              case FRAME_MtoZIGBCMD_cmdQue_ledBackSet:{
1758   6                                              
1759   6                                                      EEPROM_read_n(EEPROM_ADDR_ledSWBackGround, &paramTX_temp[14], 1);
1760   6                                                      EEPROM_read_n(EEPROM_ADDR_ledSWBackGround + 1, &paramTX_temp[15], 1);
1761   6                                                      
1762   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1763   6                                              
1764   6                                              }break;
1765   5                                              
1766   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioSet:{
1767   5      //                                              
1768   5      //                                              u16 xdata panid_Temp = ZigB_getPanIDCurrent(); //ÅäÖÃ»Ø¸´Ìí¼ÓPANID
1769   5      //                                      
1770   5      //                                              bit opt_result = swScenario_oprateSave(datsParam[12], datsParam[14]);
1771   5      //                                              if(opt_result)paramTX_temp[12] = 0;
1772   5      //                                              else paramTX_temp[12] = 0x0A; //³¡¾°ÉèÖÃÎÞÐ§»Ø¸´£¨³¡¾°´æ´¢ÒÑÂú£©
1773   5      //                                              
1774   5      //                                              paramTX_temp[14] = (u8)((panid_Temp & 0xFF00) >> 8);
1775   5      //                                              paramTX_temp[15] = (u8)((panid_Temp & 0x00FF) >> 0);
1776   5      //                                              
1777   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ£¨±¾µØ´æ´¢ÒÑ±»Õ¼Âú£©
1778   5      //                                      
1779   5      //                                      }break;
1780   5      //                                      
1781   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioCtl:{
1782   5      //                                              
1783   5      //                                              u8 sw_Act = swScenario_oprateCheck(datsParam[12]);
1784   5      //                                              if(sw_Act != SW_SCENCRAIO_ACTINVALID){ //ÈôË÷Òýµ½ÓÐÐ§²Ù×÷Î»
1785   5      //                                                      
1786   5      //                                                      swCommand_fromUsr.actMethod = relay_OnOff;
1787   5      //                                                      swCommand_fromUsr.objRelay = sw_Act;
1788   5      //                                              
1789   5      //                                                      paramTX_temp[12] = 0;
1790   5      //                                                      
1791   5      //                                              }else{ //ÈôÎÞ·¨Ë÷Òýµ½ÓÐÐ§²Ù×÷Î»
1792   5      //                                              
1793   5      //                                                      paramTX_temp[12] = 0x0A; //³¡¾°¿ØÖÆÎÞÐ§»Ø¸´£¨³¡¾°ºÅÎÞ·¨±»Ë÷Òý£©
1794   5      //                                              }
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 31  

1795   5      //                                      
1796   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1797   5      //                                      
1798   5      //                                      }break;
1799   5      //                                      
1800   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioDel:{
1801   5      //                                              
1802   5      //                                              swScenario_oprateDele(datsParam[12]);
1803   5      //                                              paramTX_temp[12] = 0;
1804   5      //                                      
1805   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1806   5      //                                      
1807   5      //                                      }break;
1808   5                                              
1809   5                                              default:{
1810   6                                              
1811   6                                                      respond_IF = 0;
1812   6                                              
1813   6                                              }break;
1814   5                                      }
1815   4                                      
1816   4                                      /*»Ø¸´ÏìÓ¦*/
1817   4                                      if(respond_IF){ //Êý¾Ý°ü»Ø¸´ÏìÓ¦¶¯×÷
1818   5                                      
1819   5                                              u8 datsTX_Len = 0;
1820   5                                              
1821   5                                              respond_IF = 0;
1822   5                                              
1823   5                                              datsTX_Len = dtasTX_loadBasic_CUST(dataFromRemote_IF,
1824   5                                                                                                                 paramTX_temp,
1825   5                                                                                                                 33,
1826   5                                                                                                                 FRAME_TYPE_StoM_RCVsuccess,
1827   5                                                                                                                 datsParam[3],
1828   5                                                                                                                 specialCmd_IF);
1829   5                                              
1830   5                                              heartBeatCount = 1; //»Ø¸´ÏìÓ¦µÖÏûÒ»´ÎÐÄÌø
1831   5                                              
1832   5                                              datsSend_request.nwkAddr = nwkAddr_from;
1833   5                                              datsSend_request.portPoint = port_from;
1834   5                                              memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
1835   5                                              memcpy(datsSend_request.datsTrans.dats, paramTX_temp, datsTX_Len);
1836   5                                              datsSend_request.datsTrans.datsLen = datsTX_Len;
1837   5                                              datsRcv_respond.datsTrans.datsLen = 0;
1838   5                                              devRunning_Status = status_dataTransRequestDatsSend;
1839   5                                      }
1840   4                              }
1841   3                      }break;
1842   2                      
1843   2                      /*ÐÄÌø_Íø¹ØÔÚÏß*/
1844   2                      case ZIGB_FRAMEHEAD_HEARTBEAT:{
1845   3                      
1846   3                              
1847   3                              
1848   3                      }break;
1849   2                      
1850   2                      /*ÐÄÌø_Íø¹ØÀëÏß*///internetÀëÏß£¬²»ÊÇzigbÍøÂçÀëÏß
1851   2                      case ZIGB_FRAMEHEAD_HBOFFLINE:{
1852   3                      
1853   3                              
1854   3                              
1855   3                      }break;
1856   2                      
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 32  

1857   2                      default:{}break;
1858   2              }
1859   1      }
1860          
1861          /*zigbeeÖ÷Ïß³Ì*///¶¯×÷×èÈû´óÓÚ200msµÄº¯Êý¶¼ÉèÎª×´Ì¬»úÔËÐÐ£¬ÆäËüÐ¡ÓÚ200msº¯Êý£¬×èÈûÎ¬³Ö£¬·ñÔò×´Ì¬»ú¸´ÔÓ¶È¼Ó
             -´ó
1862          void thread_dataTrans(void){
1863   1              
1864   1              u8 code cmd_datsComing[2] = {0x44, 0x81};
1865   1      
1866   1      #define dataLen_zigbDatsTrans 96
1867   1              u8 xdata paramTX_temp[dataLen_zigbDatsTrans] = {0};
1868   1              u8 xdata paramRX_temp[dataLen_zigbDatsTrans] = {0};
1869   1              
1870   1              static bit heartBeat_cmdFLG = 0; //ÐÄÌøÆæÅ¼±êÖ¾
1871   1              
1872   1              /*zigbÖ÷Ïß³ÌÏµÍ³Ê±¼ä¸üÐÂ*/
1873   1              if(!sysTimeReales_counter){ 
1874   2              
1875   2                      sysTimeReales_counter = PERIOD_SYSTIMEREALES;
1876   2                      getSystemTime_reales();
1877   2              }
1878   1              
1879   1              /*zigbÖ÷Ïß³Ì×´Ì¬»ú£º¸ù¾Ý×´Ì¬±êÖ¾ÔËÐÐ*/
1880   1              switch(devRunning_Status){
1881   2              
1882   2                      case status_passiveDataRcv:{
1883   3                              
1884   3                              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
1885   4                              
1886   4                                      devStatus_switch.statusChange_IF = 0;
1887   4                                      devRunning_Status = devStatus_switch.statusChange_standBy;
1888   4                                      
1889   4                                      break;
1890   4                              }
1891   3                              
1892   3                              {/*³õÊ¼»¯Ê±¼ä¸³Öµ*///½ö¿ª»ú¸³ÖµÒ»´Î£¬²»×öÊ±Çøµ÷Õû
1893   4                                      static bit FLG_timeSetInit = 1;
1894   4                                      
1895   4                                      if(FLG_timeSetInit){
1896   5                                      
1897   5                                              FLG_timeSetInit = 0;
1898   5                                              zigB_sysTimeSet(1533810700UL - 946713600UL, 0); //zigbeeÊ±¼ä´Á´Óunix¼ÍÔª946713600<2000/01/01 00:00:00
             ->¿ªÊ¼¼ÆËã
1899   5                                      }
1900   4                              }
1901   3                              
1902   3                              if(devTips_status == status_tipsNwkFind)tips_statusChangeToNormal(); //tips¸´Ô­(ÍøÂçÒÑ¼ÓÈë£¬»Ö¸´Õý³£tip
             -s)
1903   3              
1904   3                              //--------------------------------Ö÷×´Ì¬£ºÐÄÌø--------------------------------------------------------/
             -/
1905   3                              if(heartBeatCycle_FLG){
1906   4                              
1907   4                                      heartBeatCycle_FLG = 0;
1908   4                                      heartBeat_cmdFLG = !heartBeat_cmdFLG;
1909   4                                      
1910   4                                      memset(paramTX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans); //Çå»º´æ
1911   4                                      
1912   4                                      paramTX_temp[0] = ZIGB_FRAMEHEAD_HEARTBEAT;
1913   4                                      paramTX_temp[1] = 14;
1914   4                                      (heartBeat_cmdFLG)?(paramTX_temp[2] = FRAME_HEARTBEAT_cmdOdd):(paramTX_temp[2] = FRAME_HEARTBEAT_cmdEv
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 33  

             -en);
1915   4                                      memcpy(&paramTX_temp[4], &MAC_ID[1], 5);
1916   4                                      
1917   4                                      if(heartBeat_cmdFLG){ //Ææ°ü
1918   5                                      
1919   5                                              
1920   5                                      
1921   5                                      }else{ //Å¼°ü
1922   5                                      
1923   5                                              
1924   5                                      }
1925   4                                      
1926   4                                      datsSend_request.nwkAddr = 0; //½ö¶ÔÍø¹Ø·¢ËÍ£¬½øÐÐÊý¾Ý×ª·¢
1927   4                                      datsSend_request.portPoint = ZIGB_ENDPOINT_CTRLNORMAL; //³£¹æÊý¾Ý×ª·¢×¨ÓÃ¶Ë¿Ú
1928   4                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
1929   4                                      memcpy(datsSend_request.datsTrans.dats, paramTX_temp, 14);
1930   4                                      datsSend_request.datsTrans.datsLen = 14;
1931   4                                      datsRcv_respond.datsTrans.datsLen = 0;
1932   4                                      devRunning_Status = status_dataTransRequestDatsSend;
1933   4                                      
1934   4                                      return;
1935   4                              }
1936   3                              
1937   3                              //--------------------------------Ö÷×´Ì¬£ºÊý¾ÝÍÆËÍ---------------------------------------------------//
             -        
1938   3                              if(devActionPush_IF.push_IF){
1939   4                                      
1940   4                                      const bit dataFromRemote_IF = 1; //Ô¶³ÌÍÆËÍ
1941   4                                      const bit specialCmd_IF = 0; //·ÇÌØÊâÕ¼Î»
1942   4                                      
1943   4                                      u8 xdata datsTX_Len = 0;
1944   4                                      
1945   4                                      devActionPush_IF.push_IF = 0;
1946   4                                      
1947   4                                      memset(paramTX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans); //Çå»º´æ
1948   4                                      
1949   4                                      paramTX_temp[11] = devActionPush_IF.dats_Push; //ÍÆËÍÐÅÏ¢Ìî×°
1950   4      
1951   4      #if(DEBUG_LOGOUT_EN == 1)
1952   4                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1953   5                                              u8 xdata log_buf[64];
1954   5                                              
1955   5                                              sprintf(log_buf, "swData push:%02X.\n", (int)devActionPush_IF.dats_Push);
1956   5                                              PrintString1_logOut(log_buf);
1957   5                                      }                       
1958   4      #endif  
1959   4                                      datsTX_Len = dtasTX_loadBasic_CUST(dataFromRemote_IF,
1960   4                                                                                                         paramTX_temp,
1961   4                                                                                                         33,
1962   4                                                                                                         FRAME_TYPE_StoM_RCVsuccess,
1963   4                                                                                                         FRAME_MtoZIGBCMD_cmdControl,
1964   4                                                                                                         specialCmd_IF);
1965   4                              
1966   4                                      datsSend_request.nwkAddr = 0; //½ö¶ÔÍø¹Ø·¢ËÍ£¬½øÐÐÊý¾Ý×ª·¢
1967   4                                      datsSend_request.portPoint = ZIGB_ENDPOINT_CTRLNORMAL; //³£¹æÊý¾Ý×ª·¢×¨ÓÃ¶Ë¿Ú
1968   4                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
1969   4                                      memcpy(datsSend_request.datsTrans.dats, paramTX_temp, datsTX_Len);
1970   4                                      datsSend_request.datsTrans.datsLen = datsTX_Len;
1971   4                                      datsRcv_respond.datsTrans.datsLen = 0; //ÎÞÐèÔ¶¶ËÓ¦´ð
1972   4                                      devRunning_Status = status_dataTransRequestDatsSend; //Ö±½ÓÇÐ»»£¨²»×öÔ¤±¸¶¯×÷£©
1973   4      
1974   4                                      return; //Ô½¹ý±¾´Îµ÷¶È£¬Õ¼ÓÃÊý¾Ý·¢ËÍ×´Ì¬¸ü¸ÄÈ¨£¬ÏÈµ½ÏÈµÃ£¬ÆäËüÐèÒª¸ü¸ÄÊý¾Ý·¢ËÍÈ¨µÄÒµÎñ£¬·¢ËÍ×´Ì¬±£³Ö£¬
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 34  

             -µÈ´ýÏÈÐÐÒµÎñÊý¾Ý·¢ËÍÍê±Ï
1975   4                              }
1976   3                              
1977   3                              //--------------------------------Ö÷×´Ì¬£º»¥¿ØÍ¬²½---------------------------------------------------//
1978   3                              if(EACHCTRL_realesFLG){
1979   4                              
1980   4                                      if(devRunning_Status == status_passiveDataRcv){
1981   5                                      
1982   5                                              u8 idata loop;
1983   5                                              
1984   5                                              for(loop = 0; loop < 3; loop ++){ //Èý¸ö¿ª¹ØÎ»·Ö±ðÅÐ¶¨
1985   6                                              
1986   6                                                      if(EACHCTRL_realesFLG & (1 << loop)){ //»¥¿ØÓÐÐ§Î»ÅÐ¶Ï
1987   7                                                      
1988   7                                                              EACHCTRL_realesFLG &= ~(1 << loop); //»¥¿ØÓÐÐ§Î»ÇåÁã
1989   7                                                              
1990   7                                                              paramTX_temp[0] = (status_Relay >> loop) & 0x01; //¿ª¹Ø×´Ì¬Ìî×°
1991   7                                                              
1992   7                                                              if((CTRLEATHER_PORT[loop] > 0x10) && CTRLEATHER_PORT[loop] < 0xFF){ //ÊÇ·ñÎªÓÐÐ§»¥¿Ø¶Ë¿Ú
1993   8                                                              
1994   8                                                                      datsSend_request.nwkAddr = 0xffff; //¼ä½Ó×é²¥£¨¶Ô»¥¿Ø×¨ÓÃ¶Ë¿Ú½øÐÐ¹ã²¥£©
1995   8                                                                      datsSend_request.portPoint = CTRLEATHER_PORT[loop]; //»¥¿ØÎ»¶ÔÓ¦°ó¶¨¶Ë¿Ú
1996   8                                                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
1997   8                                                                      memcpy(datsSend_request.datsTrans.dats, paramTX_temp, 1);
1998   8                                                                      datsSend_request.datsTrans.datsLen = 1;
1999   8                                                                      datsRcv_respond.datsTrans.datsLen = 0; //ÎÞÐèÔ¶¶ËÓ¦´ð
2000   8                                                                      devRunning_Status = status_dataTransRequestDatsSend; //Ö±½ÓÇÐ»»£¨²»×öÔ¤±¸¶¯×÷£©
2001   8                                                                      
2002   8                                                                      return; //Ô½¹ý±¾´Îµ÷¶È£¬Õ¼ÓÃÊý¾Ý·¢ËÍ×´Ì¬¸ü¸ÄÈ¨£¬ÏÈµ½ÏÈµÃ£¬ÆäËüÐèÒª¸ü¸ÄÊý¾Ý·¢ËÍÈ¨µÄÒµÎñ£¬·¢ËÍ×´Ì¬±£
             -³Ö£¬µÈ´ýÏÈÐÐÒµÎñÊý¾Ý·¢ËÍÍê±Ï
2003   8                                                              }
2004   7                                                      }
2005   6                                              }
2006   5                                      }       
2007   4                              }
2008   3                              
2009   3                              //--------------------------------Ö÷×´Ì¬£ºÊý¾Ý½âÎöÏìÓ¦-----------------------------------------------//
2010   3                              if(uartRX_toutFLG){ //Êý¾Ý½ÓÊÕ(Ö¡³¬Ê±)
2011   4                                      
2012   4                                      uartRX_toutFLG = 0;
2013   4                                      
2014   4                                      /*ZigbeeÒ»¼¶Ð­ÒéºË¶Ô½âÎö*/
2015   4                                      if((datsRcv_ZIGB.rcvDats[0] == ZIGB_FRAME_HEAD) &&
2016   4                                              !memcmp(&datsRcv_ZIGB.rcvDats[2], cmd_datsComing, 2)){
2017   5                                              
2018   5                                              u16 idata datsFrom_addr = ((u16)(datsRcv_ZIGB.rcvDats[9]) << 8) | ((u16)(datsRcv_ZIGB.rcvDats[8]) << 
             -0); //Êý¾Ý·¢ËÍ·½ÍøÂçµØÖ·
2019   5                                              u8      idata srcPoint =  datsRcv_ZIGB.rcvDats[10];     //Ô´¶Ë
2020   5                                              u8      idata dstPoint =  datsRcv_ZIGB.rcvDats[11];     //Ô¶¶Ë
2021   5                                                      
2022   5                                              devTips_nwkZigb = nwkZigb_Normal; //zigbTips×´Ì¬ÏìÓ¦£¬Ö»Òª½ÓÊÕµ½zigbÊý¾Ý£¬tips×´Ì¬¾ÍÇÐ»»ÖÁÕý³£
2023   5                                              
2024   5                                              memset(paramRX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans);
2025   5                                              memcpy(paramRX_temp, &(datsRcv_ZIGB.rcvDats[21]), datsRcv_ZIGB.rcvDats[20]);
2026   5                                                      
2027   5                                              if(srcPoint > 0x10 && srcPoint < 0xff){ /*»¥¿Ø¶Ë¿Ú*/
2028   6                                                      
2029   6                                                      u8 statusRelay_temp = status_Relay; //µ±Ç°¿ª¹Ø×´Ì¬»º´æ
2030   6                                              
2031   6                                                      if((srcPoint == CTRLEATHER_PORT[0]) && (0 != CTRLEATHER_PORT[0])){ //¿ª¹ØÎ»1 »¥¿Ø°ó¶¨ÅÐ¶Ï
2032   7                                                      
2033   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 35  

2034   7                                                              statusRelay_temp &= ~(1 << 0); //¶¯×÷Î»»º´æÇåÁã
2035   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 0; //bit0 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
2036   7                                                      }
2037   6                                                      else
2038   6                                                      if((srcPoint == CTRLEATHER_PORT[1]) && (0 != CTRLEATHER_PORT[1])){ //¿ª¹ØÎ»2 »¥¿Ø°ó¶¨ÅÐ¶Ï
2039   7                                                      
2040   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2041   7                                                              statusRelay_temp &= ~(1 << 1); //¶¯×÷Î»»º´æÇåÁã
2042   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 1; //bit1 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
2043   7                                                      }
2044   6                                                      else
2045   6                                                      if((srcPoint == CTRLEATHER_PORT[2]) && (0 != CTRLEATHER_PORT[2])){ //¿ª¹ØÎ»3 »¥¿Ø°ó¶¨ÅÐ¶Ï
2046   7                                                      
2047   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2048   7                                                              statusRelay_temp &= ~(1 << 2); //¶¯×÷Î»»º´æÇåÁã
2049   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 2; //bit2 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
2050   7                                                      }
2051   6                                                      
2052   6                                                      devActionPush_IF.push_IF = 1; //ÍÆËÍÊ¹ÄÜ
2053   6                                              
2054   6                                              }else{ /*·Ç»¥¿Ø¶Ë¿Ú*///Ê£ÏÂ¾ÍÊÇÏµÍ³×¨ÓÃµÄ15¸ö¶Ë¿Ú
2055   6                                              
2056   6                                                      switch(srcPoint){
2057   7                                                              
2058   7                                                              /*³¡¾°¼¯Èº¶Ë¿Ú*/
2059   7                                                              case ZIGB_ENDPOINT_CTRLSECENARIO:{      
2060   8                                                              
2061   8                                                                      dataParing_scenarioCtrl(paramRX_temp); //³¡¾°¼¯Èº¿ØÖÆ½âÎö
2062   8                                                                      
2063   8                                                              }break;
2064   7                                                      
2065   7                                                              /*³£¹æ¿ØÖÆ×ª·¢¶Ë¿Ú*/
2066   7                                                              case ZIGB_ENDPOINT_CTRLNORMAL:{ 
2067   8                                                              
2068   8                                                                      if(datsFrom_addr == ZIGB_NWKADDR_CORDINATER){ //À´×ÔÐ­µ÷Æ÷
2069   9                                                                      
2070   9                                                                              dataParing_Nomal(paramRX_temp, datsFrom_addr, srcPoint); //³£¹æ½âÎö
2071   9                                                                      }
2072   8                                                                      
2073   8                                                              }break;
2074   7                                                              
2075   7                                                              /*zigbÏµÍ³½»»¥¶Ë¿Ú*/
2076   7                                                              case ZIGB_ENDPOINT_CTRLSYSZIGB:{        
2077   8                                                              
2078   8                                                                      dataParing_zigbSysCtrl(paramRX_temp); //ÏµÍ³¿ØÖÆ½âÎö
2079   8                                                                      
2080   8                                                              }break;
2081   7                                                                      
2082   7                                                              default:{
2083   8                                                              
2084   8                                                                      
2085   8                                                                      
2086   8                                                              }break;
2087   7                                                      }
2088   6                                              }
2089   5                                      }
2090   4                              }
2091   3                              
2092   3                      }break;
2093   2                      
2094   2                      case status_nwkREQ:{
2095   3                      
C51 COMPILER V9.54   DATATRANS                                                             09/21/2018 11:10:01 PAGE 36  

2096   3                              //--------------------------------Ð­×´Ì¬£ºÍøÂçÇëÇó-----------------------------------------------//
2097   3                              devTips_nwkZigb = nwkZigb_nwkREQ;
2098   3                              zigB_nwkJoinRequest(1); //·Ç×èÈûÖ÷¶¯¼ÓÈë¸½½ü¿ª·ÅÍøÂç
2099   3                              
2100   3                      }break;
2101   2                              
2102   2                      case status_nwkReconnect:{
2103   3                      
2104   3                              //--------------------------------Ð­×´Ì¬£ºµôÏß´¦Àí-----------------------------------------------//
2105   3                              devTips_nwkZigb = nwkZigb_reConfig;
2106   3                              zigB_nwkJoinRequest(0); //·Ç×èÈûÖØÁ¬
2107   3                              
2108   3                      }break;
2109   2                      
2110   2                      case status_dataTransRequestDatsSend:{
2111   3                              
2112   3                              //--------------------------------Ð­×´Ì¬£ºÊý¾ÝÇëÇó-----------------------------------------------//
2113   3                              dataTransRequest_datsSend(); //·Ç×èÈûÔ¶¶ËÊý¾Ý´«Êä
2114   3                      
2115   3                      }break;
2116   2                      
2117   2                      case status_devNwkHold:{
2118   3                      
2119   3                              //--------------------------------Ð­×´Ì¬£ºÍøÂç¹ÒÆð-----------------------------------------------//
2120   3                              devTips_nwkZigb = nwkZigb_hold;
2121   3                              function_devNwkHold();
2122   3                              
2123   3                      }break;
2124   2                              
2125   2                      default:{
2126   3                      
2127   3                              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
2128   4                              
2129   4                                      devStatus_switch.statusChange_IF = 0;
2130   4                                      devRunning_Status = devStatus_switch.statusChange_standBy;
2131   4                                      
2132   4                                      break;
2133   4                              }
2134   3                      
2135   3                      }break;
2136   2              }
2137   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6909    ----
   CONSTANT SIZE    =   2952    ----
   XDATA SIZE       =    287    1566
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12     140
   IDATA SIZE       =   ----       8
   BIT SIZE         =      7      17
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
