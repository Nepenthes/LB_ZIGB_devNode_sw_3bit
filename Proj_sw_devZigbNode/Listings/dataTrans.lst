C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DATATRANS
OBJECT MODULE PLACED IN .\Output\dataTrans.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE dataTrans\dataTrans.c OMF2 ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(
                    -.\Usr;.\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\dataTrans.lst) OBJECT(.\Out
                    -put\dataTrans.obj)

line level    source

   1          #include "dataTrans.h"
   2          
   3          #include "string.h"
   4          #include "stdio.h"
   5          
   6          #include "eeprom.h"
   7          #include "USART.h"
   8          #include "delay.h"
   9          #include "Relay.h"
  10          
  11          #include "timerAct.h"
  12          #include "pars_Method.h"
  13          #include "dataManage.h"
  14          #include "Tips.h"
  15          
  16          /**********************±¾µØÎÄ¼þ±äÁ¿¶¨ÒåÇø************************/
  17          datsAttr_datsTrans xdata datsSend_request;//Ô¶¶ËÊý¾Ý´«ÊäÇëÇó»º´æ
  18          datsAttr_datsTrans xdata datsRcv_respond;//Ô¶¶ËÊý¾Ý´«ÊäÇëÇóµÈ´ýÏìÓ¦»º´æ»º´æ
  19          
  20          //zigbeeÔËÐÐ×´Ì¬ÇÐ»»±êÖ¾
  21          stt_statusChange xdata devStatus_switch = {0, status_NULL};
  22          //Êý¾ÝÇëÇóÍê³ÉºóÊÇ·ñÐèÒªÖØÆôÍøÂç
  23          bit reConnectAfterDatsReq_IF = 0; //ÓÃÓÚ»¥¿ØÍ¨Ñ¶´Ø¼´¿Ì×¢²áÌØÊâÇé¿öÏÂÊ¹ÓÃ
  24          
  25          bit coordinatorOnline_IF = 0; //Ð­µ÷Æ÷ÔÚÏß±êÖ¾
  26          
  27          //zigbÍøÂç¶¯×÷×¨ÓÃÊ±¼ä¼ÆÊý
  28          u16 xdata zigbNwkAction_counter = 0;
  29          
  30          //zigbÉè±¸ÍøÂç¹ÒÆðÊôÐÔ²ÎÊý
  31          attr_devNwkHold xdata devNwkHoldTime_Param = {0};
  32          
  33          //ÐÄÌø
  34          bit heartBeatCycle_FLG = 0;     //ÐÄÌøÖÜÆÚ´¥·¢
  35          u8      heartBeatCount     = 0; //ÐÄÌøÖÜÆÚ¼ÆÊý
  36          
  37          //´®¿Ú½ÓÊÕ³¬Ê±±êÖ¾
  38          bit uartRX_toutFLG      = 0;
  39          //´®¿Ú½ÓÊÕ³¬Ê±¼ÆÊý
  40          bit rxTout_count_EN = 0;
  41          u8  rxTout_count        = 0;
  42          //´®¿ÚÊý¾Ý»º´æ
  43          u8      datsRcv_length  = 0;
  44          uartTout_datsRcv xdata datsRcv_ZIGB = {{0}, 0};
  45          
  46          //zigbeeÍ¨ÐÅÏß³Ìµ±Ç°ÔËÐÐ×´Ì¬±êÖ¾
  47          threadRunning_Status devRunning_Status = status_NULL;
  48          
  49          void zigbUart_pinInit(void){
  50   1      
  51   1              //TXÍÆÍìÊä³ö
  52   1              P3M1 &= 0xFD;   
  53   1              P3M0 |= 0x02;   
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 2   

  54   1              
  55   1              //RX¸ß×èÊäÈë
  56   1              P3M1 |= 0x01;
  57   1              P3M0 &= 0xFE;
  58   1              
  59   1              //TXÍÆÍìÊä³ö
  60   1              P2M1 &= ~0x08;
  61   1              P2M0 |= 0x08;
  62   1      }
  63                  
  64          /*--------------------------------------------------------------*/
  65          void uartObjZigb_Init(void){
  66   1      
  67   1              EA = 0;
  68   1      
  69   1              PS = 1;
  70   1              SCON = (SCON & 0x3f) | UART_8bit_BRTx;
  71   1      
  72   1      {
  73   2              u32 j = (MAIN_Fosc / 4) / ZIGB_BAUND;   //°´1T¼ÆËã
  74   2                      j = 65536UL - j;
  75   2              
  76   2              TH2 = (u8)(j>>8);
  77   2              TL2 = (u8)j;
  78   2      }
  79   1              AUXR &= ~(1<<4);        //Timer stop
  80   1              AUXR |= 0x01;           //S1 BRT Use Timer2;
  81   1              AUXR &= ~(1<<3);        //Timer2 set As Timer
  82   1              AUXR |=  (1<<2);        //Timer2 set as 1T mode
  83   1      
  84   1              IE2  &= ~(1<<2);        //½ûÖ¹ÖÐ¶Ï
  85   1              AUXR &= ~(1<<3);        //¶¨Ê±
  86   1              AUXR |=  (1<<4);        //Timer run enable
  87   1      
  88   1              ES        = 1;
  89   1              REN   = 1;
  90   1              P_SW1 = (P_SW1 & 0x3f) | (UART1_SW_P30_P31 & 0xc0);
  91   1              
  92   1              memset(TX1_Buffer, 0, sizeof(char) * COM_TX1_Lenth);
  93   1      
  94   1              EA = 1;
  95   1      
  96   1              PrintString1("i'm UART1 for wifi data translate !!!\n");
  97   1              PrintString1_logOut("i'm UART1 for datsLog !!!\n");
  98   1      }
  99          
 100          ///*----------------------------
 101          //·¢ËÍ´®¿ÚÊý¾Ý
 102          //----------------------------*/
 103          //void uartObjWIFI_Send_Byte(u8 dat)    //´®¿Ú1
 104          //{
 105          //      TX1_write2buff(dat);
 106          //}
 107          
 108          //void uartObjWIFI_Send_String(char *s,unsigned char ucLength){  //´®¿Ú1
 109          //      
 110          //      uart1_datsSend(s, ucLength);
 111          //}
 112          
 113          //void rxBuff_WIFI_Clr(void){
 114          
 115          //      memset(rxBuff_WIFI, 0xff, sizeof(char) * COM_RX1_Lenth);
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 3   

 116          //      COM1.RX_Cnt = 0;
 117          //}
 118          
 119          /********************* UART1(WIIF)ÖÐ¶Ïº¯Êý_×Ô¶¨ÒåÖØ¹¹************************/
 120          void UART1_Rountine (void) interrupt UART1_VECTOR
 121          {
 122   1              
 123   1              if(RI)
 124   1              {
 125   2                      RI = 0;
 126   2                      if(COM1.B_RX_OK == 0)
 127   2                      {
 128   3                              
 129   3      //                      if(COM1.RX_Cnt >= COM_RX1_Lenth)        COM1.RX_Cnt = 0;
 130   3      //                      RX1_Buffer[COM1.RX_Cnt++] = SBUF;
 131   3      //                      COM1.RX_TimeOut = TimeOutSet1;
 132   3                              
 133   3                              if(!rxTout_count_EN){
 134   4                              
 135   4                                      rxTout_count_EN = 1;
 136   4                                      rxTout_count    = 0;
 137   4                                      datsRcv_length  = 0;
 138   4                                      
 139   4                                      memset(RX1_Buffer, 0xff, sizeof(char) * COM_RX1_Lenth);
 140   4                              }
 141   3                              
 142   3                              
 143   3                              RX1_Buffer[datsRcv_length ++]   = SBUF;
 144   3                              rxTout_count = 0;
 145   3                      }
 146   2              }
 147   1      
 148   1              if(TI)
 149   1              {
 150   2                      TI = 0;
 151   2                      if(COM1.TX_read != COM1.TX_write)
 152   2                      {
 153   3                              SBUF = TX1_Buffer[COM1.TX_read];
 154   3                              if(++COM1.TX_read >= COM_TX1_Lenth)             COM1.TX_read = 0;
 155   3                      }
 156   2                      else    COM1.B_TX_busy = 0;
 157   2              }
 158   1      }
 159          
 160          /* ×Ô¶¨ÒåÐ£Ñé*///×Ô¼Ò²úÆ·Ð­Òé²ã
 161          static 
 162          unsigned char frame_Check(unsigned char frame_temp[], u8 check_num){
 163   1        
 164   1              unsigned char loop              = 0;
 165   1              unsigned char val_Check = 0;
 166   1              
 167   1              for(loop = 0; loop < check_num; loop ++){
 168   2              
 169   2                      val_Check += frame_temp[loop];
 170   2              }
 171   1              
 172   1              val_Check  = ~val_Check;
 173   1              val_Check ^= 0xa7;
 174   1              
 175   1              return val_Check;
 176   1      }
 177          
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 4   

 178          /*´ËÊý¾Ý·â×°±ØÐëÔÚÊý¾Ý°ü·¢ËÍÇ°×îºóµ÷ÓÃ£¬×Ô¶¨Òå¶ÔÏó½øÐÐÊý¾Ý·â×°*///±ÜÃâÐ£Ñé±»ÌáÇ°¶ø³ö´í
 179          static 
 180          u8 dtasTX_loadBasic_CUST(bit ifRemoteDats,
 181                                                       u8 dats_Tx[],
 182                                                       u8 datsLen_TX,
 183                                                       u8 frame_Type,
 184                                                       u8 frame_CMD,
 185                                                       bit ifSpecial_CMD){
 186   1                                                         
 187   1              dats_Tx[2]      = frame_Type;
 188   1              dats_Tx[3]      = frame_CMD;
 189   1              
 190   1              if(!ifSpecial_CMD)dats_Tx[10] = SWITCH_TYPE;    //¿ª¹ØÀàÐÍÌî³ä
 191   1              
 192   1              memcpy(&dats_Tx[5], &MAC_ID[1], 5);     //MACÌî³ä
 193   1                                                        
 194   1              dats_Tx[4]      = frame_Check(&dats_Tx[5], 28);
 195   1                                                                 
 196   1              if(ifRemoteDats){
 197   2                      
 198   2                      u8 xdata dats_Temp[64] = {0};
 199   2              
 200   2                      dats_Tx[0] = ZIGB_FRAMEHEAD_CTRLREMOTE;
 201   2                      dats_Tx[1]      = datsLen_TX + 12;
 202   2                      
 203   2                      memcpy(dats_Temp, &dats_Tx[1], datsLen_TX - 13);
 204   2                      memset(&dats_Tx[1], 0, datsLen_TX - 1);
 205   2                      memcpy(&dats_Tx[13], dats_Temp, datsLen_TX - 13);
 206   2                      memcpy(&dats_Tx[1], MAC_ID_DST, 6);
 207   2                      memcpy(&dats_Tx[8], &MAC_ID[1], 5);
 208   2                      
 209   2                      return 45;
 210   2                      
 211   2              }else{
 212   2              
 213   2                      dats_Tx[0]      = ZIGB_FRAMEHEAD_CTRLLOCAL;
 214   2                      dats_Tx[1]      = datsLen_TX;
 215   2                      
 216   2                      return 33;
 217   2              }
 218   1      }
 219          
 220          /*Êý¾ÝÒì»òÐ£Ñé*///ZNPÐ­Òé²ã
 221          static 
 222          u8 XORNUM_CHECK(u8 buf[], u8 length){
 223   1      
 224   1              u8 loop = 0;
 225   1              u8 valXOR = buf[0];
 226   1              
 227   1              for(loop = 1;loop < length;loop ++)valXOR ^= buf[loop];
 228   1              
 229   1              return valXOR;
 230   1      }
 231          
 232          /*zigbeeÊý¾ÝÖ¡¼ÓÔØ*/
 233          static 
 234          u8 ZigB_TXFrameLoad(u8 frame[],u8 cmd[],u8 cmdLen,u8 dats[],u8 datsLen){                
 235   1      
 236   1              const u8 frameHead = ZIGB_FRAME_HEAD;   //ZNP,SOFÖ¡Í·
 237   1              u8 xor_check = datsLen;                                 //Òì»òÐ£Ñé£¬Ö¡Î²
 238   1              u8 loop = 0;
 239   1              u8 ptr = 0;
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 5   

 240   1              
 241   1              frame[ptr ++] = frameHead;
 242   1              frame[ptr ++] = datsLen;
 243   1              
 244   1              memcpy(&frame[ptr],cmd,cmdLen);
 245   1              ptr += cmdLen;
 246   1              for(loop = 0;loop < cmdLen;loop ++)xor_check ^= cmd[loop];
 247   1      
 248   1              memcpy(&frame[ptr],dats,datsLen);
 249   1              ptr += datsLen;
 250   1              for(loop = 0;loop < datsLen;loop ++)xor_check ^= dats[loop];    
 251   1              
 252   1              frame[ptr ++] = xor_check;
 253   1              
 254   1              return ptr;
 255   1      }
 256          
 257          /*zigbeeµ¥Ö¸ÁîÊý¾ÝÇëÇó£¬·µ»ØÓ¦´ðÊý¾Ý³¤¶È*/
 258          static 
 259          u8 zigb_datsRequest( u8 frameREQ[],             //ÇëÇóÖ¡
 260                                                   u8 frameREQ_Len,       //ÇëÇóÖ¡³¤
 261                                                   u8 resp_cmd[2],        //ËùÐèÓ¦´ðÖ¸Áî
 262                                                   u8 resp_dats[],        //Ó¦´ðÊý¾Ý»º´æ
 263                                                   u8 loopReapt,u16 timeWait){    //Ñ­»·´ÎÊý£¬µ¥´ÎµÈ´ýÊ±¼ä
 264   1                                                
 265   1              u16 Local_Delay = timeWait;             
 266   1              u8      loop = 0;
 267   1                                                       
 268   1              for(loop = 0;loop < loopReapt;loop ++){
 269   2              
 270   2                      uartRX_toutFLG = 0;
 271   2                      zigbNwkAction_counter = timeWait;       
 272   2                  uartZigB_datsSend(frameREQ, frameREQ_Len);
 273   2                      
 274   2                      while(zigbNwkAction_counter){ //¶¨Ê±Æ÷ÖÐ¶ÏÄÚ½øÐÐµ¹¼ÆÊ±
 275   3      
 276   3                              if(uartRX_toutFLG){
 277   4                              
 278   4                                      uartRX_toutFLG = 0;
 279   4                                      
 280   4                                      if(!memcmp(&(datsRcv_ZIGB.rcvDats[2]), resp_cmd, 2)){
 281   5                                      
 282   5                                              memcpy(resp_dats, datsRcv_ZIGB.rcvDats, datsRcv_ZIGB.rcvDatsLen);
 283   5                                              return datsRcv_ZIGB.rcvDatsLen;
 284   5                                              
 285   5                                      }
 286   4                              }
 287   3                      }
 288   2              }       
 289   1      
 290   1              return 0;
 291   1      }
 292          
 293          /*zigbeeµ¥Ö¸ÁîÏÂ·¢¼°ÏìÓ¦ÑéÖ¤*///×èÈû
 294          bit zigb_VALIDA_INPUT(u8 REQ_CMD[2],            //Ö¸Áî
 295                                                    u8 REQ_DATS[],                //Êý¾Ý
 296                                                    u8 REQdatsLen,                //Êý¾Ý³¤¶È
 297                                                    u8 ANSR_frame[],              //ÏìÓ¦Ö¡
 298                                                    u8 ANSRdatsLen,               //ÏìÓ¦Ö¡³¤¶È
 299                                                    u8 times,u16 timeDelay){      //Ñ­»·´ÎÊý£¬µ¥´ÎµÈ´ýÊ±¼ä
 300   1                                                 
 301   1      #define dataLen_validaInput     96
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 6   

 302   1              u8 xdata dataTXBUF[dataLen_validaInput] = {0};
 303   1              u8      loop = 0;
 304   1              u8      datsTX_Len;
 305   1      
 306   1              datsTX_Len = ZigB_TXFrameLoad(dataTXBUF,REQ_CMD, 2, REQ_DATS, REQdatsLen);
 307   1      
 308   1              for(loop = 0;loop < times;loop ++){
 309   2              
 310   2                      uartRX_toutFLG = 0;
 311   2                      zigbNwkAction_counter = timeDelay;
 312   2                      uartZigB_datsSend(dataTXBUF, datsTX_Len);
 313   2                      
 314   2                      while(zigbNwkAction_counter){ //¶¨Ê±Æ÷ÖÐ¶ÏÄÚ½øÐÐµ¹¼ÆÊ±
 315   3                              
 316   3                              if(uartRX_toutFLG){
 317   4                              
 318   4                                      uartRX_toutFLG = 0;
 319   4                                      
 320   4                                      if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ANSR_frame, ANSRdatsLen)){
 321   5                                      
 322   5                                              delayMs(2);
 323   5                                              return 1;
 324   5                                      }
 325   4                              }
 326   3                      }
 327   2              }
 328   1              
 329   1              return 0;
 330   1      }
 331          
 332          ///*zigbeeÍ¨ÐÅ´ØÉèÖÃ*///×èÈû
 333          //bit zigb_clusterSet(u16 deviveID, u8 endPoint){
 334          
 335          //      datsAttr_ZigbInit code default_param = {{0x24,0x00},{0x0E,0x0D,0x00,0x0D,0x00,0x0D,0x00,0x01,0x00,0x00,
             -0x01,0x00,0x00},0x0D,{0xFE,0x01,0x64,0x00,0x00,0x65},0x06,300};       //Êý¾Ý´Ø×¢²á,Ä¬ÈÏ²ÎÊý
 336          //      u8 code frameResponse_Subs[6] = {0xFE,0x01,0x64,0x00,0xB8,0xDD}; //ÏìÓ¦Ö¡Ìæ²¹£¬ÈôÊý¾Ý´ØÒÑ¾­×¢²á
 337          //              
 338          //#define       dataLen_zigbClusterSet  64
 339          //      u8 xdata paramTX_temp[dataLen_zigbClusterSet] = {0};
 340          //      
 341          //      bit setResult = 0;
 342          //      
 343          //      memcpy(paramTX_temp, default_param.zigbInit_reqDAT, default_param.reqDAT_num);
 344          //      paramTX_temp[0] = endPoint;
 345          //      paramTX_temp[3] = (u8)((deviveID & 0x00ff) >> 0);
 346          //      paramTX_temp[4] = (u8)((deviveID & 0xff00) >> 8);
 347          //      
 348          //      setResult =  zigb_VALIDA_INPUT( (u8 *)default_param.zigbInit_reqCMD,
 349          //                                                                      (u8 *)paramTX_temp,
 350          //                                                                      default_param.reqDAT_num,
 351          //                                                                      (u8 *)default_param.zigbInit_REPLY,
 352          //                                                                      default_param.REPLY_num,
 353          //                                                                      2,              //2´ÎÒÔÄÚÃ»ÓÐÕýÈ·ÏìÓ¦¾ÍÊ§°Ü
 354          //                                                                      default_param.timeTab_waitAnsr);
 355          //      
 356          //      if(setResult)return setResult;
 357          //      else{
 358          //      
 359          //              return zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 360          //                                                               (u8 *)paramTX_temp,
 361          //                                                               default_param.reqDAT_num,
 362          //                                                               (u8 *)frameResponse_Subs,
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 7   

 363          //                                                               6,
 364          //                                                               2,             //2´ÎÒÔÄÚÃ»ÓÐÕýÈ·ÏìÓ¦¾ÍÊ§°Ü
 365          //                                                               default_param.timeTab_waitAnsr);
 366          //      }
 367          //}
 368          
 369          ///*zigbeeÖØÐÂÈëÍø*///×èÈûº¯Êý£¬½ö¹©²âÊÔÊ¹ÓÃ
 370          //bit ZigB_NwkJoin(u16 PANID, u8 CHANNELS){
 371          
 372          //#define       cmdNum_zigbNwkJoin      8       
 373          //      
 374          //#define        loop_PANID             5
 375          //#define        loop_CHANNELS  6
 376          
 377          //      datsAttr_ZigbInit code ZigbInit_dats[cmdNum_zigbNwkJoin] = {
 378          //              
 379          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¸´Î»
 380          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¸´Î»
 381          //              {       {0x26,0x05},    {0x03,0x01,0x03},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //¼Ä´æÆ÷³
             -õÊ¼»¯£¬È«²¿Çå¿Õ
 382          //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      
             -//¶þ´Î¸´Î»
 383          //              
 384          ////            {       {0x26,0x05},    {0x87,0x01,0x00},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«É
             -èÖÃ£¨Ð­µ÷Æ÷£©
 385          //              {       {0x26,0x05},    {0x87,0x01,0x01},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨Â·ÓÉÆ÷£©
 386          ////            {       {0x26,0x05},    {0x87,0x01,0x02},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«É
             -èÖÃ£¨ÖÕ¶Ë£©
 387          //              
 388          //              {       {0x27,0x02},    {0x34,0x12},                    0x02,   {0xFE,0x01,0x67,0x02,0x00,0x64},                                                        0x06,   500             },      //PAN_ID¼Ä´æÆ
             -÷ÉèÖÃ
 389          //              {       {0x27,0x03},    {0x00,0x80,0x00,0x00},  0x04,   {0xFE,0x01,0x67,0x03,0x00,0x65},                                                        0x06,   500             },      //ÐÅµ
             -À¼Ä´æÆ÷ÅäÖÃ
 390          ////            {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x09,0x8D},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È
             -¶¨½ÇÉ«Ð­µ÷Æ÷£¨Ð­µ÷Æ÷ÏìÓ¦£©
 391          //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x07,0x83},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨Â·ÓÉÆ÷ÏìÓ¦£©
 392          ////            {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x06,0x82},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È
             -¶¨½ÇÉ«Ð­µ÷Æ÷£¨ÖÕ¶ËÏìÓ¦£©
 393          //      };
 394          //      
 395          //#define       dataLen_zigbNwkJoin 64
 396          //      u8 xdata paramTX_temp[dataLen_zigbNwkJoin] = {0};
 397          //      
 398          //      u8  loop;
 399          //      u32 chnl_temp = 0x00000800UL << CHANNELS;
 400          //      
 401          //      for(loop = 1; loop < cmdNum_zigbNwkJoin; loop ++){
 402          //              
 403          //              memset(paramTX_temp, 0, dataLen_zigbNwkJoin * sizeof(u8));
 404          //              
 405          //              switch(loop){   //×ÔÑ¡²ÎÊý&Ä¬ÈÏ²ÎÊý
 406          //              
 407          //                      case loop_PANID:{
 408          //                      
 409          //                              paramTX_temp[0] = (u8)((PANID & 0x00ff) >> 0);
 410          //                              paramTX_temp[1] = (u8)((PANID & 0xff00) >> 8);
 411          //                              
 412          //                      }break;
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 8   

 413          //                      
 414          //                      case loop_CHANNELS:{
 415          //                      
 416          //                              paramTX_temp[0] = (u8)((chnl_temp & 0x000000ff) >>  0);
 417          //                              paramTX_temp[1] = (u8)((chnl_temp & 0x0000ff00) >>  8);
 418          //                              paramTX_temp[2] = (u8)((chnl_temp & 0x00ff0000) >> 16);
 419          //                              paramTX_temp[3] = (u8)((chnl_temp & 0xff000000) >> 24);
 420          //                              
 421          //                      }break;
 422          //                      
 423          //                      default:{
 424          //                      
 425          //                              memcpy(paramTX_temp,ZigbInit_dats[loop].zigbInit_reqDAT,ZigbInit_dats[loop].reqDAT_num);
 426          //                              
 427          //                      }break;
 428          //              }
 429          //      
 430          //              delayMs(100);
 431          //              if(0 == zigb_VALIDA_INPUT((u8 *)ZigbInit_dats[loop].zigbInit_reqCMD,
 432          //                                                                (u8 *)paramTX_temp,
 433          //                                                                ZigbInit_dats[loop].reqDAT_num,
 434          //                                                                (u8 *)ZigbInit_dats[loop].zigbInit_REPLY,
 435          //                                                                ZigbInit_dats[loop].REPLY_num,
 436          //                                                                3,
 437          //                                                                ZigbInit_dats[loop].timeTab_waitAnsr)
 438          //                                                               )loop = 0;
 439          //      }
 440          //      
 441          //      return zigb_clusterSet(13, 13); //Éè±¸ID 13£¬ÖÕ¶Ëµã 13£»
 442          //}
 443          
 444          /*zigbee Ö÷¶¯¿ª·ÅÍøÂç*///×èÈû
 445          bit ZigB_nwkOpen(bit openIF, u8 openTime){
 446   1      
 447   1              datsAttr_ZigbInit code default_param = {{0x26,0x08}, {0xFC,0xFF,0x00}, 0x03, {0xFE,0x01,0x66,0x08,0x00,0x
             -6F}, 0x06, 150}; //zigbeeÖ¸ÁîÏÂ´ïÄ¬ÈÏ²ÎÊý
 448   1              
 449   1              bit resultSet = 0;
 450   1              
 451   1              u8 openTime_temp = 0;
 452   1              
 453   1      #define paramLen_zigbNwkOpen 3
 454   1              u8 xdata paramTX_temp[paramLen_zigbNwkOpen] = {0xFC,0xFF,0x00};
 455   1              
 456   1              (openIF)?(paramTX_temp[2] = openTime):(paramTX_temp[2] = 0);
 457   1              
 458   1              resultSet = zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 459   1                                                                        (u8 *)paramTX_temp,
 460   1                                                                        default_param.reqDAT_num,
 461   1                                                                        (u8 *)default_param.zigbInit_REPLY,
 462   1                                                                        default_param.REPLY_num,
 463   1                                                                        2,    //2´ÎÎÞ»Ø¸´ÎªÊ§°Ü
 464   1                                                                        default_param.timeTab_waitAnsr);
 465   1      
 466   1      #if(DEBUG_LOGOUT_EN == 1)       
 467   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 468   1      //              u8 xdata log_buf[64];
 469   1      //              
 470   1      //              sprintf(log_buf, "nwkOpen result:%d.\n", (int)resultSet);
 471   1      //              PrintString1_logOut(log_buf);
 472   1      //      }
 473   1      #endif
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 9   

 474   1              
 475   1              return resultSet;
 476   1      }
 477          
 478          /*zigbee PANID»ñÈ¡*///×èÈû
 479          static u16 ZigB_getPanIDCurrent(void){
 480   1      
 481   1              u16 PANID_temp = 0;
 482   1              
 483   1      #define paramLen_zigbPanIDGet 32
 484   1              u8 xdata paramTX_temp[paramLen_zigbPanIDGet] = {0};
 485   1              
 486   1              u8 code frameREQ_zigbPanIDGet[6] = {0xFE, 0x01, 0x26, 0x06, 0x06, 0x27};        //zigb PANID»ñÈ¡Ö¸ÁîÖ¡
 487   1              u8 code cmdResp_zigbPanIDGet[2]  = {0x66, 0x06};        //zigb PANID»ñÈ¡Ô¤ÆÚÏìÓ¦Ö¸Áî
 488   1              u8 datsResp_Len = 0;
 489   1      
 490   1              datsResp_Len = zigb_datsRequest(frameREQ_zigbPanIDGet, 6, cmdResp_zigbPanIDGet, paramTX_temp, 2, 300);
 491   1      
 492   1              if(datsResp_Len){
 493   2      
 494   2                      PANID_temp |= (((u16)(paramTX_temp[5]) << 0) & 0x00FF);
 495   2                      PANID_temp |= (((u16)(paramTX_temp[6]) << 8) & 0xFF00);
 496   2      
 497   2      //              printf_datsHtoA("[Tips_uartZigb]: resultDats:", local_datsParam->frameResp, local_datsParam->frameResp
             -Len);
 498   2              }
 499   1      
 500   1              return PANID_temp;
 501   1      }
 502          
 503          /*zigbeeÏµÍ³Ê±¼ä»ñÈ¡²¢¸üÐÂ*///×èÈû
 504          static bit getSystemTime_reales(void){
 505   1              
 506   1              bit resultOpreat = 0;
 507   1      
 508   1      #define paramLen_zigbSystimeGet 32
 509   1              u8 xdata paramTX_temp[paramLen_zigbSystimeGet] = {0};
 510   1              
 511   1              u8 code frameREQ_zigbSystimeGet[5] = {0xFE, 0x00, 0x21, 0x11, 0x30};    //zigb PANID»ñÈ¡Ö¸ÁîÖ¡
 512   1              u8 code cmdResp_zigbSystimeGet[2]  = {0x61, 0x11};      //zigb PANID»ñÈ¡Ô¤ÆÚÏìÓ¦Ö¸Áî
 513   1              u8 datsResp_Len = 0;
 514   1      
 515   1              datsResp_Len = zigb_datsRequest(frameREQ_zigbSystimeGet, 5, cmdResp_zigbSystimeGet, paramTX_temp, 2, 300)
             -;
 516   1              
 517   1              if(!datsResp_Len)resultOpreat = 0;
 518   1              else{
 519   2                      
 520   2                      u16 Y_temp16 = ((u16)paramTX_temp[13] << 0) | ((u16)paramTX_temp[14] << 8);
 521   2                      u8  Y_temp8 = 0;
 522   2                      u8  M_temp8 = 0;
 523   2                      
 524   2                      u8 Y = (u8)(Y_temp16 % 2000);
 525   2                      u8 M = paramTX_temp[11];
 526   2                      u8 D = paramTX_temp[12];
 527   2                      u8 W = 0;
 528   2                      
 529   2                      /*¼ÆËã»º´æ¸³Öµ*/
 530   2                      Y_temp8 = Y;
 531   2                      if(M == 1 || M == 2){ //Ò»ÔÂºÍ¶þÔÂµ±×÷ÉÏÒ»ÄêÊ®ÈýÔÂºÍÊ®ËÄÔÂ
 532   3                      
 533   3                              M_temp8 = M + 12;
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 10  

 534   3                              Y_temp8 --;
 535   3                      }
 536   2                      else M_temp8 = M;
 537   2                      
 538   2                      /*¿ªÊ¼¼ÆËã*/
 539   2                      W =      Y_temp8 + (Y_temp8 / 4) + 5 - 40 + (26 * (M_temp8 + 1) / 10) + D - 1;  //²ÌÀÕ¹«Ê½
 540   2                      W %= 7; 
 541   2                      
 542   2                      /*¼ÆËã½á¹û¸³Öµ*/
 543   2                      W?(systemTime_current.time_Week = W):(systemTime_current.time_Week = 7);
 544   2                      
 545   2                      systemTime_current.time_Month =         M;
 546   2                      systemTime_current.time_Day =           D;
 547   2                      systemTime_current.time_Year =          Y;
 548   2                      
 549   2                      systemTime_current.time_Hour =          paramTX_temp[8];
 550   2                      systemTime_current.time_Minute =        paramTX_temp[9];
 551   2                      systemTime_current.time_Second =        paramTX_temp[10];
 552   2                      
 553   2                      /*±¾µØÊ±¼äÎ¬³Ö¼ÆÊýÖµÐ£×¼¸üÐÂ*/
 554   2                      sysTimeKeep_counter = systemTime_current.time_Minute * 60 + systemTime_current.time_Second; //ÏµÍ³Ê±¼äÎ¬
             -³Ö¼ÆÊýÖµ¸üÐÂ
 555   2                      
 556   2                      resultOpreat = 1;
 557   2              }
 558   1              
 559   1      #if(DEBUG_LOGOUT_EN == 1)       
 560   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 561   1      //              u8 xdata log_buf[64];
 562   1      //              
 563   1      //              sprintf(log_buf, "sysTime reales result:%d.\n", (int)resultOpreat);
 564   1      //              PrintString1_logOut(log_buf);
 565   1      //      }
 566   1      #endif
 567   1              
 568   1              return resultOpreat;
 569   1      }
 570          
 571          /*zigbeeÏµÍ³Ê±¼äÉèÖÃ*///×èÈû
 572          static
 573          bit zigB_sysTimeSet(u32 timeStamp, bit timeZoneAdjust_IF){
 574   1      
 575   1              datsAttr_ZigbInit code default_param = {{0x21,0x10},{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
             -00},0x0B,{0xFE,0x01,0x61,0x10,0x00},0x05,100}; //zigbeeÖ¸ÁîÏÂ´ïÄ¬ÈÏ²ÎÊý
 576   1              u8 xdata timeStampArray[0x0B] = {0};
 577   1              bit resultSet = 0;
 578   1              u32 timeStamp_temp = timeStamp;
 579   1              
 580   1              if(timeZoneAdjust_IF){ //ÊÇ·ñÐèÒªÊ±Çøµ÷Õû
 581   2              
 582   2                      if(sysTimeZone_H <= 12){
 583   3                      
 584   3                              timeStamp_temp += (3600UL * (long)sysTimeZone_H + 60UL * (long)sysTimeZone_M); //Ê±ÇøÕý
 585   3                              
 586   3                      }else
 587   2                      if(sysTimeZone_H > 12 && sysTimeZone_H <= 24){
 588   3                      
 589   3                              timeStamp_temp -= (3600UL * (long)(sysTimeZone_H - 12) + 60UL * (long)sysTimeZone_M); //Ê±Çø¸º
 590   3                              
 591   3                      }else
 592   2                      if(sysTimeZone_H >= 30){
 593   3                      
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 11  

 594   3                              timeStamp_temp += (3600UL * (long)(sysTimeZone_H - 17) + 60UL * (long)sysTimeZone_M); //Ê±ÇøÌØÊâ
 595   3                      }
 596   2              }
 597   1      
 598   1              timeStampArray[0] = (u8)((timeStamp_temp & 0x000000ff) >> 0);
 599   1              timeStampArray[1] = (u8)((timeStamp_temp & 0x0000ff00) >> 8);
 600   1              timeStampArray[2] = (u8)((timeStamp_temp & 0x00ff0000) >> 16);
 601   1              timeStampArray[3] = (u8)((timeStamp_temp & 0xff000000) >> 24);
 602   1              
 603   1              resultSet = zigb_VALIDA_INPUT((u8 *)default_param.zigbInit_reqCMD,
 604   1                                                                        (u8 *)timeStampArray,
 605   1                                                                        default_param.reqDAT_num,
 606   1                                                                        (u8 *)default_param.zigbInit_REPLY,
 607   1                                                                        default_param.REPLY_num,
 608   1                                                                        2,    //2´ÎÎÞ»Ø¸´ÎªÊ§°Ü
 609   1                                                                        default_param.timeTab_waitAnsr);
 610   1              
 611   1      #if(DEBUG_LOGOUT_EN == 1)       
 612   1      //      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
 613   1      //              u8 xdata log_buf[64];
 614   1      //              
 615   1      //              sprintf(log_buf, "sysTime set result:%d.\n", (int)resultSet);
 616   1      //              PrintString1_logOut(log_buf);
 617   1      //      }
 618   1      #endif
 619   1              
 620   1              return resultSet;
 621   1      }
 622          
 623          ///*zigbeeÓ²¼þ¸´Î»³õÊ¼»¯*///×èÈû
 624          //bit ZigB_resetInit(void){
 625          
 626          //#define zigbInit_loopTry              3
 627          //#define zigbInit_onceWait     5000
 628          
 629          //      u8 code initCmp_Frame[11] = {0xFE, 0x06, 0x41, 0x80, 0x01, 0x02, 0x00, 0x02, 0x06, 0x03, 0xC3};
 630          //      
 631          //      u8      loop = 0;
 632          //      u16 timeWait = 0;
 633          //      
 634          //      for(loop = 0; loop < zigbInit_loopTry; loop ++){
 635          //      
 636          //              zigbPin_RESET = 0;
 637          //              delayMs(100);
 638          //              zigbPin_RESET = 1;
 639          //              
 640          //              timeWait = zigbInit_onceWait;
 641          //              while(timeWait --){
 642          //              
 643          //                      delayMs(2);     //±ØÐëÑÓÊ±
 644          //                      if(uartRX_toutFLG){
 645          //                      
 646          //                              uartRX_toutFLG = 0;
 647          //                              
 648          //                              if(!memcmp(datsRcv_ZIGB.rcvDats, initCmp_Frame, 11)){
 649          //                              
 650          //                                      return 1;
 651          //                                      
 652          //                              }else{
 653          //                                      
 654          //                                      delayMs(1);     //±ØÐëÑÓÊ±
 655          //                              }
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 12  

 656          //                      }
 657          //              }
 658          //      }
 659          //      
 660          //      return 0;
 661          //}
 662          
 663          ///*zigbee³õÊ¼»¯×Ô¼ì*///×èÈû
 664          //bit ZigB_inspectionSelf(void){        
 665          //      
 666          //#define       paramLen_zigbInspection 64
 667          //      u8 xdata paramTX_temp[paramLen_zigbInspection] = {0};
 668          //      
 669          ////    bit REQResult = 0;
 670          //      
 671          ////    u8 code frameREQ_zigbStatusCheck[5] = {0xFE, 0x00, 0x27, 0x00, 0x27};   //zigb×´Ì¬²éÑ¯Ö¸ÁîÖ¡
 672          ////    u8 code cmdResp_zigbStatusCheck[2]      = {0x67, 0x00}; //zigb×´Ì¬²éÑ¯ÏìÓ¦Ö¸Áî
 673          //      u8 code frameREQ_zigbJoinNWK[5]         = {0xFE, 0x00, 0x26, 0x00, 0x26};       //zigb¼¤»îÍøÂçÖ¸ÁîÖ¡
 674          //      u8 code cmdResp_zigbJoinNWK[2]          = {0x45, 0xC0}; //zigb¼¤»îÍøÂçÏìÓ¦Ö¸Áî
 675          //      u8 datsResp_Len = 0;
 676          //      
 677          ////    datsResp_Len = zigb_datsRequest(frameREQ_zigbStatusCheck, 5, cmdResp_zigbStatusCheck, paramTX_temp, 2
             -, 500);
 678          ////    if(paramTX_temp[16] == 0x07)REQResult
 679          //      
 680          //      datsResp_Len = zigb_datsRequest(frameREQ_zigbJoinNWK, 5, cmdResp_zigbJoinNWK, paramTX_temp, 2, 5000);
 681          //      if(paramTX_temp[4] == 0x07)return (zigb_clusterSet(13, 13) & zigb_clusterSet(13, 14));  //Éè±¸ID 13£¬ÖÕ¶
             -Ëµã 13£»        
 682          //      else{
 683          //      
 684          //              return 0;
 685          //      }
 686          //}
 687          
 688          /*zigbee·Ç×èÈûÈëÍøÇëÇó×´Ì¬»ú*///·Ç×èÈû ---ÐÅµÀÄ¬ÈÏµÚËÄÐÅµÀ
 689          static 
 690          void zigB_nwkJoinRequest(bit reJoin_IF){
 691   1      
 692   1      #define cmdNum_zigbNwkREQ       9       
 693   1      
 694   1              datsAttr_ZigbInit code ZigbInit_dats[cmdNum_zigbNwkREQ] = {
 695   1      
 696   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¸´Î»(Ó²¼þ)
 697   1      //              {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x00,0x02,0x00,0x02,0x06,0x03,0xC2},       0x0B,   4000    },      
             -//¸´Î»(Ìæ²¹)
 698   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¸´Î»(Èí¼þ)
 699   1                      {       {0x26,0x05},    {0x03,0x01,0x03},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //¼Ä´æÆ÷³õÊ
             -¼»¯£¬È«²¿Çå¿Õ
 700   1                      {       {0x46,0x09},    {0},                                    0x00,   {0xFE,0x06,0x41,0x80,0x01,0x02,0x00,0x02,0x06,0x03,0xC3},       0x0B,   4000    },      //
             -¶þ´Î¸´Î»(Èí¼þ)
 701   1                      
 702   1      //              {       {0x26,0x05},    {0x87,0x01,0x00},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨Ð­µ÷Æ÷£©
 703   1                      {       {0x26,0x05},    {0x87,0x01,0x01},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖÃ£
             -¨Â·ÓÉÆ÷£©
 704   1      //              {       {0x26,0x05},    {0x87,0x01,0x02},               0x03,   {0xFE,0x01,0x66,0x05,0x00,0x62},                                                        0x06,   500             },      //½ÇÉ«ÉèÖ
             -Ã£¨ÖÕ¶Ë£©
 705   1                      
 706   1                      {       {0x27,0x02},    {0xFF,0xFF},                    0x02,   {0xFE,0x01,0x67,0x02,0x00,0x64},                                                        0x06,   500             },      //PAN_ID¼Ä´æÆ÷É
             -èÖÃ
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 13  

 707   1                      {       {0x27,0x03},    {0x00,0x80,0x00,0x00},  0x04,   {0xFE,0x01,0x67,0x03,0x00,0x65},                                                        0x06,   500             },      //ÐÅµÀ¼
             -Ä´æÆ÷ÅäÖÃ
 708   1      //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x09,0x8D},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨Ð­µ÷Æ÷ÏìÓ¦£©
 709   1                      {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x07,0x83},                                                        0x06,   8000    },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨½ÇÉ
             -«Ð­µ÷Æ÷£¨Â·ÓÉÆ÷ÏìÓ¦£©
 710   1      //              {       {0x26,0x00},    {0},                                    0x00,   {0xFE,0x01,0x45,0xC0,0x06,0x82},                                                        0x06,   12000   },      //¿ªÊ¼ÈëÍø£¬ÒÔ¼È¶¨
             -½ÇÉ«Ð­µ÷Æ÷£¨ÖÕ¶ËÏìÓ¦£©
 711   1                      {       {0x26,0x08},    {0xFC,0xFF,0x00},               0x03,   {0xFE,0x01,0x66,0x08,0x00,0x6F},                                                        0x06,   150             },  //¹Ø±Õ
             -ÍøÂç
 712   1              };
 713   1              
 714   1              datsAttr_ZigbInit code defaultParam_clusterRegister = {{0x24,0x00},{0x0E,0x0D,0x00,0x0D,0x00,0x0D,0x00,0x
             -01,0x00,0x00,0x01,0x00,0x00},0x0D,{0xFE,0x01,0x64,0x00,0x00,0x65},0x06,500};  //Êý¾Ý´Ø×¢²á,Ä¬ÈÏ²ÎÊý
 715   1              u8 code frameResponseSubs_clusterRegister[6] = {0xFE,0x01,0x64,0x00,0xB8,0xDD}; //ÏìÓ¦Ö¡Ìæ²¹£¬ÈôÊý¾Ý´ØÒÑ¾
             -­×¢²á
 716   1              
 717   1      #define clusterNum_default 3
 718   1              datsAttr_clusterREG code cluster_Default[clusterNum_default] = {
 719   1              
 720   1                      {ZIGB_ENDPOINT_CTRLSECENARIO, zigbDatsDefault_ClustID}, 
 721   1                      {ZIGB_ENDPOINT_CTRLNORMAL, zigbDatsDefault_ClustID}, 
 722   1                      {ZIGB_ENDPOINT_CTRLSYSZIGB, zigbDatsDefault_ClustID}
 723   1              };
 724   1              
 725   1      #define dataLen_zigbNwkREQ 64
 726   1              u8 xdata paramTX_temp[dataLen_zigbNwkREQ] = {0};
 727   1              
 728   1              static u8 step_CortexA = 0,
 729   1                                step_CortexB = 0;
 730   1              static u8 reactionLoop = 0;
 731   1              
 732   1              u8 datsTX_Len = 0;
 733   1              
 734   1              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
 735   2              
 736   2                      devStatus_switch.statusChange_IF = 0;
 737   2                      devRunning_Status = devStatus_switch.statusChange_standBy;
 738   2                      
 739   2                      step_CortexA = 0;
 740   2                      step_CortexB = 0;
 741   2                      reactionLoop = 0;
 742   2                      zigbPin_RESET = 1;
 743   2                      
 744   2                      return;
 745   2              }
 746   1              
 747   1              if(step_CortexA > (cmdNum_zigbNwkREQ + clusterNum_usr + clusterNum_default)){ //ÄÚ²¿×´Ì¬Íê³É
 748   2              
 749   2                      step_CortexA = 0;
 750   2                      step_CortexB = 0;
 751   2                      reactionLoop = 0;
 752   2                      zigbPin_RESET = 1;
 753   2                      
 754   2                      sysTimeReales_counter = PERIOD_SYSTIMEREALES; //systime¸üÐÂÖÜÆÚÖØÖÃ£¬·ÀÖ¹¶àÖ¸Áî¶ÂÈû³åÍ»
 755   2                      
 756   2                      devRunning_Status = status_passiveDataRcv; //Íâ²¿×´Ì¬ÇÐ»»
 757   2                      devTips_status = status_Normal; //Éè±¸ÏµÍ³tips×´Ì¬ÇÐ»»
 758   2                      
 759   2                      return;
 760   2              }
 761   1              
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 14  

 762   1              if(!reJoin_IF)if(step_CortexA == 0)step_CortexA = 7; //ÊÇ·ñÎªÖØÐÂÖ÷¶¯¼ÓÈëÐÂÍøÂç£¬·ñÔò²»½øÐÐÓ²¼þ¸´Î»(Ó²¼þ¸
             -´Î»½«µ¼ÖÂ±¾µØÊ±¼ä±»ÖØÖÃ)
 763   1              if((step_CortexA == 7) || (step_CortexA == 0))sysTimeReales_counter     = PERIOD_SYSTIMEREALES; //·Ç×èÈû¹Ø¼üÖ
             -¸Áî²»ÄÜ±»×èÈûÖ¸Áî´ò¶Ï£¨Ó²¼þ¸´Î» ºÍ ÈëÍøÊ± ÖÐ¶Ï×èÈûÖ¸ÁîÏÂ´ï£©
 764   1              if(step_CortexA == 0){ //ÌØÊâÖ¸Áî_Ó²¼þ¸´Î»:<0>
 765   2              
 766   2                      switch(step_CortexA){
 767   3                      
 768   3                              case 0:{ //Ê×ÌõÖ¸Áî£¬Ó²¼þ¸´Î»
 769   4                              
 770   4                                      switch(step_CortexB){
 771   5                                      
 772   5                                              case 0:{ //²½ÖèÒ»£ºÓ²¼þÀ­µÍ100ms
 773   6                                              
 774   6                                                      zigbPin_RESET = 0;
 775   6                                                      zigbNwkAction_counter = 200;
 776   6                                                      step_CortexB = 1;
 777   6                                              
 778   6                                              }break;
 779   5                                      
 780   5                                              case 1:{ //²½Öè¶þ£ºÓ²¼þÀ­µÍÍê±ÏºóÈ·ÈÏÓ¦´ðÖ¡Ê±³¤
 781   6                                              
 782   6                                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý
 783   7                                                      
 784   7                                                              zigbPin_RESET = 1;
 785   7                                                              zigbNwkAction_counter = 6000;
 786   7                                                              step_CortexB = 2;
 787   7                                                      }
 788   6                                                      
 789   6                                              }break;
 790   5                                              
 791   5                                              case 2:{ //²½Öè¶þ£ºÈ·ÈÏÓ¦´ðÖ¡
 792   6                                                      
 793   6                                                      if(!zigbNwkAction_counter)step_CortexB = 0; //·Ç×èÈûµÈ´ýÏìÓ¦
 794   6                                              
 795   6                                                      if(uartRX_toutFLG){
 796   7                                                      
 797   7                                                              uartRX_toutFLG = 0;
 798   7                                                              
 799   7                                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ZigbInit_dats[0].zigbInit_REPLY, ZigbInit_dats[0].RE
             -PLY_num)){
 800   8                              
 801   8                                                                      step_CortexB = 0;
 802   8                                                                      reactionLoop = 0;
 803   8                                                                      step_CortexA ++;
 804   8                                                              }
 805   7                                                      }
 806   6                                                      
 807   6                                              }break;
 808   5                                      }
 809   4                                      
 810   4                              }break;
 811   3                      }
 812   2              }else
 813   1              if(step_CortexA > 0 && step_CortexA < cmdNum_zigbNwkREQ){ //³£¹æÖ¸Áî:<1 - 9>
 814   2                      
 815   2      //              if(!reJoin_IF)if(step_CortexA == 2)step_CortexA = 7;    //ÊÇ·ñÎªÖØÐÂÖ÷¶¯¼ÓÈëÐÂÍøÂç£¬·ñÔòÖ»½øÐÐ±»¶¯ÍøÂç¼¤»
             -î
 816   2      
 817   2                      switch(step_CortexB){
 818   3                      
 819   3                              case 0:{
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 15  

 820   4                                      
 821   4                                      if(reactionLoop > 2){
 822   5                                              
 823   5                                              reactionLoop = 0;
 824   5                                              step_CortexA = 0;
 825   5                                              break;
 826   5                                      }
 827   4                                      
 828   4                                      datsTX_Len = ZigB_TXFrameLoad(paramTX_temp, 
 829   4                                                                                                ZigbInit_dats[step_CortexA].zigbInit_reqCMD, 
 830   4                                                                                                2, 
 831   4                                                                                                ZigbInit_dats[step_CortexA].zigbInit_reqDAT, 
 832   4                                                                                                ZigbInit_dats[step_CortexA].reqDAT_num);
 833   4                                      
 834   4                                      uartZigB_datsSend(paramTX_temp, datsTX_Len);
 835   4                                      
 836   4                                      zigbNwkAction_counter = ZigbInit_dats[step_CortexA].timeTab_waitAnsr;
 837   4                                      step_CortexB = 1;
 838   4                                      
 839   4                              }break;
 840   3                                      
 841   3                              case 1:{
 842   4                                      
 843   4                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ýÏìÓ¦
 844   5                                      
 845   5                                              reactionLoop ++;
 846   5                                              step_CortexB = 0;
 847   5                                      }
 848   4                                      else
 849   4                                      if(uartRX_toutFLG){
 850   5                                      
 851   5                                              uartRX_toutFLG = 0;
 852   5                                              
 853   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, ZigbInit_dats[step_CortexA].zigbInit_REPLY, ZigbInit_d
             -ats[step_CortexA].REPLY_num)){
 854   6                                              
 855   6                                                      step_CortexB = 0;
 856   6                                                      reactionLoop = 0;
 857   6                                                      step_CortexA ++;
 858   6                                              }
 859   5                                      }
 860   4                                      
 861   4                              }break;
 862   3                      }
 863   2                      
 864   2              }else
 865   1              if(step_CortexA >= cmdNum_zigbNwkREQ){ //ÌØÊâÖ¸Áî_³£¹æÍ¨ÐÅ´Ø×¢²á:<10 - n>
 866   2                      
 867   2                      u8 datsREG_cluster[16] = {0};
 868   2                      memcpy(datsREG_cluster, defaultParam_clusterRegister.zigbInit_reqDAT, defaultParam_clusterRegister.reqDA
             -T_num);
 869   2                      if(step_CortexA < (cmdNum_zigbNwkREQ + clusterNum_default)){ //Ä¬ÈÏ×¨ÓÃÍ¨ÐÅ´Ø²ÎÊýÌî×°
 870   3                      
 871   3                              datsREG_cluster[0] = cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].endpoint;
 872   3                              datsREG_cluster[3] = (u8)((cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].devID & 0x00ff) >> 0);
 873   3                              datsREG_cluster[4] = (u8)((cluster_Default[step_CortexA - cmdNum_zigbNwkREQ].devID & 0xff00) >> 8);
 874   3                              
 875   3                      }else{  //ÓÃ»§Í¨ÐÅ´Ø£¨»¥¿Ø£©×¢²á²ÎÊýÌî×°
 876   3                      
 877   3                              if((CTRLEATHER_PORT[step_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr] >= 0x10) && (CTRLEATHER_PORT[ste
             -p_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr] < 255)){ //Í¨ÐÅ´Ø¶Ë¿ÚºÏ·¨ÐÔÅÐ¶Ï
 878   4                              
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 16  

 879   4                                      datsREG_cluster[0] = CTRLEATHER_PORT[step_CortexA - cmdNum_zigbNwkREQ - clusterNum_usr];
 880   4                                      datsREG_cluster[3] = zigbDatsDefault_ClustID; //Ä¬ÈÏ´ØID <LSB>
 881   4                                      datsREG_cluster[4] = 0; //Ä¬ÈÏ´ØID <MSB>
 882   4                                      
 883   4                              }else{
 884   4                              
 885   4                                      step_CortexA ++;
 886   4                                      return;
 887   4                              }
 888   3                      }
 889   2              
 890   2                      switch(step_CortexB){
 891   3                      
 892   3                              case 0:{
 893   4                                      
 894   4                                      if(reactionLoop > 2){
 895   5                                              
 896   5                                              reactionLoop = 0;
 897   5                                              step_CortexA = 0;
 898   5                                              break;
 899   5                                      }
 900   4                                      
 901   4                                      datsTX_Len = ZigB_TXFrameLoad(paramTX_temp, 
 902   4                                                                                                defaultParam_clusterRegister.zigbInit_reqCMD, 
 903   4                                                                                                2, 
 904   4                                                                                                datsREG_cluster, 
 905   4                                                                                                defaultParam_clusterRegister.reqDAT_num);
 906   4                                      
 907   4                                      uartZigB_datsSend(paramTX_temp, datsTX_Len);
 908   4                                      
 909   4                                      zigbNwkAction_counter = defaultParam_clusterRegister.timeTab_waitAnsr;
 910   4                                      step_CortexB = 1;
 911   4                                      
 912   4                              }break;
 913   3                                      
 914   3                              case 1:{
 915   4                                      
 916   4                                      if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ýÏìÓ¦
 917   5                                      
 918   5                                              reactionLoop ++;
 919   5                                              step_CortexB = 0;
 920   5                                      }
 921   4                                      else
 922   4                                      if(uartRX_toutFLG){
 923   5                                      
 924   5                                              uartRX_toutFLG = 0;
 925   5                                              
 926   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, defaultParam_clusterRegister.zigbInit_REPLY, defaultPa
             -ram_clusterRegister.REPLY_num) || //Ô¤ÆÚÏìÓ¦
 927   5                                                 memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, frameResponseSubs_clusterRegister, 6)){ //Ìæ²¹ÏìÓ¦
 928   6                                              
 929   6                                                      step_CortexB = 0;
 930   6                                                      reactionLoop = 0;
 931   6                                                      step_CortexA ++;
 932   6                                              }
 933   5                                      }
 934   4                                      
 935   4                              }break;
 936   3                      }
 937   2              }
 938   1      }
 939          
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 17  

 940          /*zigbeeÍøÂçÊý¾Ý·¢ËÍ¸ñÊ½»¯Ìî×°*/
 941          static 
 942          u8 zigb_datsLoad_datsSend(u8  frame_Temp[NORMALDATS_DEFAULT_LENGTH],
 943                                                            u16 DstAddr,
 944                                                            u8  portPoint,
 945                                                            u8  dats[],
 946                                                            u8  datsLen){
 947   1              
 948   1              u8 code zigbCMD_DatsSend[2] = {0x24, 0x01};
 949   1              
 950   1      #define zigbDatsSend_datsTransLen       72
 951   1              u8 xdata buf_datsLOAD[zigbDatsSend_datsTransLen] = {0};
 952   1              u8 datsTX_Len = 0;
 953   1                                                                
 954   1              memset(frame_Temp, 0, NORMALDATS_DEFAULT_LENGTH * sizeof(u8));  
 955   1      
 956   1              //·¢ËÍÖ¡Ìî×°
 957   1              buf_datsLOAD[0] = (u8)((DstAddr & 0x00ff) >> 0);
 958   1              buf_datsLOAD[1] = (u8)((DstAddr & 0xff00) >> 8);
 959   1              buf_datsLOAD[2] = portPoint;
 960   1              buf_datsLOAD[3] = portPoint;
 961   1              buf_datsLOAD[4] = zigbDatsDefault_ClustID;
 962   1              buf_datsLOAD[6] = zigbDatsDefault_TransID;
 963   1              buf_datsLOAD[7] = zigbDatsDefault_Option;
 964   1              buf_datsLOAD[8] = zigbDatsDefault_Radius;
 965   1              buf_datsLOAD[9] = datsLen;
 966   1              memcpy(&buf_datsLOAD[10], dats, datsLen);       
 967   1              
 968   1              return ZigB_TXFrameLoad(frame_Temp, (u8 *)zigbCMD_DatsSend, 2, buf_datsLOAD, datsLen + 10);
 969   1      }
 970          
 971          /*zigbeeÎÞÊÓÏìÓ¦»Ø¸´Ö±½Ó·¢ËÍÊý¾Ý*///×èÈû
 972          static
 973          void dataSendRemote_straightforward( u16 DstAddr, //Ô¶¶ËÍøÂç¶ÌµØÖ·
 974                                                                                    u8 port,       //¶Ëµã¿Ú
 975                                                                                    u8 dats[], //Êý¾Ý
 976                                                                                    u8 datsLen ){ //Êý¾Ý³¤¶È
 977   1                                                                                                                                                
 978   1              u8 xdata buf_datsTX[NORMALDATS_DEFAULT_LENGTH] = {0};
 979   1              u8 datsTX_Len = 0;
 980   1              
 981   1              datsTX_Len = zigb_datsLoad_datsSend(buf_datsTX, DstAddr, port, dats, datsLen);
 982   1              
 983   1              uartZigB_datsSend(buf_datsTX, datsTX_Len);
 984   1      }
 985          
 986          /*zigbeeÍøÂçÊý¾Ý·¢ËÍÇëÇó×´Ì¬»ú*///·Ç×èÈû
 987          static
 988          void dataTransRequest_datsSend(void){
 989   1      
 990   1              u8 xdata buf_datsTX[NORMALDATS_DEFAULT_LENGTH] = {0};
 991   1              u8 datsTX_Len = 0;
 992   1              
 993   1      #define zigbDatsSend_datsRespLen        64
 994   1              u8 xdata buf_datsRX[zigbDatsSend_datsRespLen] = {0};
 995   1              u8 datsRX_Len = 0;
 996   1              
 997   1      #define zigbDatsSend_ASR_datsLen        3
 998   1              u8              ASR_dats[zigbDatsSend_ASR_datsLen] = {0};
 999   1              u8 code ASR_cmd[2] = {0x44,0x80};       //±¾µØZNPÐ­Òé²ãÈ·ÈÏ·¢ËÍÏìÓ¦
1000   1              
1001   1      #define resCODE_datsSend_NOROUTER 0xCD  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-Â·ÓÉÊ§Áª
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 18  

1002   1      #define resCODE_datsSend_NOREMOTE 0xE9  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-¶Ô·½²»ÔÚÏß
1003   1      #define resCODE_datsSend_TIMEOUT  0x01  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-·¢ËÍ³¬Ê±
1004   1      #define resCODE_datsSend_SUCCESS  0x00  //Êý¾Ý·¢ËÍÐ­Òé²ãÏìÓ¦´úÂë-·¢ËÍ³É¹¦
1005   1              static u8 datsTrans_respondCode = 0; //·¢ËÍÍê³ÉÏìÓ¦Âë
1006   1              
1007   1              static u8 step = 0;
1008   1              static u8 reactionLoop = 0;
1009   1              
1010   1              if(devStatus_switch.statusChange_IF){   //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
1011   2              
1012   2                      devStatus_switch.statusChange_IF = 0;
1013   2                      devRunning_Status = devStatus_switch.statusChange_standBy;
1014   2                      
1015   2                      step = 0;
1016   2                      reactionLoop = 0;
1017   2                      
1018   2                      return;
1019   2              }
1020   1              
1021   1              //½ÓÊÕÖ¡Ìî×°_±¾µØ
1022   1              ASR_dats[0] = 0x00; //·¢ËÍ³É¹¦ÏìÓ¦´úÂë
1023   1              ASR_dats[1] = datsSend_request.portPoint;
1024   1              ASR_dats[2] = zigbDatsDefault_TransID;
1025   1              datsRX_Len = ZigB_TXFrameLoad(buf_datsRX, (u8 *)ASR_cmd, 2, ASR_dats, zigbDatsSend_ASR_datsLen);
1026   1              
1027   1              datsTX_Len = zigb_datsLoad_datsSend(buf_datsTX, datsSend_request.nwkAddr, datsSend_request.portPoint, dat
             -sSend_request.datsTrans.dats, datsSend_request.datsTrans.datsLen);
1028   1              
1029   1              switch(step){
1030   2              
1031   2                      case 0:{ //ÏìÓ¦½ÓÊÕ¾ÍÐ÷£¬ÉèÖÃÏìÓ¦Ê±¼ä
1032   3                              
1033   3                              if(reactionLoop > 3){
1034   4                                      
1035   4                                      datsTrans_respondCode = resCODE_datsSend_TIMEOUT; //ÏìÓ¦Âë¸ÄÎª³¬Ê±
1036   4                                      
1037   4                                      reactionLoop = 0;
1038   4                                      step = 4;
1039   4                                      
1040   4                                      break;
1041   4                              }
1042   3                      
1043   3                              zigbPin_RESET = 1; //±£ÏÕÆð¼û£¬¸´Î»À­¸ß
1044   3                              uartZigB_datsSend(buf_datsTX, datsTX_Len);
1045   3                              zigbNwkAction_counter = 1000; //Ä¬ÈÏÐ­Òé²ãÏìÓ¦Ê±¼ä<Ê±¼äÌ«¶ÌÎÞ·¨ÊÕµ½ºóÃæµÄ½ÓÊÕ×´Ì¬ÏìÓ¦Ö¸Áî£¬Ö»ÄÜÊÕµ½ÏµÍ³
             -ÏìÓ¦>
1046   3                              step = 1;
1047   3                              
1048   3                      }break;
1049   2                      
1050   2                      case 1:{ //·Ç×èÈûµÈ´ýÏµÍ³ÏìÓ¦
1051   3                      
1052   3                              if(!zigbNwkAction_counter){
1053   4                              
1054   4                                      reactionLoop ++;
1055   4                                      step = 0;
1056   4                              }
1057   3                              else{
1058   4                                      
1059   4                                      if(uartRX_toutFLG){
1060   5                                      
1061   5                                              uartRX_toutFLG = 0;
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 19  

1062   5      
1063   5                                              if(memmem(datsRcv_ZIGB.rcvDats, COM_RX1_Lenth, buf_datsRX, datsRX_Len)){
1064   6                                              
1065   6                                                      if(datsRcv_respond.datsTrans.datsLen == 0){
1066   7                                                      
1067   7                                                              step = 3;
1068   7                                                              
1069   7                                                      }else{
1070   7                                                      
1071   7                                                              step = 2;
1072   7                                                              zigbNwkAction_counter = 500; //Ä¬ÈÏÔ¶¶ËÏìÓ¦Ê±¼ä<¶Ô·½½ÚµãÏìÓ¦>
1073   7                                                      }
1074   6                                                      
1075   6                                              }else{  
1076   6                                                      
1077   6                                                      datsTrans_respondCode = datsRcv_ZIGB.rcvDats[4]; //´íÎóÏìÓ¦Âë×°ÔØ
1078   6                                                      
1079   6      //#if(DEBUG_LOGOUT_EN == 1)
1080   6      //                                              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1081   6      //                                                      u8 xdata log_buf[64]; //Êý¾Ý´«ÊäÊ§°ÜÐ­Òé²ãÏìÓ¦´úÂë´òÓ¡
1082   6      //                                                      
1083   6      //                                                      sprintf(log_buf, "dats_TX fail code: %02X %02X %02X.\n", (int)datsRcv_ZIGB.rcvDats[2], (int)datsR
             -cv_ZIGB.rcvDats[3], (int)datsRcv_ZIGB.rcvDats[4]);
1084   6      //                                                      PrintString1_logOut(log_buf);
1085   6      //                                              }       
1086   6      //#endif                                
1087   6                                              }
1088   5                                      }
1089   4                              }
1090   3                              
1091   3                      }break;
1092   2                      
1093   2                      case 2:{ //·Ç×èÈûµÈ´ýÔ¶¶ËÏìÓ¦
1094   3      
1095   3                              if(!zigbNwkAction_counter){
1096   4                              
1097   4                                      reactionLoop ++;
1098   4                                      step = 0;
1099   4                              }
1100   3                              else{
1101   4                                      
1102   4                                      if(uartRX_toutFLG){
1103   5                                              
1104   5                                              u16 idata datsFrom_addr = ((u16)(datsRcv_ZIGB.rcvDats[9]) << 8) | ((u16)(datsRcv_ZIGB.rcvDats[8]) << 
             -0); //Êý¾Ý·¢ËÍ·½ÍøÂçµØÖ·
1105   5                                              u8      idata dstPoint =  datsRcv_ZIGB.rcvDats[11];     //Ô¶¶Ë  
1106   5                                              
1107   5                                              uartRX_toutFLG = 0;
1108   5      
1109   5                                              if(!memcmp(&(datsRcv_ZIGB.rcvDats[21]), datsRcv_respond.datsTrans.dats, datsRcv_respond.datsTrans.dat
             -sLen) && 
1110   5                                                 (datsRcv_respond.nwkAddr == datsFrom_addr) &&
1111   5                                                      (datsRcv_respond.portPoint == dstPoint)){
1112   6                                              
1113   6                                                      step = 3;
1114   6                                              }
1115   5                                      }
1116   4                              }
1117   3                              
1118   3                      }break;
1119   2                      
1120   2                      case 3:{ //ÏìÓ¦³É¹¦
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 20  

1121   3                      
1122   3                              if(reConnectAfterDatsReq_IF){ //Õë¶Ô¼´¿Ì×¢²á»¥¿ØÌØÊâÇé¿ö ×´Ì¬ÇÐ»»
1123   4                              
1124   4                                      reConnectAfterDatsReq_IF = 0;
1125   4                                      devRunning_Status = status_nwkReconnect;
1126   4                                      
1127   4                              }else{ 
1128   4                              
1129   4                                      devRunning_Status = status_passiveDataRcv;
1130   4                              }
1131   3                              
1132   3                              reactionLoop = 0;
1133   3                              step = 0;
1134   3                              
1135   3                      }break;
1136   2                      
1137   2                      case 4:{ //ÏìÓ¦Ê§°Ü
1138   3                      
1139   3                              if(reConnectAfterDatsReq_IF){ //Õë¶Ô¼´¿Ì×¢²á»¥¿ØÌØÊâÇé¿ö ×´Ì¬ÇÐ»»
1140   4                              
1141   4                                      reConnectAfterDatsReq_IF = 0;
1142   4                                      devRunning_Status = status_nwkReconnect;
1143   4                                      
1144   4                              }else{ 
1145   4                              
1146   4                                      devRunning_Status = status_passiveDataRcv;
1147   4                              }
1148   3                              
1149   3                              //Õë¶ÔÊý¾Ý´«ÊäÊ§°ÜÏìÓ¦´úÂëÇé¿ö½øÐÐÑ¡ÔñÐÔÖØÁ¬£¬·ñÔò½öÊ±ÇøÐ­µ÷Æ÷Éè±¸¾Ígg
1150   3                              if(datsTrans_respondCode){ 
1151   4                                      
1152   4                                      switch(datsTrans_respondCode){ //ÏìÓ¦Ê§°ÜÂë·ÖÎö
1153   5                                      
1154   5                                              case resCODE_datsSend_NOROUTER:
1155   5                                              case resCODE_datsSend_NOREMOTE:
1156   5                                              case resCODE_datsSend_SUCCESS:{
1157   6                                              
1158   6                                                      devTips_nwkZigb = nwkZigb_outLine; //ÔÝÊ±Ö»×öÊ§°ÜÌáÊ¾£¬²»×öÆäËû¶¯×÷
1159   6                                                      
1160   6                                              }break;
1161   5                                              
1162   5                                              default:{
1163   6                                              
1164   6                                                      devTips_nwkZigb = nwkZigb_outLine; //ÔÝÊ±Ö»×öÊ§°ÜÌáÊ¾£¬²»×öÆäËû¶¯×÷
1165   6                                                      
1166   6                                              }break;
1167   5                                      }
1168   4                                      
1169   4                                      datsTrans_respondCode = 0;
1170   4                              }
1171   3                              
1172   3                              reactionLoop = 0;
1173   3                              step = 0;
1174   3                              
1175   3                      }break;
1176   2                              
1177   2                      default:{
1178   3                      
1179   3                              step = 4;
1180   3                              
1181   3                      }break;
1182   2              }
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 21  

1183   1      }
1184          
1185          /*Éè±¸Êý¾Ý´«ÊäÖ÷×´Ì¬ÇÐ»»ÖÁÍøÂç¹ÒÆð*/
1186          void devStatusChangeTo_devHold(bit zigbNwkSysNote_IF){ //Éè±¸ÍøÂç¹ÒÆð
1187   1      
1188   1              devNwkHoldTime_Param.devHoldTime_counter = DEVHOLD_TIME_DEFAULT;
1189   1              if(zigbNwkSysNote_IF)devNwkHoldTime_Param.zigbNwkSystemNote_IF = 1;
1190   1              
1191   1              devStatus_switch.statusChange_standBy = status_devNwkHold; //Êý¾Ý´«Êä×´Ì¬»ú¸ü±ä
1192   1              devStatus_switch.statusChange_IF = 1;
1193   1              
1194   1              devTips_status = status_devHold; //tips¸ü±ä
1195   1              
1196   1      #if(DEBUG_LOGOUT_EN == 1)                               
1197   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1198   2                      u8 xdata log_buf[64];
1199   2                      
1200   2                      sprintf(log_buf, "devHold start right now.\n");
1201   2                      PrintString1_logOut(log_buf);
1202   2              }
1203   1      #endif  
1204   1      }
1205          
1206          /*Éè±¸ÍøÂç¹ÒÆðÍ£Ö¹£¬Ê¹ÌáÇ°½áÊø*/
1207          void devHoldStop_makeInAdvance(void){ //Í£Ö¹Éè±¸ÍøÂç¹ÒÆð£¨ÌáÇ°£©
1208   1      
1209   1              if(devNwkHoldTime_Param.devHoldTime_counter)devNwkHoldTime_Param.devHoldTime_counter = 0;
1210   1      }
1211          
1212          /*zigbeeÉè±¸ÍøÂç¹ÒÆð×´Ì¬»ú*///·Ç×èÈû
1213          static 
1214          void function_devNwkHold(void){
1215   1              
1216   1              static status_Step = 0; //µ±Ç°×´Ì¬»ú²½Öè×´Ì¬Ö¸Ê¾
1217   1              
1218   1              if(devNwkHoldTime_Param.devHoldTime_counter){ //Ö±µ½¹ÒÆðÊ±¼ä½áÊø
1219   2              
1220   2                      if(devNwkHoldTime_Param.zigbNwkSystemNote_IF){ //Í¨Öªµ±Ç°ÍøÂçÄÚ×ÓÉè±¸¹ÒÆð,±¨Á½´Î
1221   3                              
1222   3                              u8 xdata dats_Note[3] = {ZIGB_SYSCMD_DEVHOLD, 1, 0}; //ÃüÁî¡¢Êý¾Ý³¤¶È¡¢Êý¾Ý
1223   3                      
1224   3                              devNwkHoldTime_Param.zigbNwkSystemNote_IF = 0; //Í¨ÖªÊ¹ÄÜ¸´Î»
1225   3                              
1226   3                              dataSendRemote_straightforward( 0xFFFF, //¹ã²¥Í¨ÖªÍøÄÚËùÓÐ×ÓÉè±¸¹ÒÆð
1227   3                                                                                              ZIGB_ENDPOINT_CTRLSYSZIGB,
1228   3                                                                                              dats_Note,
1229   3                                                                                              3 );
1230   3                              
1231   3                              delayMs(50); //±ØÐèÑÓÊ±£¬·ñÔòÊý¾Ý»¹Ã»·¢ËÍ³öÈ¥£¬¾ÍÅÜµ½ÏÂÒ»²½¸´Î»ÁË
1232   3                      }
1233   2                      
1234   2                      { //Éè±¸¹ÒÆð,Ñ­»·¸´Î»
1235   3                              
1236   3                              switch(status_Step){
1237   4                              
1238   4                                      case 0:{ //¸´Î»200ms
1239   5                                      
1240   5                                              zigbPin_RESET = 0;
1241   5                                              zigbNwkAction_counter = 200;
1242   5                                              status_Step = 1;
1243   5                                      
1244   5                                      }break;
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 22  

1245   4                                              
1246   4                                      case 1:{ //Ã¿6s¸´Î»Ò»´Î
1247   5                                      
1248   5                                              if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý
1249   6                                              
1250   6                                                      zigbPin_RESET = 1;
1251   6                                                      zigbNwkAction_counter = 6000;
1252   6                                                      status_Step = 2;
1253   6                                              }
1254   5                                      
1255   5                                      }break;
1256   4                                      
1257   4                                      case 2:{
1258   5                                      
1259   5                                              if(!zigbNwkAction_counter){ //·Ç×èÈûµÈ´ý
1260   6                                              
1261   6                                                      status_Step = 0;
1262   6                                                      
1263   6      #if(DEBUG_LOGOUT_EN == 1)                               
1264   6                                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1265   7                                                              u8 xdata log_buf[64];
1266   7                                                              
1267   7                                                              sprintf(log_buf, "devHold time count remind: %02d s.\n", (int)devNwkHoldTime_Param.devHoldTime_coun
             -ter);
1268   7                                                              PrintString1_logOut(log_buf);
1269   7                                                      }
1270   6      #endif
1271   6                                              }
1272   5                                      
1273   5                                      }break;
1274   4                                      
1275   4                                      default:{
1276   5                                              
1277   5                                              status_Step = 0;
1278   5                                              
1279   5                                      }break;
1280   4                              }
1281   3                      }
1282   2      
1283   2              }else{
1284   2              
1285   2                      //¹ÒÆðÊ±¼ä½áÊø,Ö÷×´Ì¬»Ö¸´ÖÁÖØÁ¬£¬±¾µØ×´Ì¬»Ö¸´
1286   2                      status_Step = 0;
1287   2                      zigbPin_RESET = 1;
1288   2                      
1289   2                      devRunning_Status = status_nwkReconnect; //Ö±½Ó½«Ö÷×´Ì¬ÇÐ»»ÖÁÍøÂçÖØÁ¬,²»×ßstandbyÁ÷³Ì
1290   2                      devTips_status = status_Normal; //tips¸ü±ä
1291   2              
1292   2      #if(DEBUG_LOGOUT_EN == 1)                               
1293   2                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1294   3                              u8 xdata log_buf[64];
1295   3                              
1296   3                              sprintf(log_buf, "devHold stop.\n");
1297   3                              PrintString1_logOut(log_buf);
1298   3                      }
1299   2      #endif  
1300   2              }
1301   1      }
1302          
1303          /*zigbee¼¯Èº¿ØÖÆÊý¾Ý½âÎö*/
1304          static 
1305          void dataParing_scenarioCtrl(u8 datsFrame[]){
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 23  

1306   1      
1307   1              swCommand_fromUsr.objRelay = datsFrame[0]; //¼ÌµçÆ÷ÏìÓ¦¼´¿É
1308   1              swCommand_fromUsr.actMethod = relay_OnOff;
1309   1              
1310   1      #if(DEBUG_LOGOUT_EN == 1)
1311   1              { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1312   2                      u8 xdata log_buf[64];
1313   2                      
1314   2                      sprintf(log_buf, "cmdScenarioCtrl comming, statusData:%02X.\n", (int)datsFrame[0]);
1315   2                      PrintString1_logOut(log_buf);
1316   2              }                       
1317   1      #endif          
1318   1      }
1319          
1320          /*zigbeeÏµÍ³½»»¥Êý¾Ý½âÎö*/
1321          static 
1322          void dataParing_zigbSysCtrl(u8 datsFrame[]){
1323   1      
1324   1              frame_zigbSysCtrl xdata dats = {0};
1325   1              
1326   1              dats.command = datsFrame[0];
1327   1              memcpy(dats.dats, &datsFrame[2], datsFrame[1]);
1328   1              dats.datsLen = datsFrame[1];
1329   1              
1330   1              switch(dats.command){
1331   2              
1332   2                      case ZIGB_SYSCMD_NWKOPEN:{ //ÍøÂç¿ª·Å
1333   3                              
1334   3                              bit resultSet = 0;
1335   3                              
1336   3                              resultSet = ZigB_nwkOpen(1, dats.dats[0]); //¹¦ÄÜ´¥·¢
1337   3                              tips_statusChangeToZigbNwkOpen(ZIGBNWK_OPNETIME_DEFAULT); //tips´¥·¢
1338   3                              
1339   3                      }break;
1340   2                      
1341   2                      case ZIGB_SYSCMD_TIMESET:{ //ÏµÍ³Ê±¼äÉè¶¨
1342   3                      
1343   3                              bit resultSet = 0;
1344   3                              bit timeZoneAdjust_needIF = 0;
1345   3                              u32 time_Temp = 0UL;
1346   3                              
1347   3                              time_Temp |= (u32)dats.dats[0] << 0;
1348   3                              time_Temp |= (u32)dats.dats[1] << 8;
1349   3                              time_Temp |= (u32)dats.dats[2] << 16;
1350   3                              time_Temp |= (u32)dats.dats[3] << 24;
1351   3                              if((sysTimeZone_H != dats.dats[4]) || (sysTimeZone_M != dats.dats[5])){ //Ê±ÇøÍ¬²½
1352   4                              
1353   4                                      sysTimeZone_H = dats.dats[4];
1354   4                                      sysTimeZone_M = dats.dats[5];
1355   4                                      coverEEPROM_write_n(EEPROM_ADDR_timeZone_H, &sysTimeZone_H, 1);
1356   4                                      coverEEPROM_write_n(EEPROM_ADDR_timeZone_M, &sysTimeZone_M, 1);
1357   4                              }
1358   3                              
1359   3                              if(dats.dats[6])timeZoneAdjust_needIF = 1; //Ê±Çø²¹³¥Ê¹ÄÜ
1360   3                              resultSet = zigB_sysTimeSet(time_Temp - ZIGB_UTCTIME_START, timeZoneAdjust_needIF); //zigbee UTC¸º²¹³¥
1361   3                              
1362   3                      }break;
1363   2                      
1364   2                      case ZIGB_SYSCMD_DEVHOLD:{
1365   3                      
1366   3                              devStatusChangeTo_devHold(0); //Éè±¸ÍøÂç¹ÒÆð,²»½øÐÐÍøÂçÍ¨Öª
1367   3                              
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 24  

1368   3                      }break;
1369   2                              
1370   2                      default:break;
1371   2              }
1372   1      }
1373          
1374          /*zigbee³£¹æ¿ØÖÆ×ª·¢Êý¾Ý½âÎö*/
1375          static 
1376          void dataParing_Nomal(u8 datsParam[], u16 nwkAddr_from, u8 port_from){
1377   1              
1378   1      #define dataLen_dataParingNomal 96
1379   1              u8 xdata paramTX_temp[dataLen_dataParingNomal] = {0};
1380   1              
1381   1              bit dataFromRemote_IF = 0;      //ÊÇ·ñÎª·þÎñÆ÷¶ËÊý¾Ý±êÖ¾
1382   1      
1383   1              /*²úÆ·¶þ¼¶Ð­ÒéºË¶Ô_³£¹æ¿ØÖÆ*///¿ØÖÆÏÂ´ï
1384   1              switch(datsParam[0]){
1385   2              
1386   2                      /*Ô¶¶Ë*/
1387   2                      case ZIGB_FRAMEHEAD_CTRLREMOTE:{
1388   3                              
1389   3                              dataFromRemote_IF = 1;
1390   3                              
1391   3                              memcpy(MAC_ID_DST, &datsParam[7], 6);
1392   3                              memcpy(&datsParam[1], &datsParam[13], datsRcv_ZIGB.rcvDats[20] - 13);
1393   3                      }
1394   2                      
1395   2                      /*±¾µØ*/
1396   2                      case ZIGB_FRAMEHEAD_CTRLLOCAL:{
1397   3                              
1398   3                              bit frameCheck_Done = 0; //Êý¾Ý¼ì²âºÏ¸ñ±êÖ¾
1399   3                              
1400   3                              {
1401   4                                      bit frameCodeCheck_PASS = 0; //Ð£ÑéÂë¼ì²éÍ¨¹ý±êÖ¾
1402   4                                      bit frameMacCheck_PASS  = 0; //macµØÖ·´ý¼ì²éÍ¨¹ý±êÖ¾
1403   4                                      
1404   4                                      if(datsParam[4] == frame_Check(&datsParam[5], 28))frameCodeCheck_PASS = 1; //Ð£ÑéÂë¼ì²â
1405   4                                      if(!memcmp(&datsParam[5], &MAC_ID[1], 5))frameMacCheck_PASS = 1; //MAC¼ì²â
1406   4      
1407   4                                      if(datsParam[3] == FRAME_MtoZIGBCMD_cmdConfigSearch){ //ÌØÊâÖ¸Áî²»×öMAC¼ì²â
1408   5                                      
1409   5                                              frameMacCheck_PASS = 1;
1410   5                                              
1411   5                                      }else
1412   4                                      if((datsParam[3] == FRAME_MtoZIGBCMD_cmdCfg_swTim) || //ÌØÊâÖ¸Áî²»×öÐ£ÑéÂë¼ì²â
1413   4                                         (datsParam[3] == FRAME_MtoZIGBCMD_cmdswTimQuery)){
1414   5                                         
1415   5                                              frameCodeCheck_PASS = 1;
1416   5                                      }
1417   4                                         
1418   4                                      if(frameCodeCheck_PASS && frameCodeCheck_PASS)frameCheck_Done = 1;
1419   4                              }
1420   3                                 
1421   3                              if(frameCheck_Done){ //Ö¡¼ì²éÍ¨¹ý£¬¿ªÊ¼½âÎö¡¢¶¯×÷¼°ÏìÓ¦
1422   4                                      
1423   4                                      bit respond_IF          = 0;    //ÊÇ·ñ»Ø¸´
1424   4                                      bit specialCmd_IF       = 0;    //ÊÇ·ñÎªÌØÊâÖ¸Áî£¨ÌØÊâÖ¸ÁîÕ¼ÓÃ¿ª¹ØÀàÐÍÄÇÒ»¸ö×Ö½Ú£©
1425   4                                      
1426   4      #if(DEBUG_LOGOUT_EN == 1)
1427   4                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1428   5                                              u8 xdata log_buf[64];
1429   5                                              
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 25  

1430   5                                              sprintf(log_buf, "cmdComing:%02X.\n", (int)datsParam[3]);
1431   5                                              PrintString1_logOut(log_buf);
1432   5                                      }                       
1433   4      #endif          
1434   4                                      memset(paramTX_temp, 0, sizeof(u8) * dataLen_dataParingNomal);
1435   4                              
1436   4                                      switch(datsParam[3]){
1437   5                                      
1438   5                                              case FRAME_MtoZIGBCMD_cmdConfigSearch:{
1439   6                                                      
1440   6                                                      if(!deviceLock_flag){ //Éè±¸ÊÇ·ñÉÏËø
1441   7                                                              
1442   7                                                              u16 xdata panid_Temp = ZigB_getPanIDCurrent(); //ÅäÖÃ»Ø¸´Ìí¼ÓPANID
1443   7                                                              
1444   7                                                              paramTX_temp[14] = (u8)((panid_Temp & 0xFF00) >> 8);
1445   7                                                              paramTX_temp[15] = (u8)((panid_Temp & 0x00FF) >> 0);
1446   7                                                              
1447   7                                                              sysTimeZone_H = datsParam[12];
1448   7                                                              sysTimeZone_M = datsParam[13];
1449   7                                                              coverEEPROM_write_n(EEPROM_ADDR_timeZone_H, &sysTimeZone_H, 1);
1450   7                                                              coverEEPROM_write_n(EEPROM_ADDR_timeZone_M, &sysTimeZone_M, 1);
1451   7                                                      
1452   7                                                              respond_IF              = 1; //ÏìÓ¦»Ø¸´
1453   7                                                              specialCmd_IF   = 0;
1454   7                                                              
1455   7                                                      }else{
1456   7                                                      
1457   7                                                              
1458   7                                                      }
1459   6                                                      
1460   6                                              }break;
1461   5                                              
1462   5                                              case FRAME_MtoZIGBCMD_cmdControl:{
1463   6      
1464   6                                                      paramTX_temp[11] = 0;
1465   6                                                      paramTX_temp[11] |= (datsParam[11] & 0x07);     //×´Ì¬Î»Ìî×°
1466   6                                                      if(             (datsParam[11] & 0x01) != (status_Relay & 0x01))paramTX_temp[11] |= 0x20; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ»>µ
             -ÚÒ»Î»
1467   6                                                      else if((datsParam[11] & 0x02) != (status_Relay & 0x02))paramTX_temp[11] |= 0x40; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ
             -»>µÚ¶þÎ»
1468   6                                                      else if((datsParam[11] & 0x04) != (status_Relay & 0x04))paramTX_temp[11] |= 0x80; //¸ü¸ÄÖµÌî×°<¸ßÈýÎ
             -»>µÚÈýÎ»
1469   6                                                      
1470   6                                                      swCommand_fromUsr.objRelay = datsParam[11];
1471   6                                                      swCommand_fromUsr.actMethod = relay_OnOff;
1472   6      
1473   6                                                      respond_IF              = 1; //ÏìÓ¦»Ø¸´
1474   6                                                      specialCmd_IF   = 0;                                                    
1475   6                                                      
1476   6                                              }break;
1477   5                                                      
1478   5                                              case FRAME_MtoZIGBCMD_cmdQuery:{}break;
1479   5                                                      
1480   5                                              case FRAME_MtoZIGBCMD_cmdInterface:{}break;
1481   5                                                      
1482   5                                              case FRAME_MtoZIGBCMD_cmdReset:{}break;
1483   5                                                      
1484   5                                              case FRAME_MtoZIGBCMD_cmdDevLockON:{
1485   6                                              
1486   6                                                      //Êý¾Ý´¦Àí¼°¶¯×÷ÏìÓ¦
1487   6                                                      {
1488   7                                                              u8 deviceLock_IF = 1;
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 26  

1489   7                                                              
1490   7                                                              deviceLock_flag  = 1;
1491   7                                                              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
1492   7                                                      }               
1493   6                                                      
1494   6                                              }break;
1495   5                                                      
1496   5                                              case FRAME_MtoZIGBCMD_cmdDevLockOFF:{
1497   6                                              
1498   6                                                      //Êý¾Ý´¦Àí¼°¶¯×÷ÏìÓ¦
1499   6                                                      {
1500   7                                                              u8 deviceLock_IF = 0;
1501   7                                                              
1502   7                                                              deviceLock_flag  = 0;
1503   7                                                              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1);
1504   7                                                      }       
1505   6                                              
1506   6                                              }break;
1507   5                                                      
1508   5                                              case FRAME_MtoZIGBCMD_cmdswTimQuery:{
1509   6                                              
1510   6                                                      //·ÖÀà»Ø¸´
1511   6                                                      switch(datsParam[13]){ //×ÓÃüÁî½âÎö
1512   7                                                      
1513   7                                                              case 0: /*ÉÏÎ»»úÔÚ¶¨Ê±µÄÊ±ºò¸ø0£¬´ýÐ­ÉÌ*/
1514   7                                                              case cmdConfigTim_normalSwConfig:{
1515   8                                                              
1516   8                                                                      u8 loop = 0;
1517   8                                                              
1518   8                                                                      //Êý¾ÝÏìÓ¦¼°»Ø¸´
1519   8                                                                      EEPROM_read_n(EEPROM_ADDR_swTimeTab, &paramTX_temp[14], 12);    //¶¨Ê±±í»Ø¸´Ìî×°
1520   8                                                                      
1521   8                                                                      //»Ø¸´Êý¾Ý¶þ´Î´¦Àí£¨Õë¶ÔÒ»´ÎÐÔ¶¨Ê±Êý¾Ý£©
1522   8                                                                      for(loop = 0; loop < 4; loop ++){
1523   9                                                                      
1524   9                                                                              if(swTim_onShoot_FLAG & (1 << loop)){
1525  10                                                                                      
1526  10                                                                                      paramTX_temp[14 + loop * 3] &= 0x80;
1527  10                                                                              }
1528   9                                                                      }
1529   8                                                                                      
1530   8                                                                      specialCmd_IF = 1; //ÌØÊâÕ¼Î»Ö¸Áî
1531   8                                                                      
1532   8                                                              }break;
1533   7                                                              
1534   7                                                              case cmdConfigTim_onoffDelaySwConfig:{
1535   8                                                              
1536   8                                                                      if(!delayCnt_onoff)paramTX_temp[14] = 0;
1537   8                                                                      else paramTX_temp[14] = delayPeriod_onoff - (u8)(delayCnt_onoff / 60);
1538   8                                                                      paramTX_temp[15] = delayUp_act;
1539   8                                                                      
1540   8                                                              }break;
1541   7                                                              
1542   7                                                              case cmdConfigTim_closeLoopSwConfig:{
1543   8                                                              
1544   8                                                                      paramTX_temp[14] = delayPeriod_closeLoop;
1545   8                                                                      
1546   8                                                              }break;
1547   7                                                              
1548   7                                                              case cmdConfigTim_nightModeSwConfig:{  
1549   8                                                              
1550   8                                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &paramTX_temp[14], 6);      //Ò¹¼äÄ£Ê½¶¨Ê±±í»Ø¸´Ìî×°
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 27  

1551   8                                                                      
1552   8                                                                      (deviceLock_flag)?(paramTX_temp[12] |= 0x01):(paramTX_temp[12] &= ~0x01);
1553   8                                                                      (ifNightMode_sw_running_FLAG)?(paramTX_temp[12] |= 0x02):(paramTX_temp[12] &= ~0x02);
1554   8                                                                      
1555   8                                                              }break;
1556   7                                                              
1557   7                                                              default:break;
1558   7                                                      }
1559   6                                                      
1560   6                                                      paramTX_temp[13] = datsParam[13]; //¶¨Ê±×ÓÃüÁîÍ¬²½»Ø¸´
1561   6                                                      
1562   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1563   6                                                      
1564   6                                              }break;
1565   5                                                      
1566   5                                              case FRAME_MtoZIGBCMD_cmdConfigAP:{}break;
1567   5                                                      
1568   5                                              case FRAME_MtoZIGBCMD_cmdBeepsON:{ //Ò¹¼äÄ£Ê½¹Ø
1569   6                                              
1570   6                                                      u8 datsTemp = 0;
1571   6                                                      
1572   6                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
1573   6                                                      datsTemp &= ~0x7f; //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢,È¡ÏûÍ·×Ö½ÚÈ«Õ¼Âú,Ê§ÄÜÈ«Ìì
1574   6                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
1575   6                                                      
1576   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1577   6                                                      
1578   6                                              }break;
1579   5                                                      
1580   5                                              case FRAME_MtoZIGBCMD_cmdBeepsOFF:{ //Ò¹¼äÄ£Ê½¿ª
1581   6                                              
1582   6                                                      u8 datsTemp = 0;
1583   6                                                      
1584   6                                                      EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);
1585   6                                                      datsTemp |= 0x7f; //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢,Í·×Ö½ÚÈ«Õ¼Âú,Ç¿ÖÆÈ«Ìì
1586   6                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsTemp, 1);        
1587   6                                                      
1588   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1589   6                                                      
1590   6                                              }break;
1591   5                                                      
1592   5                                              case FRAME_MtoZIGBCMD_cmdftRecoverRQ:{
1593   6                                              
1594   6                                                      respond_IF = 1;
1595   6                                                      
1596   6                                              }break;
1597   5                                                      
1598   5                                              case FRAME_MtoZIGBCMD_cmdRecoverFactory:{
1599   6                                              
1600   6                                                      Factory_recover();
1601   6                                              
1602   6                                              }break;
1603   5                                                      
1604   5                                              case FRAME_MtoZIGBCMD_cmdCfg_swTim:{
1605   6                                                      
1606   6                                                      u8 loop = 0;
1607   6                                                      
1608   6                                                      switch(datsParam[13]){ //¶¨Ê±Êý¾Ý´¦Àí¼°¸üÐÂ,·ÖÀà´¦Àí
1609   7                                                      
1610   7                                                              case cmdConfigTim_normalSwConfig:{      /*ÆÕÍ¨¶¨Ê±*/
1611   8                                                                      
1612   8                                                                      for(loop = 0; loop < 4; loop ++){
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 28  

1613   9                                                                      
1614   9                                                                              if(datsParam[14 + loop * 3] == 0x80){   /*Ò»´ÎÐÔ¶¨Ê±ÅÐ¶Ï*///ÖÜÕ¼Î»Îª¿Õ£¬¶ø¶¨Ê±Æ÷±»´ò¿ª£¬ËµÃ÷ÊÇÒ»´ÎÐ
             -Ô
1615  10                                                                              
1616  10                                                                                      swTim_onShoot_FLAG      |= (1 << loop); //Ò»´ÎÐÔ¶¨Ê±±êÖ¾¿ªÆô
1617  10                                                                                      datsParam[14 + loop * 3] |= (1 << (datsParam[31] - 1)); //Ç¿ÐÐ½øÐÐµ±Ç°ÖÜÕ¼Î»£¬µ±´ÎÖ´ÐÐÍê±ÏºóÇå³ý
1618  10                                                                              }
1619   9                                                                      }
1620   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_swTimeTab, &datsParam[14], 12); //¶¨Ê±±í
1621   8      
1622   8                                                              }break;
1623   7                                                              
1624   7                                                              case cmdConfigTim_onoffDelaySwConfig:{  /*¿ª¹ØÑÓÊ±*/
1625   8                                                              
1626   8                                                                      if(datsParam[14]){
1627   9                                                                      
1628   9                                                                              ifDelay_sw_running_FLAG |= (1 << 1);
1629   9                                                                              delayPeriod_onoff               = datsParam[14];
1630   9                                                                              
1631   9                                                                              delayUp_act                             = datsParam[15];
1632   9                                                                              
1633   9                                                                              delayCnt_onoff                  = 0;
1634   9                                                                              
1635   9                                                                      }else{
1636   9                                                                      
1637   9                                                                              ifDelay_sw_running_FLAG &= ~(1 << 1);
1638   9                                                                              delayPeriod_onoff               = 0;
1639   9                                                                              delayCnt_onoff                  = 0;
1640   9                                                                      }
1641   8                                                                      
1642   8                                                              }break;
1643   7                                                              
1644   7                                                              case cmdConfigTim_closeLoopSwConfig:{   /*ÂÌÉ«¹¦ÄÜ(×Ô¶¯Ñ­»·¹Ø±Õ)*/
1645   8                                                              
1646   8                                                                      if(datsParam[14]){
1647   9                                                                      
1648   9                                                                              ifDelay_sw_running_FLAG |= (1 << 0);
1649   9                                                                              delayPeriod_closeLoop   = datsParam[14];
1650   9                                                                              delayCnt_closeLoop              = 0;
1651   9                                                                      }else{
1652   9                                                                      
1653   9                                                                              ifDelay_sw_running_FLAG &= ~(1 << 0);
1654   9                                                                              delayPeriod_closeLoop   = 0;
1655   9                                                                              delayCnt_closeLoop              = 0;
1656   9                                                                      }
1657   8                                                                      
1658   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_swDelayFLAG, &ifDelay_sw_running_FLAG, 1);
1659   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_periodCloseLoop, &delayPeriod_closeLoop, 1);
1660   8                                                                      
1661   8                                                              }break;         
1662   7      
1663   7                                                              case cmdConfigTim_nightModeSwConfig:{  /*Ò¹¼äÄ£Ê½ ±³¹â°ëÁÁ*/
1664   8                                                              
1665   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_TimeTabNightMode, &datsParam[14], 6);   //Ò¹¼äÄ£Ê½¶¨Ê±±í´æ´¢
1666   8                                                                      
1667   8                                                              }break;
1668   7                                                              
1669   7                                                              default:break;
1670   7                                                      }
1671   6                                                      
1672   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1673   6                                                      
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 29  

1674   6                                              }break;
1675   5                                              
1676   5                                              case FRAME_MtoZIGBCMD_cmdCfg_ctrlEachO:{
1677   6                                              
1678   6                                                      u8 loop = 0;
1679   6                                                      u8 effective_oprate = datsParam[12]; //ÓÐÐ§²Ù×÷Êý¾ÝÕ¼Î»»ñÈ¡
1680   6                                                      
1681   6                                                      for(loop = 0; loop < clusterNum_usr; loop ++){
1682   7                                                      
1683   7                                                              if((effective_oprate >> loop) & 0x01){ //ÓÐÐ§Êý¾ÝÅÐ¶Ï
1684   8                                                              
1685   8                                                                      coverEEPROM_write_n(EEPROM_ADDR_portCtrlEachOther + loop, &datsParam[14 + loop], 1);
1686   8                                                                      CTRLEATHER_PORT[loop] = datsParam[14 + loop];
1687   8                                                                      reConnectAfterDatsReq_IF = 1; //¼´¿Ì×¢²á»¥¿ØÍ¨Ñ¶´Ø¶Ë¿Ú
1688   8                                                              }
1689   7                                                      }
1690   6                                                      
1691   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1692   6                                              
1693   6                                              }break;
1694   5                                              
1695   5                                              case FRAME_MtoZIGBCMD_cmdQue_ctrlEachO:{
1696   6                                              
1697   6                                                      u8 loop = 0;
1698   6                                                      
1699   6                                                      for(loop = 0; loop < clusterNum_usr; loop ++){
1700   7                                                      
1701   7                                                              EEPROM_read_n(EEPROM_ADDR_portCtrlEachOther + loop, &paramTX_temp[14 + loop], 1);
1702   7                                                      }
1703   6                                                      
1704   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1705   6                                              
1706   6                                              }break;
1707   5                                                      
1708   5                                              case FRAME_MtoZIGBCMD_cmdCfg_ledBackSet:{
1709   6                                              
1710   6                                                      coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround, &datsParam[14], 1);
1711   6                                                      coverEEPROM_write_n(EEPROM_ADDR_ledSWBackGround + 1, &datsParam[15], 1);
1712   6                                                      tipsInsert_swLedBKG_ON  = datsParam[14];
1713   6                                                      tipsInsert_swLedBKG_OFF = datsParam[15];
1714   6                                                      
1715   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1716   6                                              
1717   6                                              }break;
1718   5                                              
1719   5                                              case FRAME_MtoZIGBCMD_cmdQue_ledBackSet:{
1720   6                                              
1721   6                                                      EEPROM_read_n(EEPROM_ADDR_ledSWBackGround, &paramTX_temp[14], 1);
1722   6                                                      EEPROM_read_n(EEPROM_ADDR_ledSWBackGround + 1, &paramTX_temp[15], 1);
1723   6                                                      
1724   6                                                      respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1725   6                                              
1726   6                                              }break;
1727   5                                              
1728   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioSet:{
1729   5      //                                              
1730   5      //                                              u16 xdata panid_Temp = ZigB_getPanIDCurrent(); //ÅäÖÃ»Ø¸´Ìí¼ÓPANID
1731   5      //                                      
1732   5      //                                              bit opt_result = swScenario_oprateSave(datsParam[12], datsParam[14]);
1733   5      //                                              if(opt_result)paramTX_temp[12] = 0;
1734   5      //                                              else paramTX_temp[12] = 0x0A; //³¡¾°ÉèÖÃÎÞÐ§»Ø¸´£¨³¡¾°´æ´¢ÒÑÂú£©
1735   5      //                                              
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 30  

1736   5      //                                              paramTX_temp[14] = (u8)((panid_Temp & 0xFF00) >> 8);
1737   5      //                                              paramTX_temp[15] = (u8)((panid_Temp & 0x00FF) >> 0);
1738   5      //                                              
1739   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ£¨±¾µØ´æ´¢ÒÑ±»Õ¼Âú£©
1740   5      //                                      
1741   5      //                                      }break;
1742   5      //                                      
1743   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioCtl:{
1744   5      //                                              
1745   5      //                                              u8 sw_Act = swScenario_oprateCheck(datsParam[12]);
1746   5      //                                              if(sw_Act != SW_SCENCRAIO_ACTINVALID){ //ÈôË÷Òýµ½ÓÐÐ§²Ù×÷Î»
1747   5      //                                                      
1748   5      //                                                      swCommand_fromUsr.actMethod = relay_OnOff;
1749   5      //                                                      swCommand_fromUsr.objRelay = sw_Act;
1750   5      //                                              
1751   5      //                                                      paramTX_temp[12] = 0;
1752   5      //                                                      
1753   5      //                                              }else{ //ÈôÎÞ·¨Ë÷Òýµ½ÓÐÐ§²Ù×÷Î»
1754   5      //                                              
1755   5      //                                                      paramTX_temp[12] = 0x0A; //³¡¾°¿ØÖÆÎÞÐ§»Ø¸´£¨³¡¾°ºÅÎÞ·¨±»Ë÷Òý£©
1756   5      //                                              }
1757   5      //                                      
1758   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1759   5      //                                      
1760   5      //                                      }break;
1761   5      //                                      
1762   5      //                                      case FRAME_MtoZIGBCMD_cmdCfg_scenarioDel:{
1763   5      //                                              
1764   5      //                                              swScenario_oprateDele(datsParam[12]);
1765   5      //                                              paramTX_temp[12] = 0;
1766   5      //                                      
1767   5      //                                              respond_IF = 1; //ÏìÓ¦»Ø¸´Ê¹ÄÜ
1768   5      //                                      
1769   5      //                                      }break;
1770   5                                              
1771   5                                              default:{
1772   6                                              
1773   6                                                      respond_IF = 0;
1774   6                                              
1775   6                                              }break;
1776   5                                      }
1777   4                                      
1778   4                                      /*»Ø¸´ÏìÓ¦*/
1779   4                                      if(respond_IF){ //Êý¾Ý°ü»Ø¸´ÏìÓ¦¶¯×÷
1780   5                                      
1781   5                                              u8 datsTX_Len = 0;
1782   5                                              
1783   5                                              respond_IF = 0;
1784   5                                              
1785   5                                              datsTX_Len = dtasTX_loadBasic_CUST(dataFromRemote_IF,
1786   5                                                                                                                 paramTX_temp,
1787   5                                                                                                                 33,
1788   5                                                                                                                 FRAME_TYPE_StoM_RCVsuccess,
1789   5                                                                                                                 datsParam[3],
1790   5                                                                                                                 specialCmd_IF);
1791   5                                              
1792   5                                              heartBeatCount = 1; //»Ø¸´ÏìÓ¦µÖÏûÒ»´ÎÐÄÌø
1793   5                                              
1794   5                                              datsSend_request.nwkAddr = nwkAddr_from;
1795   5                                              datsSend_request.portPoint = port_from;
1796   5                                              memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
1797   5                                              memcpy(datsSend_request.datsTrans.dats, paramTX_temp, datsTX_Len);
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 31  

1798   5                                              datsSend_request.datsTrans.datsLen = datsTX_Len;
1799   5                                              datsRcv_respond.datsTrans.datsLen = 0;
1800   5                                              devRunning_Status = status_dataTransRequestDatsSend;
1801   5                                      }
1802   4                              }
1803   3                      }break;
1804   2                      
1805   2                      /*ÐÄÌø_Íø¹ØÔÚÏß*/
1806   2                      case ZIGB_FRAMEHEAD_HEARTBEAT:{
1807   3                      
1808   3                              
1809   3                              
1810   3                      }break;
1811   2                      
1812   2                      /*ÐÄÌø_Íø¹ØÀëÏß*///internetÀëÏß£¬²»ÊÇzigbÍøÂçÀëÏß
1813   2                      case ZIGB_FRAMEHEAD_HBOFFLINE:{
1814   3                      
1815   3                              
1816   3                              
1817   3                      }break;
1818   2                      
1819   2                      default:{}break;
1820   2              }
1821   1      }
1822          
1823          /*zigbeeÖ÷Ïß³Ì*///¶¯×÷×èÈû´óÓÚ200msµÄº¯Êý¶¼ÉèÎª×´Ì¬»úÔËÐÐ£¬ÆäËüÐ¡ÓÚ200msº¯Êý£¬×èÈûÎ¬³Ö£¬·ñÔò×´Ì¬»ú¸´ÔÓ¶È¼Ó
             -´ó
1824          void thread_dataTrans(void){
1825   1              
1826   1              u8 code cmd_datsComing[2] = {0x44, 0x81};
1827   1      
1828   1      #define dataLen_zigbDatsTrans 96
1829   1              u8 xdata paramTX_temp[dataLen_zigbDatsTrans] = {0};
1830   1              u8 xdata paramRX_temp[dataLen_zigbDatsTrans] = {0};
1831   1              
1832   1              static bit heartBeat_cmdFLG = 0; //ÐÄÌøÆæÅ¼±êÖ¾
1833   1              
1834   1              /*zigbÖ÷Ïß³ÌÏµÍ³Ê±¼ä¸üÐÂ*/
1835   1              if(!sysTimeReales_counter){ 
1836   2              
1837   2                      sysTimeReales_counter = PERIOD_SYSTIMEREALES;
1838   2                      getSystemTime_reales();
1839   2              }
1840   1              
1841   1              /*zigbÖ÷Ïß³Ì×´Ì¬»ú£º¸ù¾Ý×´Ì¬±êÖ¾ÔËÐÐ*/
1842   1              switch(devRunning_Status){
1843   2              
1844   2                      case status_passiveDataRcv:{
1845   3                              
1846   3                              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
1847   4                              
1848   4                                      devStatus_switch.statusChange_IF = 0;
1849   4                                      devRunning_Status = devStatus_switch.statusChange_standBy;
1850   4                                      
1851   4                                      break;
1852   4                              }
1853   3                              
1854   3                              {/*³õÊ¼»¯Ê±¼ä¸³Öµ*///½ö¿ª»ú¸³ÖµÒ»´Î£¬²»×öÊ±Çøµ÷Õû
1855   4                                      static bit FLG_timeSetInit = 1;
1856   4                                      
1857   4                                      if(FLG_timeSetInit){
1858   5                                      
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 32  

1859   5                                              FLG_timeSetInit = 0;
1860   5                                              zigB_sysTimeSet(1533810700UL - 946713600UL, 0); //zigbeeÊ±¼ä´Á´Óunix¼ÍÔª946713600<2000/01/01 00:00:00
             ->¿ªÊ¼¼ÆËã
1861   5                                      }
1862   4                              }
1863   3                              
1864   3                              if(devTips_status == status_tipsNwkFind)tips_statusChangeToNormal(); //tips¸´Ô­(ÍøÂçÒÑ¼ÓÈë£¬»Ö¸´Õý³£tip
             -s)
1865   3              
1866   3                              //--------------------------------Ö÷×´Ì¬£ºÐÄÌø--------------------------------------------------------/
             -/
1867   3                              if(heartBeatCycle_FLG){
1868   4                              
1869   4                                      heartBeatCycle_FLG = 0;
1870   4                                      heartBeat_cmdFLG = !heartBeat_cmdFLG;
1871   4                                      
1872   4                                      paramTX_temp[0] = ZIGB_FRAMEHEAD_HEARTBEAT;
1873   4                                      paramTX_temp[1] = 14;
1874   4                                      (heartBeat_cmdFLG)?(paramTX_temp[2] = FRAME_HEARTBEAT_cmdOdd):(paramTX_temp[2] = FRAME_HEARTBEAT_cmdEv
             -en);
1875   4                                      memcpy(&paramTX_temp[4], &MAC_ID[1], 5);
1876   4                                      
1877   4                                      if(heartBeat_cmdFLG){
1878   5                                      
1879   5                                              
1880   5                                      
1881   5                                      }else{
1882   5                                      
1883   5                                              
1884   5                                      }
1885   4                                      
1886   4                                      datsSend_request.nwkAddr = 0;
1887   4                                      datsSend_request.portPoint = ZIGB_ENDPOINT_CTRLNORMAL;
1888   4                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
1889   4                                      memcpy(datsSend_request.datsTrans.dats, paramTX_temp, 14);
1890   4                                      datsSend_request.datsTrans.datsLen = 14;
1891   4                                      datsRcv_respond.datsTrans.datsLen = 0;
1892   4                                      devRunning_Status = status_dataTransRequestDatsSend;
1893   4                                      
1894   4                                      memset(paramTX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans);
1895   4                                      
1896   4                                      return;
1897   4                              }
1898   3                              
1899   3                              //--------------------------------Ö÷×´Ì¬£ºÊý¾ÝÍÆËÍ---------------------------------------------------//
             -        
1900   3                              if(devActionPush_IF.push_IF){
1901   4                                      
1902   4                                      const bit dataFromRemote_IF = 1; //Ô¶³ÌÍÆËÍ
1903   4                                      const bit specialCmd_IF = 0; //·ÇÌØÊâÕ¼Î»
1904   4                                      
1905   4                                      u8 xdata datsTX_Len = 0;
1906   4                                      
1907   4                                      devActionPush_IF.push_IF = 0;
1908   4                                      
1909   4                                      paramTX_temp[11] = devActionPush_IF.dats_Push; //ÍÆËÍÐÅÏ¢Ìî×°
1910   4      
1911   4      #if(DEBUG_LOGOUT_EN == 1)
1912   4                                      { //Êä³ö´òÓ¡£¬½÷¼Ç ÓÃºó×¢ÊÍ£¬·ñÔòÕ¼ÓÃ´óÁ¿´úÂë¿Õ¼ä
1913   5                                              u8 xdata log_buf[64];
1914   5                                              
1915   5                                              sprintf(log_buf, "swData push:%02X.\n", (int)devActionPush_IF.dats_Push);
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 33  

1916   5                                              PrintString1_logOut(log_buf);
1917   5                                      }                       
1918   4      #endif  
1919   4                                      datsTX_Len = dtasTX_loadBasic_CUST(dataFromRemote_IF,
1920   4                                                                                                         paramTX_temp,
1921   4                                                                                                         33,
1922   4                                                                                                         FRAME_TYPE_StoM_RCVsuccess,
1923   4                                                                                                         FRAME_MtoZIGBCMD_cmdControl,
1924   4                                                                                                         specialCmd_IF);
1925   4                              
1926   4                                      datsSend_request.nwkAddr = 0;
1927   4                                      datsSend_request.portPoint = ZIGB_ENDPOINT_CTRLNORMAL;
1928   4                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
1929   4                                      memcpy(datsSend_request.datsTrans.dats, paramTX_temp, datsTX_Len);
1930   4                                      datsSend_request.datsTrans.datsLen = datsTX_Len;
1931   4                                      datsRcv_respond.datsTrans.datsLen = 0;
1932   4                                      devRunning_Status = status_dataTransRequestDatsSend;
1933   4                                      
1934   4                                      memset(paramTX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans);
1935   4      
1936   4                                      return;
1937   4                              }
1938   3                              
1939   3                              //--------------------------------Ö÷×´Ì¬£º»¥¿ØÍ¬²½---------------------------------------------------//
1940   3                              if(EACHCTRL_realesFLG){
1941   4                              
1942   4                                      if(devRunning_Status == status_passiveDataRcv){
1943   5                                      
1944   5                                              u8 idata loop;
1945   5                                              
1946   5                                              for(loop = 0; loop < 3; loop ++){ //Èý¸ö¿ª¹ØÎ»·Ö±ðÅÐ¶¨
1947   6                                              
1948   6                                                      if(EACHCTRL_realesFLG & (1 << loop)){ //»¥¿ØÓÐÐ§Î»ÅÐ¶Ï
1949   7                                                      
1950   7                                                              EACHCTRL_realesFLG &= ~(1 << loop); //»¥¿ØÓÐÐ§Î»ÇåÁã
1951   7                                                              
1952   7                                                              paramTX_temp[0] = (status_Relay >> loop) & 0x01; //¿ª¹Ø×´Ì¬Ìî×°
1953   7                                                              
1954   7                                                              if((CTRLEATHER_PORT[loop] > 0x10) && CTRLEATHER_PORT[loop] < 0xFF){ //ÊÇ·ñÎªÓÐÐ§»¥¿Ø¶Ë¿Ú
1955   8                                                              
1956   8                                                                      datsSend_request.nwkAddr = 0xffff;
1957   8                                                                      datsSend_request.portPoint = CTRLEATHER_PORT[loop];
1958   8                                                                      memset(datsSend_request.datsTrans.dats, 0, DATBASE_LENGTH * sizeof(u8));
1959   8                                                                      memcpy(datsSend_request.datsTrans.dats, paramTX_temp, 1);
1960   8                                                                      datsSend_request.datsTrans.datsLen = 1;
1961   8                                                                      datsRcv_respond.datsTrans.datsLen = 0;
1962   8                                                                      devRunning_Status = status_dataTransRequestDatsSend;
1963   8                                                                      
1964   8                                                                      break; //Ë³ÐòÖ´ÐÐ£¬ÏÈÖ´ÐÐÏÈbreak£¬Ã¿¸ö×Üµ÷¶ÈÖÜÆÚÖ´ÐÐÒ»¸öÓÐÐ§»¥¿Ø
1965   8                                                              }
1966   7                                                      }
1967   6                                              }
1968   5                                      }       
1969   4                              }memset(paramTX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans);
1970   3                              
1971   3                              //--------------------------------Ö÷×´Ì¬£ºÊý¾Ý½âÎöÏìÓ¦-----------------------------------------------//
1972   3                              if(uartRX_toutFLG){ //Êý¾Ý½ÓÊÕ(Ö¡³¬Ê±)
1973   4                                      
1974   4                                      uartRX_toutFLG = 0;
1975   4                                      
1976   4                                      /*ZigbeeÒ»¼¶Ð­ÒéºË¶Ô½âÎö*/
1977   4                                      if((datsRcv_ZIGB.rcvDats[0] == ZIGB_FRAME_HEAD) &&
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 34  

1978   4                                              !memcmp(&datsRcv_ZIGB.rcvDats[2], cmd_datsComing, 2)){
1979   5                                              
1980   5                                              u16 idata datsFrom_addr = ((u16)(datsRcv_ZIGB.rcvDats[9]) << 8) | ((u16)(datsRcv_ZIGB.rcvDats[8]) << 
             -0); //Êý¾Ý·¢ËÍ·½ÍøÂçµØÖ·
1981   5                                              u8      idata srcPoint =  datsRcv_ZIGB.rcvDats[10];     //Ô´¶Ë
1982   5                                              u8      idata dstPoint =  datsRcv_ZIGB.rcvDats[11];     //Ô¶¶Ë
1983   5                                                      
1984   5                                              devTips_nwkZigb = nwkZigb_Normal; //zigbTips×´Ì¬ÏìÓ¦£¬Ö»Òª½ÓÊÕµ½zigbÊý¾Ý£¬tips×´Ì¬¾ÍÇÐ»»ÖÁÕý³£
1985   5                                              
1986   5                                              memset(paramRX_temp, 0, sizeof(u8) * dataLen_zigbDatsTrans);
1987   5                                              memcpy(paramRX_temp, &(datsRcv_ZIGB.rcvDats[21]), datsRcv_ZIGB.rcvDats[20]);
1988   5                                                      
1989   5                                              if(srcPoint > 0x10 && srcPoint < 0xff){ /*»¥¿Ø¶Ë¿Ú*/
1990   6                                                      
1991   6                                                      u8 statusRelay_temp = status_Relay; //µ±Ç°¿ª¹Ø×´Ì¬»º´æ
1992   6                                              
1993   6                                                      if((srcPoint == CTRLEATHER_PORT[0]) && (0 != CTRLEATHER_PORT[0])){ //¿ª¹ØÎ»1 »¥¿Ø°ó¶¨ÅÐ¶Ï
1994   7                                                      
1995   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
1996   7                                                              statusRelay_temp &= ~(1 << 0); //¶¯×÷Î»»º´æÇåÁã
1997   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 0; //bit0 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
1998   7                                                      }
1999   6                                                      else
2000   6                                                      if((srcPoint == CTRLEATHER_PORT[1]) && (0 != CTRLEATHER_PORT[1])){ //¿ª¹ØÎ»2 »¥¿Ø°ó¶¨ÅÐ¶Ï
2001   7                                                      
2002   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2003   7                                                              statusRelay_temp &= ~(1 << 1); //¶¯×÷Î»»º´æÇåÁã
2004   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 1; //bit1 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
2005   7                                                      }
2006   6                                                      else
2007   6                                                      if((srcPoint == CTRLEATHER_PORT[2]) && (0 != CTRLEATHER_PORT[2])){ //¿ª¹ØÎ»3 »¥¿Ø°ó¶¨ÅÐ¶Ï
2008   7                                                      
2009   7                                                              swCommand_fromUsr.actMethod = relay_OnOff;
2010   7                                                              statusRelay_temp &= ~(1 << 2); //¶¯×÷Î»»º´æÇåÁã
2011   7                                                              swCommand_fromUsr.objRelay = statusRelay_temp | paramRX_temp[0] << 2; //bit2 ¿ª¹ØÎ»¶¯×÷ÏìÓ¦
2012   7                                                      }
2013   6                                                      
2014   6                                                      devActionPush_IF.push_IF = 1; //ÍÆËÍÊ¹ÄÜ
2015   6                                              
2016   6                                              }else{ /*·Ç»¥¿Ø¶Ë¿Ú*///Ê£ÏÂ¾ÍÊÇ×¨ÓÃµÄ15¸ö¶Ë¿Ú
2017   6                                              
2018   6                                                      switch(srcPoint){
2019   7                                                              
2020   7                                                              /*³¡¾°¼¯Èº¶Ë¿Ú*/
2021   7                                                              case ZIGB_ENDPOINT_CTRLSECENARIO:{      
2022   8                                                              
2023   8                                                                      dataParing_scenarioCtrl(paramRX_temp); //³¡¾°¼¯Èº¿ØÖÆ½âÎö
2024   8                                                                      
2025   8                                                              }break;
2026   7                                                      
2027   7                                                              /*³£¹æ¿ØÖÆ×ª·¢¶Ë¿Ú*/
2028   7                                                              case ZIGB_ENDPOINT_CTRLNORMAL:{ 
2029   8                                                              
2030   8                                                                      if(datsFrom_addr == ZIGB_NWKADDR_CORDINATER){ //À´×ÔÐ­µ÷Æ÷
2031   9                                                                      
2032   9                                                                              dataParing_Nomal(paramRX_temp, datsFrom_addr, srcPoint); //³£¹æ½âÎö
2033   9                                                                      }
2034   8                                                                      
2035   8                                                              }break;
2036   7                                                              
2037   7                                                              /*zigbÏµÍ³½»»¥¶Ë¿Ú*/
2038   7                                                              case ZIGB_ENDPOINT_CTRLSYSZIGB:{        
C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 35  

2039   8                                                              
2040   8                                                                      dataParing_zigbSysCtrl(paramRX_temp); //ÏµÍ³¿ØÖÆ½âÎö
2041   8                                                                      
2042   8                                                              }break;
2043   7                                                                      
2044   7                                                              default:{
2045   8                                                              
2046   8                                                                      
2047   8                                                                      
2048   8                                                              }break;
2049   7                                                      }
2050   6                                              }
2051   5                                      }
2052   4                              }
2053   3                              
2054   3                      }break;
2055   2                      
2056   2                      case status_nwkREQ:{
2057   3                      
2058   3                              //--------------------------------Ð­×´Ì¬£ºÍøÂçÇëÇó-----------------------------------------------//
2059   3                              devTips_nwkZigb = nwkZigb_nwkREQ;
2060   3                              zigB_nwkJoinRequest(1); //·Ç×èÈûÖ÷¶¯¼ÓÈë¸½½ü¿ª·ÅÍøÂç
2061   3                              
2062   3                      }break;
2063   2                              
2064   2                      case status_nwkReconnect:{
2065   3                      
2066   3                              //--------------------------------Ð­×´Ì¬£ºµôÏß´¦Àí-----------------------------------------------//
2067   3                              devTips_nwkZigb = nwkZigb_reConfig;
2068   3                              zigB_nwkJoinRequest(0); //·Ç×èÈûÖØÁ¬
2069   3                              
2070   3                      }break;
2071   2                      
2072   2                      case status_dataTransRequestDatsSend:{
2073   3                              
2074   3                              //--------------------------------Ð­×´Ì¬£ºÊý¾ÝÇëÇó-----------------------------------------------//
2075   3                              dataTransRequest_datsSend(); //·Ç×èÈûÔ¶¶ËÊý¾Ý´«Êä
2076   3                      
2077   3                      }break;
2078   2                      
2079   2                      case status_devNwkHold:{
2080   3                      
2081   3                              //--------------------------------Ð­×´Ì¬£ºÍøÂç¹ÒÆð-----------------------------------------------//
2082   3                              devTips_nwkZigb = nwkZigb_hold;
2083   3                              function_devNwkHold();
2084   3                              
2085   3                      }break;
2086   2                              
2087   2                      default:{
2088   3                      
2089   3                              if(devStatus_switch.statusChange_IF){ //×´Ì¬Ç¿ÖÆÇÐ»»Ê±£¬½«µ±Ç°×Ó×´Ì¬ÄÚ¾²Ì¬±äÁ¿³õÊ¼»¯ºóÔÙ½øÐÐÍâ²¿ÇÐ»»
2090   4                              
2091   4                                      devStatus_switch.statusChange_IF = 0;
2092   4                                      devRunning_Status = devStatus_switch.statusChange_standBy;
2093   4                                      
2094   4                                      break;
2095   4                              }
2096   3                      
2097   3                      }break;
2098   2              }
2099   1      }

C51 COMPILER V9.54   DATATRANS                                                             09/07/2018 18:15:39 PAGE 36  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6725    ----
   CONSTANT SIZE    =   2808    ----
   XDATA SIZE       =    287    1310
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12     140
   IDATA SIZE       =   ----       8
   BIT SIZE         =      7      17
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
