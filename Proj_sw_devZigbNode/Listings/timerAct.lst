C51 COMPILER V9.54   TIMERACT                                                              09/07/2018 18:15:40 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TIMERACT
OBJECT MODULE PLACED IN .\Output\timerAct.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Actuator\timerAct.c OMF2 ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\
                    -Usr;.\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\timerAct.lst) OBJECT(.\Output
                    -\timerAct.obj)

line level    source

   1          #include "timerAct.h"
   2          
   3          #include "dataManage.h" 
   4          #include "Relay.h"
   5          #include "dataTrans.h"
   6          
   7          #include "string.h"
   8          #include "stdio.h"
   9          
  10          #include "eeprom.h"
  11          
  12          /****************±¾µØÎÄ¼þ±äÁ¿¶¨ÒåÇø*************************/
  13          stt_Time xdata  systemTime_current                              = {0};  //ÏµÍ³Ê±¼ä
  14          u8               xdata  sysTimeReales_counter                   = PERIOD_SYSTIMEREALES;
  15          u8               xdata  sysTimeZone_H                                   = 8;
  16          u8               xdata  sysTimeZone_M                                   = 0;
  17          
  18          u16              idata  sysTimeKeep_counter                             = 0;    //ÏµÍ³Ê±¼äÎ¬³Ö¼ÆÊý£¬Ò»ÃëµÝÔö£¬ÓÃÓÚÏµÍ³Ê±¼ä²éÑ¯ÖÜÆÚµ½´ïÖ®Ç°Î¬³ÖÏµÍ
             -³Ê±¼äÔË×ª
  19          
  20          u8               idata  swTim_onShoot_FLAG                              = 0;    //ÆÕÍ¨¿ª¹Ø¶¨Ê±Ò»´ÎÐÔ±êÖ¾¡ª¡ªµÍËÄÎ»±êÊ¶ËÄ¸ö¶¨Ê±Æ÷
  21          bit              idata  ifTim_sw_running_FLAG                   = 0;    //ÆÕÍ¨¿ª¹Ø¶¨Ê±ÔËÐÐ±êÖ¾Î»
  22          
  23          bit              idata  ifNightMode_sw_running_FLAG             = 0;    //ÆÕÍ¨¿ª¹ØÒ¹¼äÄ£Ê½ÔËÐÐ±êÖ¾Î»
  24          
  25          u8               idata  ifDelay_sw_running_FLAG                 = 0;    //ÑÓÊ±¶¯×÷_ÊÇ·ñÔËÐÐ±êÖ¾Î»£¨bit 1ÑÓÊ±¿ª¹ØÔËÐÐÊ¹ÄÜ±êÖ¾£¬bit 0¶¨Ê±
             -¹Ø±ÕÔËÐÐÊ¹ÄÜ±êÖ¾£©
  26          u16              idata  delayCnt_onoff                                  = 0;    //ÑÓÊ±¶¯×÷¼ÆÊ±¼ÆÊý
  27          u8               idata  delayPeriod_onoff                               = 0;    //ÑÓÊ±¶¯×÷ÖÜÆÚ
  28          u8               idata  delayUp_act                                             = 0;    //ÑÓÊ±¶¯×÷¾ßÌå¶¯×÷
  29          u16              idata  delayCnt_closeLoop                              = 0;    //ÂÌÉ«Ä£Ê½¼ÆÊ±¼ÆÊý
  30          u8               idata  delayPeriod_closeLoop                   = 0;    //ÂÌÉ«Ä£Ê½¶¯×÷ÖÜÆÚ
  31          
  32          /*-----------------------------------------------------------------------------------------------*/
  33          void timeZone_Reales(void){
  34   1      
  35   1              EEPROM_read_n(EEPROM_ADDR_timeZone_H, &sysTimeZone_H, 1);
  36   1              EEPROM_read_n(EEPROM_ADDR_timeZone_M, &sysTimeZone_M, 1);
  37   1      }
  38          
  39          void datsTiming_read_eeprom(timing_Dats timDats_tab[4]){
  40   1      
  41   1              u8 dats_Temp[12] = {0};
  42   1              u8 loop = 0;
  43   1              
  44   1              EEPROM_read_n(EEPROM_ADDR_swTimeTab, dats_Temp, 12);
  45   1              
  46   1              for(loop = 0; loop < 4; loop ++){
  47   2              
  48   2                      timDats_tab[loop].Week_Num      = (dats_Temp[loop * 3 + 0] & 0x7f) >> 0;        /*ÖÜÕ¼Î»Êý¾Ý*///µÍÆßÎ»
  49   2                      timDats_tab[loop].if_Timing = (dats_Temp[loop * 3 + 0] & 0x80) >> 7;    /*ÊÇ·ñ¿ªÆô¶¨Ê±Æ÷Êý¾Ý*///¸ßÒ»Î»
  50   2                      timDats_tab[loop].Status_Act= (dats_Temp[loop * 3 + 1] & 0xe0) >> 5;    /*¶¨Ê±ÏìÓ¦×´Ì¬Êý¾Ý*///¸ßÈýÎ»
  51   2                      timDats_tab[loop].Hour          = (dats_Temp[loop * 3 + 1] & 0x1f) >> 0;        /*¶¨Ê±Ê±¿Ì_Ð¡Ê±*///µÍÎåÎ»
C51 COMPILER V9.54   TIMERACT                                                              09/07/2018 18:15:40 PAGE 2   

  52   2                      timDats_tab[loop].Minute        = (dats_Temp[loop * 3 + 2] & 0xff) >> 0;        /*¶¨Ê±Ê±¿Ì_·Ö*///È«°ËÎ»
  53   2              }
  54   1      }
  55          
  56          void datsTimNight_read_eeprom(timing_Dats timDats_tab[2]){
  57   1      
  58   1              u8 dats_Temp[6] = {0};
  59   1              u8 loop = 0;
  60   1              
  61   1              EEPROM_read_n(EEPROM_ADDR_TimeTabNightMode, dats_Temp, 6);
  62   1              
  63   1              for(loop = 0; loop < 2; loop ++){
  64   2              
  65   2                      timDats_tab[loop].Week_Num      = (dats_Temp[loop * 3 + 0] & 0x7f) >> 0;        /*ÖÜÕ¼Î»Êý¾Ý*///µÍÆßÎ» ------------Ò
             -¹¼ä¶¨Ê±Êý¾ÝÊ±£¬ÖÜÕ¼Î»È«Îª1Ê±Ôò±íÊ¾È«Ìì
  66   2                      timDats_tab[loop].if_Timing = (dats_Temp[loop * 3 + 0] & 0x80) >> 7;    /*ÊÇ·ñ¿ªÆô¶¨Ê±Æ÷Êý¾Ý*///¸ßÒ»Î»
  67   2                      timDats_tab[loop].Status_Act= (dats_Temp[loop * 3 + 1] & 0xe0) >> 5;    /*¶¨Ê±ÏìÓ¦×´Ì¬Êý¾Ý*///¸ßÈýÎ»
  68   2                      timDats_tab[loop].Hour          = (dats_Temp[loop * 3 + 1] & 0x1f) >> 0;        /*¶¨Ê±Ê±¿Ì_Ð¡Ê±*///µÍÎåÎ»
  69   2                      timDats_tab[loop].Minute        = (dats_Temp[loop * 3 + 2] & 0xff) >> 0;        /*¶¨Ê±Ê±¿Ì_·Ö*///È«°ËÎ»
  70   2              }
  71   1      }
  72          
  73          /*ÖÜÕ¼Î»ÅÐ¶Ï*///ÅÐ¶Ïµ±Ç°ÖÜÖµÊÇ·ñÔÚÕ¼Î»×Ö½ÚÖÐ
  74          bit weekend_judge(u8 weekNum, u8 HoldNum){
  75   1      
  76   1              u8 loop;
  77   1              
  78   1              weekNum --;
  79   1              for(loop = 0; loop < 7; loop ++){
  80   2              
  81   2                      if(HoldNum & (1 << loop)){
  82   3                              
  83   3                              if(loop == weekNum)return 1;
  84   3                      }
  85   2              }
  86   1              
  87   1              return 0;
  88   1      }
  89          
  90          #if(DEBUG_LOGOUT_EN == 1)
  91          void time_Logout(stt_Time code timeDats){
  92   1      
  93   1              u8 xdata Log[80]        = {0};
  94   1              
  95   1              /*»º´æ²»×ãÊ±£¬·Ö´Î´òÓ¡*/
  96   1              
  97   1      //      sprintf(Log, 
  98   1      //      "\n>>===Ê±¼ä´Á===<<\n    20%d/%02d/%02d-W%01d\n        %02d:%02d:%02d\n", 
  99   1      //                      (int)timeDats.time_Year,
 100   1      //                      (int)timeDats.time_Month,
 101   1      //                      (int)timeDats.time_Day,
 102   1      //                      (int)timeDats.time_Week,
 103   1      //                      (int)timeDats.time_Hour,
 104   1      //                      (int)timeDats.time_Minute,
 105   1      //                      (int)timeDats.time_Second);
 106   1      //                      
 107   1      ////    LogDats(Log, strlen(Log));
 108   1      //      PrintString1_logOut(Log);
 109   1              
 110   1              sprintf(Log, 
 111   1              "\n>>===Ê±¼ä´Á===<<\n    20%d/%02d/%02d-W%01d\n", 
 112   1                              (int)timeDats.time_Year,
C51 COMPILER V9.54   TIMERACT                                                              09/07/2018 18:15:40 PAGE 3   

 113   1                              (int)timeDats.time_Month,
 114   1                              (int)timeDats.time_Day,
 115   1                              (int)timeDats.time_Week);
 116   1                              
 117   1      //      LogDats(Log, strlen(Log));
 118   1              PrintString1_logOut(Log);
 119   1                              
 120   1              sprintf(Log, 
 121   1              "        %02d:%02d:%02d\n", 
 122   1                              (int)timeDats.time_Hour,
 123   1                              (int)timeDats.time_Minute,
 124   1                              (int)timeDats.time_Second);
 125   1                              
 126   1      //      LogDats(Log, strlen(Log));
 127   1              PrintString1_logOut(Log);
 128   1                              
 129   1              sprintf(Log, 
 130   1                              "timeZone_H:%02d.\n", 
 131   1                              (int)sysTimeZone_H);
 132   1                              
 133   1              PrintString1_logOut(Log);
 134   1      }
 135          #endif
 136          
 137          void thread_Timing(void){
 138   1      
 139   1              u8 loop = 0;
 140   1              
 141   1              timing_Dats xdata timDatsTemp_CalibrateTab[4] = {0};    /*¶¨Ê±ÆðÊ¼Ê±¿Ì±í»º´æ*///ÆðÊ¼Ê±¿Ì¼°ÊôÐÔ
 142   1              timing_Dats xdata nightDatsTemp_CalibrateTab[2] = {0};  /*Ò¹¼äÄ£Ê½ÆðÊ¼Ê±¿Ì±í»º´æ*///ÆðÊ¼Ê±¿Ì¼°ÊôÐÔ
 143   1      
 144   1      #if(DEBUG_LOGOUT_EN == 1)       
 145   1              { //µ÷ÊÔlog´úÂë-µ±Ç°Ê±¼äÊä³ö
 146   2                      
 147   2                      u16 code log_period = 5000;
 148   2                      static u16 xdata log_Count = 0;
 149   2                      
 150   2                      if(log_Count < log_period)log_Count ++;
 151   2                      else{
 152   3                      
 153   3                              log_Count = 0;
 154   3                              
 155   3                              time_Logout(systemTime_current);
 156   3                      }
 157   2              }
 158   1      #endif
 159   1      
 160   1              /*ÑÓÊ±ÒµÎñ¼°×Ô¶¯Ñ­»·ÒµÎñµôµç´æ´¢Êý¾Ý¶ÁÈ¡*///¿ª»ú¶ÁÒ»´Î¸üÐÂ¼´¿É
 161   1              {
 162   2                      
 163   2                      static bit read_FLG = 0;
 164   2                      
 165   2                      if(!read_FLG){
 166   3                      
 167   3                              read_FLG = 1;
 168   3                              
 169   3                              EEPROM_read_n(EEPROM_ADDR_swDelayFLAG, &ifDelay_sw_running_FLAG, 1);
 170   3                              EEPROM_read_n(EEPROM_ADDR_periodCloseLoop, &delayPeriod_closeLoop, 1);
 171   3                      }
 172   2              }
 173   1              
 174   1              /*ÏµÍ³Ê±¼äÎ¬³Ö¸üÐÂ*///zigb²éÑ¯sysTimeÖÜÆÚÖ®Íâ ±¾µØ×ÔÐÐÃ¿Ãë¸üÐÂ
C51 COMPILER V9.54   TIMERACT                                                              09/07/2018 18:15:40 PAGE 4   

 175   1              {
 176   2                      
 177   2                      systemTime_current.time_Minute = sysTimeKeep_counter / 60;
 178   2                      systemTime_current.time_Second = sysTimeKeep_counter % 60;
 179   2                      
 180   2                      if(sysTimeKeep_counter < 3600){
 181   3                              
 182   3                      }else{
 183   3                      
 184   3                              sysTimeKeep_counter = 0;
 185   3                              (systemTime_current.time_Hour >= 24)?(systemTime_current.time_Hour = 0):(systemTime_current.time_Hour +
             -+);
 186   3                              (systemTime_current.time_Week >   7)?(systemTime_current.time_Week = 1):(systemTime_current.time_Week +
             -+);
 187   3                      }
 188   2              }
 189   1              
 190   1              /*Ò¹¼äÄ£Ê½¶¨Ê±*///Á½¶ÎÊý¾Ý===============================================================================
             -========================<<<
 191   1              datsTimNight_read_eeprom(nightDatsTemp_CalibrateTab);
 192   1              /*ÅÐ¶ÏÊÇ·ñÎªÒ¹¼äÄ£Ê½*/
 193   1              if((nightDatsTemp_CalibrateTab[0].Week_Num & 0x7F) == 0x7F){ //È«ÌìÅÐ¶Ï£¬Èç¹ûµÚÒ»¶ÎÖÜÕ¼Î»È«ÂúÔòÎªÈ«Ìì
 194   2              
 195   2                      ifNightMode_sw_running_FLAG = 1;
 196   2                      
 197   2              }else{
 198   2                      
 199   2                      if(nightDatsTemp_CalibrateTab[0].if_Timing){ //Ê¹ÄÜÅÐ¶Ï
 200   3                      
 201   3                              if(((u16)systemTime_current.time_Hour * 60 + (u16)systemTime_current.time_Minute) >  ((u16)nightDatsTem
             -p_CalibrateTab[0].Hour * 60 + (u16)nightDatsTemp_CalibrateTab[0].Minute) && //¶¨Ê±Çø¼äÅÐ¶Ï
 202   3                                 ((u16)systemTime_current.time_Hour * 60 + (u16)systemTime_current.time_Minute) <= ((u16)nightDatsTem
             -p_CalibrateTab[1].Hour * 60 + (u16)nightDatsTemp_CalibrateTab[1].Minute)){
 203   4                                 
 204   4                                      ifNightMode_sw_running_FLAG = 1;
 205   4                                         
 206   4                              }else{
 207   4                              
 208   4                                      ifNightMode_sw_running_FLAG = 0;
 209   4                              }
 210   3                              
 211   3                      }else{
 212   3                      
 213   3                              ifNightMode_sw_running_FLAG = 0;
 214   3                      }
 215   2              }
 216   1              
 217   1              /*ÆÕÍ¨¿ª¹Ø¶¨Ê±*///ËÄ¶ÎÊý¾Ý===============================================================================
             -========================<<<
 218   1              datsTiming_read_eeprom(timDatsTemp_CalibrateTab);       /*ÆÕÍ¨¿ª¹Ø*///Ê±¿Ì±í¶ÁÈ¡
 219   1              /*ÅÐ¶ÏÊÇ·ñËùÓÐÆÕÍ¨¿ª¹Ø¶¨Ê±¶¼Îª¹Ø*/
 220   1              if((timDatsTemp_CalibrateTab[0].if_Timing == 0) &&      //È«¹Ø£¬ÖÃ±êÖ¾Î»
 221   1                 (timDatsTemp_CalibrateTab[1].if_Timing == 0) &&
 222   1                 (timDatsTemp_CalibrateTab[2].if_Timing == 0) &&
 223   1                 (timDatsTemp_CalibrateTab[3].if_Timing == 0)
 224   1                ){
 225   2                
 226   2                      ifTim_sw_running_FLAG = 0; 
 227   2                        
 228   2              }else{  //·ÇÈ«¹Ø£¬ÖÃ±êÖ¾Î»£¬²¢Ö´ÐÐ¶¨Ê±Âß¼­
 229   2                      
 230   2                      ifTim_sw_running_FLAG = 1; 
C51 COMPILER V9.54   TIMERACT                                                              09/07/2018 18:15:40 PAGE 5   

 231   2              
 232   2                      for(loop = 0; loop < 4; loop ++){
 233   3                              
 234   3                              if(weekend_judge(systemTime_current.time_Week, timDatsTemp_CalibrateTab[loop].Week_Num)){       //ÖÜÕ¼Î»±È¶Ô£
             -¬³É¹¦²Å½øÐÐÏÂÒ»²½
 235   4                              
 236   4                                      if(timCount_ENABLE == timDatsTemp_CalibrateTab[loop].if_Timing){        //ÊÇ·ñ¿ªÆô¶¨Ê±
 237   5                                              
 238   5      //                                      { //µ÷ÊÔlog´úÂë-µ±Ç°ÓÐÐ§¶¨Ê±ÐÅÏ¢Êä³ö
 239   5      //                                              
 240   5      //                                              u8 xdata log_dats[80] = {0};
 241   5      //                                              u8 code log_period = 200;
 242   5      //                                              static u8 log_Count = 0;
 243   5      //                                              
 244   5      //                                              if(log_Count < log_period)log_Count ++;
 245   5      //                                              else{
 246   5      //                                              
 247   5      //                                                      log_Count = 0;
 248   5      //                                                      
 249   5      //                                                      sprintf(log_dats, 
 250   5      //                                                                      "ÓÐÐ§¶¨Ê±£º%dºÅ, ¶¨_Ê±:%d, ¶¨_·Ö:%d \n", 
 251   5      //                                                                      (int)loop, 
 252   5      //                                                                      (int)timDatsTemp_CalibrateTab[loop].Hour, 
 253   5      //                                                                      (int)timDatsTemp_CalibrateTab[loop].Minute);
 254   5      //                                                      /*logµ÷ÊÔ´òÓ¡*///ÆÕÍ¨¶¨Ê±¶¨Ê±ÐÅÏ¢
 255   5      //                                                      uartObjWIFI_Send_String(log_dats, strlen(log_dats));
 256   5      //                                              }
 257   5      //                                      }
 258   5                                              
 259   5                                              if(((u16)systemTime_current.time_Hour * 60 + (u16)systemTime_current.time_Minute) ==  \
 260   5                                                 ((u16)timDatsTemp_CalibrateTab[loop].Hour * 60 + (u16)timDatsTemp_CalibrateTab[loop].Minute) && //
             -Ê±¿Ì±È¶Ô
 261   5                                                 ((u16)systemTime_current.time_Second <= 10)){         //Ê±¿Ì±È¶ÔÊ±¼äÏÞÔÚÇ°10Ãë
 262   6                                                         
 263   6      //                                              uartObjWIFI_Send_String("time_UP!!!", 11);
 264   6                                                      
 265   6                                                      //Ò»´ÎÐÔ¶¨Ê±ÅÐ¶Ï
 266   6                                                      if(swTim_onShoot_FLAG & (1 << loop)){   //ÊÇ·ñÎªÒ»´ÎÐÔ¶¨Ê±£¬ÊÇÔòÇå¿Õ±¾¶Î¶¨Ê±ÐÅÏ¢
 267   7                                                              
 268   7                                                              u8 code dats_Temp = 0;
 269   7                                                              
 270   7                                                              swTim_onShoot_FLAG &= ~(1 << loop);
 271   7                                                              coverEEPROM_write_n(EEPROM_ADDR_swTimeTab + loop * 3, &dats_Temp, 1); //¶¨Ê±ÐÅÏ¢Çå¿Õ
 272   7                                                      }
 273   6                                                 
 274   6                                                      //ÆÕÍ¨¿ª¹Ø¶¯×÷ÏìÓ¦
 275   6                                                      swCommand_fromUsr.actMethod = relay_OnOff; //¿ª¹Ø¶¯×÷
 276   6                                                      swCommand_fromUsr.objRelay = timDatsTemp_CalibrateTab[loop].Status_Act;
 277   6                                                      devActionPush_IF.push_IF = 1; //ÍÆËÍÊ¹ÄÜ
 278   6                                                      
 279   6                                              }else
 280   5                                              if(((u16)systemTime_current.time_Hour * 60 + (u16)systemTime_current.time_Minute) >     //µ±Ç°Ê±¼ä´óÓÚ¶¨Ê
             -±Ê±¼ä£¬Ö±½ÓÇå³ýÒ»´ÎÐÔ±êÖ¾
 281   5                                                 ((u16)timDatsTemp_CalibrateTab[loop].Hour * 60 + (u16)timDatsTemp_CalibrateTab[loop].Minute)){
 282   6                                                         
 283   6                                                      //Ò»´ÎÐÔ¶¨Ê±ÅÐ¶Ï
 284   6                                                      if(swTim_onShoot_FLAG & (1 << loop)){   //ÊÇ·ñÎªÒ»´ÎÐÔ¶¨Ê±£¬ÊÇÔòÇå¿Õ±¾¶Î¶¨Ê±ÐÅÏ¢
 285   7                                                              
 286   7                                                              u8 code dats_Temp = 0;
 287   7                                                              
 288   7                                                              swTim_onShoot_FLAG &= ~(1 << loop);
 289   7                                                              coverEEPROM_write_n(EEPROM_ADDR_swTimeTab + loop * 3, &dats_Temp, 1); //¶¨Ê±ÐÅÏ¢Çå¿Õ
C51 COMPILER V9.54   TIMERACT                                                              09/07/2018 18:15:40 PAGE 6   

 290   7                                                      }
 291   6                                              }
 292   5                                      }
 293   4                              }
 294   3                      }
 295   2              }
 296   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1540    ----
   CONSTANT SIZE    =    206    ----
   XDATA SIZE       =     12      98
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      34
   IDATA SIZE       =     11    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
