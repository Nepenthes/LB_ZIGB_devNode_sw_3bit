C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE USRKIN
OBJECT MODULE PLACED IN .\Output\usrKin.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Sensor\usrKin.c OMF2 ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr;
                    -.\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\usrKin.lst) OBJECT(.\Output\usrKi
                    -n.obj)

line level    source

   1          #include "usrKin.h"
   2          
   3          #include "Tips.h"
   4          #include "dataTrans.h"
   5          #include "dataManage.h"
   6          #include "Relay.h"
   7          
   8          #include "delay.h"
   9          #include "USART.h"
  10          
  11          #include "stdio.h"
  12          #include "string.h"
  13          
  14          /**********************本地文件变量定义区**********************/
  15          u8 idata val_DcodeCfm                   = 0;  //拨码值
  16          bit              ledBackground_method   = 1;  //背景灯颜色方案 //为1时：开-绿 关-蓝   为0时：开-蓝 关-绿
  17          
  18          bit              usrKeyCount_EN                 = 0;  //用户按键计数
  19          u16              usrKeyCount                    = 0;
  20          
  21          u16     xdata touchPadActCounter        = 0;  //触摸盘按键计时
  22          u16     xdata touchPadContinueCnt       = 0;  //触摸盘连按计时
  23          
  24          //***************Tips变量引用区***************************/
  25          extern tips_Status devTips_status;
  26          
  27          /*--------------------------------------------------------------------------------------------------------
             -----*/
  28          //funKey_Callback xdata funKey[10] = {0};
  29          
  30          static void touchPad_functionTrigNormal(u8 statusPad, keyCfrm_Type statusCfm);
  31          static void touchPad_functionTrigContinue(u8 statusPad, u8 loopCount);
  32          
  33          void usrKin_pinInit(void){
  34   1      
  35   1              P1M1 &= ~(0xE0);
  36   1              P1M0 &= ~(0xE0);
  37   1      
  38   1              P0M1 &= ~(0x04);
  39   1              P0M0 &= ~(0x04);
  40   1              
  41   1              if(!Dcode2)relayStatus_ifSave = statusSave_enable;
  42   1      }
  43          
  44          void usrZigbNwkOpen(void){
  45   1      
  46   1              ZigB_nwkOpen(1, ZIGBNWK_OPNETIME_DEFAULT); //功能触发
  47   1              tips_statusChangeToZigbNwkOpen(ZIGBNWK_OPNETIME_DEFAULT); //tips触发
  48   1      }
  49          
  50          u8 DcodeScan_oneShoot(void){
  51   1      
  52   1              u8 val_Dcode = 0;
C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 2   

  53   1              
  54   1              if(!Dcode0)val_Dcode |= 1 << 0;
  55   1              else val_Dcode &= ~(1 << 0);
  56   1              
  57   1              if(!Dcode1)val_Dcode |= 1 << 1;
  58   1              else val_Dcode &= ~(1 << 1);
  59   1              
  60   1              if(!Dcode2)val_Dcode |= 1 << 2;
  61   1              else val_Dcode &= ~(1 << 2);
  62   1              
  63   1              if(!Dcode3)val_Dcode |= 1 << 3;
  64   1              else val_Dcode &= ~(1 << 3);
  65   1              
  66   1              if(!Dcode4)val_Dcode |= 1 << 4;
  67   1              else val_Dcode &= ~(1 << 4);
  68   1              
  69   1              if(!Dcode5)val_Dcode |= 1 << 5;
  70   1              else val_Dcode &= ~(1 << 5);
  71   1              
  72   1              return val_Dcode;
  73   1      }
  74          
  75          bit UsrKEYScan_oneShoot(void){
  76   1      
  77   1              return Usr_key;
  78   1      }
  79          
  80          u8 touchPadScan_oneShoot(void){
  81   1      
  82   1              u8 valKey_Temp = 0;
  83   1              
  84   1              if(!touchPad_1)valKey_Temp |= 0x01;
  85   1              if(!touchPad_2)valKey_Temp |= 0x02;
  86   1              if(!touchPad_3)valKey_Temp |= 0x04;
  87   1              
  88   1              return valKey_Temp;
  89   1      }
  90          
  91          void DcodeScan(void){
  92   1      
  93   1              static u8       val_Dcode_Local         = 0,
  94   1                                      comfirm_Cnt                     = 0;
  95   1              const  u8       comfirm_Period          = 200;  //消抖时间因数――取决于主线程调度周期
  96   1                      
  97   1                         u8   val_Dcode_differ        = 0;
  98   1              
  99   1                         bit  val_CHG                         = 0;
 100   1              
 101   1              val_DcodeCfm = DcodeScan_oneShoot();
 102   1              
 103   1              DEV_actReserve = switchTypeReserve_GET(); //当前开关类型对应有效操作位刷新
 104   1              
 105   1              if(val_Dcode_Local != val_DcodeCfm){
 106   2              
 107   2                      if(comfirm_Cnt < comfirm_Period)comfirm_Cnt ++;
 108   2                      else{
 109   3                      
 110   3                              comfirm_Cnt = 0;
 111   3                              val_CHG         = 1;
 112   3                      }
 113   2              }
 114   1              
C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 3   

 115   1              if(val_CHG){
 116   2                      
 117   2                      val_CHG                         = 0;
 118   2              
 119   2                      val_Dcode_differ        = val_Dcode_Local ^ val_DcodeCfm;
 120   2                      val_Dcode_Local         = val_DcodeCfm;
 121   2      
 122   2                      if(val_Dcode_differ & Dcode_FLG_ifAP){
 123   3                      
 124   3                              if(val_Dcode_Local & Dcode_FLG_ifAP){
 125   4                              
 126   4      
 127   4                              }else{
 128   4                              
 129   4      
 130   4                              }
 131   3                      }
 132   2                      
 133   2                      if(val_Dcode_differ & Dcode_FLG_ifLED){
 134   3                      
 135   3                              if(val_Dcode_Local & Dcode_FLG_ifLED){
 136   4      
 137   4                                      
 138   4                              }else{
 139   4                              
 140   4      
 141   4                              }
 142   3                      }
 143   2                      
 144   2                      if(val_Dcode_differ & Dcode_FLG_ifMemory){
 145   3                      
 146   3                              if(val_Dcode_Local & Dcode_FLG_ifMemory){
 147   4      
 148   4                                      relayStatus_ifSave = statusSave_enable;
 149   4                                      
 150   4                              }else{
 151   4                              
 152   4                                      relayStatus_ifSave = statusSave_disable;
 153   4                              }
 154   3                      }
 155   2                      
 156   2                      if(val_Dcode_differ & Dcode_FLG_bitReserve){
 157   3                      
 158   3                              switch(Dcode_bitReserve(val_Dcode_Local)){
 159   4                              
 160   4                                      case 0:{
 161   5                                      
 162   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT3;       
 163   5                                              
 164   5                                      }break;
 165   4                                              
 166   4                                      case 1:{
 167   5                                      
 168   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT1;       
 169   5      
 170   5                                      }break;
 171   4                                              
 172   4                                      case 2:{
 173   5                                      
 174   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT2;       
 175   5      
 176   5                                      }break;
C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 4   

 177   4                                              
 178   4                                      case 3:{
 179   5                                              
 180   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT3;       
 181   5      
 182   5                                      }break;
 183   4                                              
 184   4                                      default:break;
 185   4                              }
 186   3                      }
 187   2              }
 188   1      }
 189          
 190          void UsrKEYScan(funKey_Callback funCB_Short, funKey_Callback funCB_LongA, funKey_Callback funCB_LongB){
 191   1              
 192   1              code    u16     keyCfrmLoop_Short       = 10,   //短按消抖时间,据大循环而定
 193   1                                      keyCfrmLoop_LongA       = 3000, //长按A时间,据大循环而定
 194   1                                      keyCfrmLoop_LongB       = 10000,//长按B时间,据大循环而定
 195   1                                      keyCfrmLoop_MAX         = 60000;//计时封顶
 196   1              
 197   1              static  bit LongA_FLG = 0;
 198   1              static  bit LongB_FLG = 0;
 199   1              
 200   1              static  bit keyPress_FLG = 0;
 201   1      
 202   1              if(!UsrKEYScan_oneShoot()){             
 203   2                      
 204   2                      keyPress_FLG = 1;
 205   2                      
 206   2      //              tips_statusChangeToNormal();
 207   2              
 208   2                      if(!usrKeyCount_EN) usrKeyCount_EN= 1;  //计时
 209   2                      
 210   2                      if((usrKeyCount >= keyCfrmLoop_LongA) && (usrKeyCount <= keyCfrmLoop_LongB) && !LongA_FLG){
 211   3                      
 212   3                              funCB_LongA();
 213   3                              
 214   3                              LongA_FLG = 1;
 215   3                      }       
 216   2                      
 217   2                      if((usrKeyCount >= keyCfrmLoop_LongB) && (usrKeyCount <= keyCfrmLoop_MAX) && !LongB_FLG){
 218   3                      
 219   3                              funCB_LongB();
 220   3                              
 221   3                              LongB_FLG = 1;
 222   3                      }
 223   2                      
 224   2              }else{          
 225   2                      
 226   2                      usrKeyCount_EN = 0;
 227   2                      
 228   2                      if(keyPress_FLG){
 229   3                      
 230   3                              keyPress_FLG = 0;
 231   3                              
 232   3                              if(usrKeyCount < keyCfrmLoop_LongA && usrKeyCount > keyCfrmLoop_Short){
 233   4                              
 234   4      //                              static bit tipsFLG = 0;
 235   4      //                               
 236   4      //                              tipsFLG = !tipsFLG;
 237   4      //                              (tipsFLG)?(tipsLED_colorSet(obj_zigbNwk, 5, 0, 0)):(tipsLED_colorSet(obj_zigbNwk, 0, 5, 0));
 238   4                                      
C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 5   

 239   4                                      funCB_Short();
 240   4                              }
 241   3                              
 242   3                              usrKeyCount = 0;
 243   3                              LongA_FLG       = 0;
 244   3                              LongB_FLG       = 0;
 245   3                      }
 246   2              }
 247   1      }
 248          
 249          void touchPad_Scan(void){
 250   1      
 251   1              static u8 touchPad_temp = 0;
 252   1              static bit keyPress_FLG = 0;
 253   1              
 254   1              static bit funTrigFLG_LongA = 0;
 255   1              static bit funTrigFLG_LongB = 0;
 256   1              
 257   1              code    u16     touchCfrmLoop_Short     = timeDef_touchPressCfm,        //短按消抖时间
 258   1                                      touchCfrmLoop_LongA     = timeDef_touchPressLongA,      //长按A时间
 259   1                                      touchCfrmLoop_LongB     = timeDef_touchPressLongB,      //长按B时间
 260   1                                      touchCfrmLoop_MAX               = 60000;//计时封顶
 261   1              
 262   1              static u8 pressContinueGet = 0;
 263   1                     u8 pressContinueCfm = 0;
 264   1              
 265   1              u16 conterTemp = 0; //按下计时差值计算缓存
 266   1              
 267   1              if(touchPadScan_oneShoot()){
 268   2                      
 269   2                      if(!keyPress_FLG){
 270   3                      
 271   3                              keyPress_FLG = 1;
 272   3                              touchPadActCounter = touchCfrmLoop_MAX;
 273   3                              touchPadContinueCnt = timeDef_touchPressContinue;  //连按间隔判断时间
 274   3                              touchPad_temp = touchPadScan_oneShoot();
 275   3                      }
 276   2                      else{
 277   3                              
 278   3                              if(touchPad_temp == touchPadScan_oneShoot()){
 279   4                                      
 280   4                                      conterTemp = touchCfrmLoop_MAX - touchPadActCounter;
 281   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 282   4      //                                      u8 xdata log_buf[64];
 283   4      //                                      
 284   4      //                                      sprintf(log_buf, "conut:%d.\n", (int)conterTemp);
 285   4      //                                      PrintString1_logOut(log_buf);
 286   4      //                              }
 287   4                              
 288   4                                      if(conterTemp > touchCfrmLoop_LongA && conterTemp <= touchCfrmLoop_LongB){
 289   5                                      
 290   5                                              if(!funTrigFLG_LongA){
 291   6                                              
 292   6                                                      funTrigFLG_LongA = 1;
 293   6                                                      touchPad_functionTrigNormal(touchPad_temp, press_LongA);
 294   6                                              }
 295   5                                      }
 296   4                                      if(conterTemp > touchCfrmLoop_LongB && conterTemp <= touchCfrmLoop_MAX){
 297   5                                      
 298   5                                              if(!funTrigFLG_LongB){
 299   6                                              
 300   6                                                      funTrigFLG_LongB = 1;
C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 6   

 301   6                                                      touchPad_functionTrigNormal(touchPad_temp, press_LongB);
 302   6                                              }
 303   5                                      }
 304   4                              }
 305   3                      }
 306   2              }else{
 307   2                      
 308   2                      if(keyPress_FLG){
 309   3                      
 310   3                              conterTemp = touchCfrmLoop_MAX - touchPadActCounter;
 311   3                              if(conterTemp > touchCfrmLoop_Short && conterTemp <= touchCfrmLoop_LongA){
 312   4                              
 313   4                                      if(touchPadContinueCnt)pressContinueGet ++;
 314   4                                      if(pressContinueGet <= 1)touchPad_functionTrigNormal(touchPad_temp, press_Short); //非连按短按触发互控
             -同步，若为连按则最后一次触发同步
 315   4                                      else touchPad_functionTrigNormal(touchPad_temp, press_ShortCnt);
 316   4                                      beeps_usrActive(3, 50, 3);
 317   4                              }
 318   3                      }
 319   2              
 320   2                      if(!touchPadContinueCnt && pressContinueGet){
 321   3                      
 322   3                              pressContinueCfm = pressContinueGet;
 323   3                              pressContinueGet = 0;
 324   3                              
 325   3                              if(pressContinueCfm >= 2){
 326   4      #if(DEBUG_LOGOUT_EN == 1)
 327   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 328   4      //                                      u8 xdata log_buf[64];
 329   4      //                                      
 330   4      //                                      sprintf(log_buf, "conut:%d.\n", (int)pressContinueCfm);
 331   4      //                                      PrintString1_logOut(log_buf);
 332   4      //                              }                       
 333   4      #endif
 334   4                                      touchPad_functionTrigContinue(touchPad_temp, pressContinueCfm);
 335   4                                      pressContinueCfm = 0;
 336   4                              }
 337   3                              
 338   3                              touchPad_temp = 0;
 339   3                      }
 340   2      
 341   2                      funTrigFLG_LongA = 0;
 342   2                      funTrigFLG_LongB = 0;
 343   2                              
 344   2                      touchPadActCounter = 0;
 345   2                      keyPress_FLG = 0;
 346   2              }
 347   1      }
 348          
 349          void touchPad_functionTrigNormal(u8 statusPad, keyCfrm_Type statusCfm){ //普通触摸触发
 350   1      
 351   1              switch(statusCfm){
 352   2              
 353   2                      case press_Short:{
 354   3                              
 355   3      #if(DEBUG_LOGOUT_EN == 1)                               
 356   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 357   4                                      u8 xdata log_buf[64];
 358   4                                      
 359   4                                      sprintf(log_buf, "touchPad:%02X, shortPress.\n", (int)statusPad);
 360   4                                      PrintString1_logOut(log_buf);
 361   4                              }
C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 7   

 362   3      #endif  
 363   3                              switch(statusPad){
 364   4                                      
 365   4                                      case 1:
 366   4                                      case 2:
 367   4                                      case 4:{
 368   5                                              
 369   5                                              swCommand_fromUsr.actMethod = relay_flip;
 370   5                                              swCommand_fromUsr.objRelay = statusPad;
 371   5                                              EACHCTRL_realesFLG = statusPad; //互控
 372   5                                              devActionPush_IF.push_IF = 1; //推送使能
 373   5                                              
 374   5                                      }break;
 375   4                                              
 376   4                                      default:{}break;
 377   4                              }
 378   3                              
 379   3                      }break;
 380   2                      
 381   2                      case press_ShortCnt:{
 382   3                              
 383   3      #if(DEBUG_LOGOUT_EN == 1)                               
 384   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 385   4                                      u8 xdata log_buf[64];
 386   4                                      
 387   4                                      sprintf(log_buf, "touchPad:%02X, cntPress.\n", (int)statusPad);
 388   4                                      PrintString1_logOut(log_buf);
 389   4                              }
 390   3      #endif  
 391   3                              
 392   3                              switch(statusPad){
 393   4                                      
 394   4                                      case 1:
 395   4                                      case 2:
 396   4                                      case 4:{
 397   5                                              
 398   5                                              swCommand_fromUsr.actMethod = relay_flip;
 399   5                                              swCommand_fromUsr.objRelay = statusPad;
 400   5                                              
 401   5                                      }break;
 402   4                                              
 403   4                                      default:{}break;
 404   4                              }
 405   3                              
 406   3                      }break;
 407   2                      
 408   2                      case press_LongA:{
 409   3                              
 410   3      #if(DEBUG_LOGOUT_EN == 1)                               
 411   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 412   4                                      u8 xdata log_buf[64];
 413   4                                      
 414   4                                      sprintf(log_buf, "touchPad:%02X, longPress_A.\n", (int)statusPad);
 415   4                                      PrintString1_logOut(log_buf);
 416   4                              }
 417   3      #endif  
 418   3                      
 419   3                              switch(statusPad){
 420   4                              
 421   4                                      case 1:{
 422   5                                              
 423   5                                      
C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 8   

 424   5                                      }break;
 425   4                                              
 426   4                                      case 2:{}break;
 427   4                                              
 428   4                                      case 4:{
 429   5                                      
 430   5                                              devStatusChangeTo_devHold(1); //设备网络挂起
 431   5                                      
 432   5                                      }break;
 433   4                                              
 434   4                                      default:{}break;
 435   4                              }
 436   3                              
 437   3                      }break;
 438   2                              
 439   2                      case press_LongB:{
 440   3                              
 441   3      #if(DEBUG_LOGOUT_EN == 1)                               
 442   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 443   4                                      u8 xdata log_buf[64];
 444   4                                      
 445   4                                      sprintf(log_buf, "touchPad:%02X, longPress_B.\n", (int)statusPad);
 446   4                                      PrintString1_logOut(log_buf);
 447   4                              }
 448   3      #endif  
 449   3                      
 450   3                              switch(statusPad){
 451   4                              
 452   4                                      case 1:{}break;
 453   4                                              
 454   4                                      case 2:{}break;
 455   4                                              
 456   4                                      case 4:{}break;
 457   4                                              
 458   4                                      default:{}break;
 459   4                              }
 460   3                              
 461   3                      }break;
 462   2                              
 463   2                      default:{}break;
 464   2              }
 465   1      }
 466          
 467          void touchPad_functionTrigContinue(u8 statusPad, u8 loopCount){ //触摸连按触发
 468   1              
 469   1              EACHCTRL_realesFLG = statusPad; //最后一次连按触发互控同步
 470   1              devActionPush_IF.push_IF = 1; //最后一次连按触发推送使能
 471   1              
 472   1      #if(DEBUG_LOGOUT_EN == 1)                               
 473   1              { //输出打印，谨记 用后注释，否则占用大量代码空间
 474   2                      u8 xdata log_buf[64];
 475   2                      
 476   2                      sprintf(log_buf, "touchPad:%02X, %02Xtime pressOver.\n", (int)statusPad, (int)loopCount);
 477   2                      PrintString1_logOut(log_buf);
 478   2              }
 479   1      #endif  
 480   1      
 481   1              switch(statusPad){
 482   2              
 483   2                      case 1:{
 484   3                      
 485   3                              switch(loopCount){
C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 9   

 486   4                              
 487   4                                      case 3:{
 488   5                                      
 489   5                                      }break;
 490   4                                      
 491   4                                      case 4:{
 492   5                                      
 493   5                                              usrZigbNwkOpen(); //网络开放
 494   5                                              
 495   5                                      }break;
 496   4                                              
 497   4                                      default:{}break;
 498   4                              }
 499   3                              
 500   3                      }break;
 501   2                              
 502   2                      case 2:{
 503   3                      
 504   3                              switch(loopCount){
 505   4                              
 506   4                                      case 3:{}break;
 507   4                                              
 508   4                                      default:{}break;
 509   4                              }
 510   3                              
 511   3                      }break;
 512   2                              
 513   2                      case 4:{
 514   3                      
 515   3                              switch(loopCount){
 516   4                              
 517   4                                      case 3:{}break;
 518   4                                              
 519   4                                      case 4:{
 520   5                                      
 521   5                                              devHoldStop_makeInAdvance(); //设备网络挂起停止
 522   5                                      
 523   5                                      }break;
 524   4                                              
 525   4                                      default:{}break;
 526   4                              }
 527   3                              
 528   3                      }break;
 529   2                              
 530   2                      default:{}break;
 531   2              }
 532   1      }
 533          
 534          void fun_Test(void){
 535   1      
 536   1              ;
 537   1      }
 538          
 539          void usrKeyFun_zigbNwkRejoin(void){
 540   1      
 541   1              devStatus_switch.statusChange_standBy = status_nwkREQ;
 542   1              devStatus_switch.statusChange_IF = 1;
 543   1              
 544   1              tips_statusChangeToZigbNwkFind(); //tips更新
 545   1      }


C51 COMPILER V9.54   USRKIN                                                                09/07/2018 18:15:39 PAGE 10  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1064    ----
   CONSTANT SIZE    =    164    ----
   XDATA SIZE       =      4     320
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      17
   IDATA SIZE       =      1    ----
   BIT SIZE         =      8       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
