C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE USRKIN
OBJECT MODULE PLACED IN .\Output\usrKin.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Sensor\usrKin.c OMF2 OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Usr;.\Usr_lib;.\st
                    -d_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\usrKin.lst) OBJECT(.\Output\usrKin.obj)

line level    source

   1          #include "usrKin.h"
   2          
   3          #include "driver_I2C_HXD019D.h"
   4          
   5          #include "Tips.h"
   6          #include "dataTrans.h"
   7          #include "dataManage.h"
   8          #include "Relay.h"
   9          #include "touchPad.h"
  10          #include "eeprom.h"
  11          
  12          #include "delay.h"
  13          #include "USART.h"
  14          
  15          #include "stdio.h"
  16          #include "string.h"
  17          
  18          //***************Tips变量引用区***************************/
  19          extern tips_Status devTips_status;
  20          
  21          /**********************本地文件变量定义区**********************/
  22          u8 idata  val_DcodeCfm                  = 0;  //拨码值
  23          bit               ledBackground_method  = 1;  //背景灯颜色方案 //为1时：开-绿 关-蓝   为0时：开-蓝 关-绿
  24          
  25          bit               usrKeyCount_EN                = 0;  //用户按键计数
  26          u16     idata usrKeyCount                       = 0;
  27          
  28          u16     xdata touchPadActCounter        = 0;  //触摸盘按键计时
  29          u16     xdata touchPadContinueCnt       = 0;  //触摸盘连按计时
  30          
  31          u8      xdata touchKeepCnt_record       = 1;  //连按正在进行时计数变量，连按必定从一开始，否则不叫连按
  32          
  33          u16 xdata combinationFunFLG_3S5S_cancel_counter  = 0;  //三短五短预触发标志_衔接时长取消计数，衔接时间过长
             -时，将预触发标志取消
  34          
  35          static param_combinationFunPreTrig idata param_combinationFunTrigger_3S1L = {0};
  36          static param_combinationFunPreTrig idata param_combinationFunTrigger_3S5S = {0};
  37          
  38          /*--------------------------------------------------------------------------------------------------------
             -----*/
  39          ///*按键回调函数缓存*///为减少代码冗余，此段弃用
  40          //static fun_KeyTrigger xdata funTrig_keyTouch_1 = {0}; //连按可用 
  41          //static fun_KeyTrigger xdata funTrig_keyTouch_2 = {0}; //连按可用
  42          //static fun_KeyTrigger xdata funTrig_keyTouch_3 = {0}; //连按可用
  43          //static fun_KeyTrigger xdata funTrig_keyButton  = {0}; //连按不可用
  44          
  45          static void touchPad_functionTrigNormal(u8 statusPad, keyCfrm_Type statusCfm);
  46          static void touchPad_functionTrigContinue(u8 statusPad, u8 loopCount);
  47          
  48          ///*按键触发回调函数注册*///为减少代码冗余，此函数弃用
  49          //void funKeyTrigger_register(funKey_Callback funTrigger, objKey key, trig_Method mTrig, u8 pressCnt_num){
             - //回调函数，按键对象，触发方式，连按次数（大于2且 触发方式为连按 有效）
  50          
  51          //      switch(key){
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 2   

  52          //      
  53          //              case kinObj_touch_1:{
  54          //              
  55          //                      switch(mTrig){
  56          //                      
  57          //                              case method_pressShort: funTrig_keyTouch_1.press_Short = funTrigger;break;
  58          //                              case method_pressCnt:   if(pressCnt_num >= 2)funTrig_keyTouch_1.press_Continue[pressCnt_num] = funTrig
             -ger;break;
  59          //                              case method_pressLong_A:funTrig_keyTouch_1.press_Long_A = funTrigger;break;
  60          //                              case method_pressLong_B:funTrig_keyTouch_1.press_Long_B = funTrigger;break;
  61          //                                      
  62          //                              default:break;
  63          //                      }
  64          //              }break;
  65          //                      
  66          //              case kinObj_touch_2:{
  67          //                      
  68          //                      switch(mTrig){
  69          //                      
  70          //                              case method_pressShort: funTrig_keyTouch_2.press_Short = funTrigger;break;
  71          //                              case method_pressCnt:   if(pressCnt_num >= 2)funTrig_keyTouch_2.press_Continue[pressCnt_num] = funTrig
             -ger;break;
  72          //                              case method_pressLong_A:funTrig_keyTouch_2.press_Long_A = funTrigger;break;
  73          //                              case method_pressLong_B:funTrig_keyTouch_2.press_Long_B = funTrigger;break;
  74          //                                      
  75          //                              default:break;
  76          //                      }
  77          //              }break;
  78          //                      
  79          //              case kinObj_touch_3:{
  80          //                      
  81          //                      switch(mTrig){
  82          //                      
  83          //                              case method_pressShort: funTrig_keyButton.press_Short = funTrigger;break;
  84          //                              case method_pressLong_A:funTrig_keyButton.press_Long_A = funTrigger;break;
  85          //                              case method_pressLong_B:funTrig_keyButton.press_Long_B = funTrigger;break;
  86          //                              
  87          //                              case method_pressCnt: //连按不可用
  88          //                              default:break;
  89          //                      }
  90          //              }break;
  91          //                      
  92          //              case kinObj_button:{
  93          //              
  94          //                      switch(mTrig){
  95          //                      
  96          //                              case method_pressShort: funTrig_keyTouch_3.press_Short = funTrigger;break;
  97          //                              case method_pressCnt:   if(pressCnt_num >= 2)funTrig_keyTouch_3.press_Continue[pressCnt_num] = funTrig
             -ger;break;
  98          //                              case method_pressLong_A:funTrig_keyTouch_3.press_Long_A = funTrigger;break;
  99          //                              case method_pressLong_B:funTrig_keyTouch_3.press_Long_B = funTrigger;break;
 100          //                                      
 101          //                              default:break;
 102          //                      }
 103          //              }break;
 104          //                      
 105          //              default:break;
 106          //      }
 107          //}
 108          
 109          void usrZigbNwkOpen(void){
 110   1              
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 3   

 111   1              if(devTips_nwkZigb != nwkZigb_outLine &&  //网关失联，通信异常，不允许开放
 112   1                 devRunning_Status != status_nwkREQ &&  //本身无网络不允许开放
 113   1                 devRunning_Status != status_nwkReconnect){  //本身无网络不允许开放
 114   2              
 115   2                      ZigB_nwkOpen(1, ZIGBNWK_OPNETIME_DEFAULT); //功能触发
 116   2                      tips_statusChangeToZigbNwkOpen(ZIGBNWK_OPNETIME_DEFAULT); //tips触发
 117   2      #if(DEBUG_LOGOUT_EN == 1)
                              { //输出打印，谨记 用后注释，否则占用大量代码空间
                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                      sprintf(log_buf, "touchPad special trig:nwkOpen:%02ds.\n", (int)ZIGBNWK_OPNETIME_DEFAULT);
                                      PrintString1_logOut(log_buf);
                              }                       
              #endif  
 124   2              }
 125   1      }
 126          
 127          void devTypeComfirm_byDcode(u8 valDcode){
 128   1              
 129   1              valDcode = valDcode;
 130   1      
 131   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      SWITCH_TYPE = SWITCH_TYPE_FANS;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      SWITCH_TYPE = SWITCH_TYPE_dIMMER;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      SWITCH_TYPE = SWITCH_TYPE_SOCKETS;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      SWITCH_TYPE = SWITCH_TYPE_SCENARIO;
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
                      SWITCH_TYPE = SWITCH_TYPE_INFRARED;     
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      switch(valDcode){
                      
                              case 1:{
                              
                                      heater_ActParam.touchAction_defineJustSwitch_IF = 1;
                              
                              }break;
              
                              default:{
                              
                                      heater_ActParam.touchAction_defineJustSwitch_IF = 0;
                              
                              }break;
                      }
              #else
 157   1              switch(valDcode){
 158   2              
 159   2                      case 0:{
 160   3                      
 161   3                              SWITCH_TYPE = SWITCH_TYPE_CURTAIN;      
 162   3                              
 163   3                      }break;
 164   2                              
 165   2                      case 1:{
 166   3                      
 167   3                              SWITCH_TYPE = SWITCH_TYPE_SWBIT1;       
 168   3      
 169   3                      }break;
 170   2                              
 171   2                      case 2:{
 172   3                      
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 4   

 173   3                              SWITCH_TYPE = SWITCH_TYPE_SWBIT2;       
 174   3      
 175   3                      }break;
 176   2                              
 177   2                      case 3:{
 178   3                              
 179   3                              SWITCH_TYPE = SWITCH_TYPE_SWBIT3;       
 180   3      
 181   3                      }break;
 182   2                              
 183   2                      default:break;
 184   2              }
 185   1      #endif
 186   1      }
 187          
 188          void usrKin_pinInit(void){
 189   1              
 190   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
                      P2M1 |= 0x10;
                      P2M0 &= ~(0x10);
              //      P2M1 &= ~(0x10);
              //      P2M0 &= ~(0x10);
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
                      P5M1 &= ~ 0x10;
                      P5M0 &= ~(0x10);
                      
              #else
 201   1              P1M1 &= ~(0xE0);
 202   1              P1M0 &= ~(0xE0);
 203   1      
 204   1              P0M1 &= ~(0x04);
 205   1              P0M0 &= ~(0x04);
 206   1              
 207   1              { //拨码预检测
 208   2              
 209   2                      u8 touchVal_temp = DcodeScan_oneShoot();
 210   2                      
 211   2                      if(touchVal_temp & Dcode_FLG_ifMemory)relayStatus_ifSave = statusSave_enable; //提前检测
 212   2                      devTypeComfirm_byDcode(Dcode_bitReserve(touchVal_temp));
 213   2              }
 214   1              
 215   1      #endif
 216   1      }
 217          
 218          bit UsrKEYScan_oneShoot(void){
 219   1      
 220   1              return Usr_key;
 221   1      }
 222          
 223          void UsrKEYScan(funKey_Callback funCB_Short, funKey_Callback funCB_LongA, funKey_Callback funCB_LongB){
 224   1              
 225   1              code    u16     keyCfrmLoop_Short       = 10,   //短按消抖时间,据大循环而定
 226   1                                      keyCfrmLoop_LongA       = 3000, //长按A时间,据大循环而定
 227   1                                      keyCfrmLoop_LongB       = 12000,//长按B时间,据大循环而定
 228   1                                      keyCfrmLoop_MAX         = 60000;//计时封顶
 229   1              
 230   1              static  bit LongA_FLG = 0;
 231   1              static  bit LongB_FLG = 0;
 232   1              
 233   1              static  bit keyPress_FLG = 0;
 234   1      
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 5   

 235   1              if(!UsrKEYScan_oneShoot()){             
 236   2                      
 237   2                      keyPress_FLG = 1;
 238   2                      
 239   2      //              tips_statusChangeToNormal();
 240   2              
 241   2                      if(!usrKeyCount_EN) usrKeyCount_EN= 1;  //计时
 242   2                      
 243   2                      if((usrKeyCount >= keyCfrmLoop_LongA) && (usrKeyCount <= keyCfrmLoop_LongB) && !LongA_FLG){
 244   3                      
 245   3                              funCB_LongA();
 246   3                              
 247   3                              LongA_FLG = 1;
 248   3                      }       
 249   2                      
 250   2                      if((usrKeyCount >= keyCfrmLoop_LongB) && (usrKeyCount <= keyCfrmLoop_MAX) && !LongB_FLG){
 251   3                      
 252   3                              funCB_LongB();
 253   3                              
 254   3                              LongB_FLG = 1;
 255   3                      }
 256   2                      
 257   2              }else{          
 258   2                      
 259   2                      usrKeyCount_EN = 0;
 260   2                      
 261   2                      if(keyPress_FLG){
 262   3                      
 263   3                              keyPress_FLG = 0;
 264   3                              
 265   3                              if(usrKeyCount < keyCfrmLoop_LongA && usrKeyCount > keyCfrmLoop_Short){
 266   4                              
 267   4      //                              static bit tipsFLG = 0;
 268   4      //                               
 269   4      //                              tipsFLG = !tipsFLG;
 270   4      //                              (tipsFLG)?(tipsLED_colorSet(obj_zigbNwk, 5, 0, 0)):(tipsLED_colorSet(obj_zigbNwk, 0, 5, 0));
 271   4                                      
 272   4                                      funCB_Short();
 273   4                              }
 274   3                              
 275   3                              usrKeyCount = 0;
 276   3                              LongA_FLG       = 0;
 277   3                              LongB_FLG       = 0;
 278   3                      }
 279   2              }
 280   1      }
 281          
 282          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS) //设备类型为插座时，没有触摸按键驱动和拨码驱动
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)  //设备类型为红外转发器时，没有触摸按键驱动和拨码驱动
              #else //除上述开关类型外，有触摸按键驱动和拨码驱动
 285          u8 DcodeScan_oneShoot(void){
 286   1      
 287   1              u8 val_Dcode = 0;
 288   1              
 289   1              if(!Dcode0)val_Dcode |= 1 << 0;
 290   1              else val_Dcode &= ~(1 << 0);
 291   1              
 292   1              if(!Dcode1)val_Dcode |= 1 << 1;
 293   1              else val_Dcode &= ~(1 << 1);
 294   1              
 295   1              if(!Dcode2)val_Dcode |= 1 << 2;
 296   1              else val_Dcode &= ~(1 << 2);
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 6   

 297   1              
 298   1              if(!Dcode3)val_Dcode |= 1 << 3;
 299   1              else val_Dcode &= ~(1 << 3);
 300   1              
 301   1              if(!Dcode4)val_Dcode |= 1 << 4;
 302   1              else val_Dcode &= ~(1 << 4);
 303   1              
 304   1              if(!Dcode5)val_Dcode |= 1 << 5;
 305   1              else val_Dcode &= ~(1 << 5);
 306   1              
 307   1              return val_Dcode;
 308   1      }
 309          
 310          void DcodeScan(void){
 311   1      
 312   1              static u8       val_Dcode_Local         = 0,
 313   1                                      comfirm_Cnt                     = 0;
 314   1              const  u8       comfirm_Period          = 200;  //消抖时间因数――取决于主线程调度周期
 315   1                      
 316   1                         u8   val_Dcode_differ        = 0;
 317   1              
 318   1                         bit  val_CHG                         = 0;
 319   1              
 320   1              val_DcodeCfm = DcodeScan_oneShoot();
 321   1              
 322   1              DEV_actReserve = switchTypeReserve_GET(); //当前开关类型对应有效操作位刷新
 323   1              
 324   1              if(val_Dcode_Local != val_DcodeCfm){
 325   2              
 326   2                      if(comfirm_Cnt < comfirm_Period)comfirm_Cnt ++;
 327   2                      else{
 328   3                      
 329   3                              comfirm_Cnt = 0;
 330   3                              val_CHG         = 1;
 331   3                      }
 332   2              }
 333   1              
 334   1              if(val_CHG){
 335   2                      
 336   2                      val_CHG                         = 0;
 337   2              
 338   2                      val_Dcode_differ        = val_Dcode_Local ^ val_DcodeCfm;
 339   2                      val_Dcode_Local         = val_DcodeCfm;
 340   2                      
 341   2                      beeps_usrActive(3, 40, 2);
 342   2                      tips_statusChangeToNormal();
 343   2                      
 344   2                      if(val_Dcode_differ & Dcode_FLG_ifAP){
 345   3                      
 346   3                              if(val_Dcode_Local & Dcode_FLG_ifAP){
 347   4                              
 348   4      
 349   4                              }else{
 350   4                              
 351   4      
 352   4                              }
 353   3                      }
 354   2                      
 355   2                      if(val_Dcode_differ & Dcode_FLG_ifLED){
 356   3                      
 357   3                              if(val_Dcode_Local & Dcode_FLG_ifLED){
 358   4      
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 7   

 359   4                                      
 360   4                              }else{
 361   4                              
 362   4      
 363   4                              }
 364   3                      }
 365   2                      
 366   2                      if(val_Dcode_differ & Dcode_FLG_ifMemory){
 367   3                      
 368   3                              if(val_Dcode_Local & Dcode_FLG_ifMemory){
 369   4      
 370   4                                      relayStatus_ifSave = statusSave_enable;
 371   4                                      
 372   4                              }else{
 373   4                              
 374   4                                      relayStatus_ifSave = statusSave_disable;
 375   4                              }
 376   3                      }
 377   2                      
 378   2                      if(val_Dcode_differ & Dcode_FLG_bitReserve){
 379   3                      
 380   3                              devTypeComfirm_byDcode(Dcode_bitReserve(val_Dcode_Local));
 381   3                      }
 382   2              }
 383   1      }
 384          
 385          static void normalBussiness_longA_touchKeepTrig(u8 statusPad){
 386   1      
 387   1              static u8 xdata trigCount_Loop = 0;
 388   1                         u8 code trigCount_Period = 30;
 389   1              
 390   1              if(trigCount_Loop < trigCount_Period)trigCount_Loop ++;
 391   1              else{
 392   2              
 393   2                      trigCount_Loop = 0;
 394   2                      
 395   2      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)         
                              switch(statusPad){
                                      
                                      case 1:{
                                              
                                              (status_Relay < 100)?(swCommand_fromUsr.objRelay = ++status_Relay):(swCommand_fromUsr.objRelay = 100);
                                      
                                      }break;
                                      
                                      case 4:{
                              
                                              if(status_Relay > 0)swCommand_fromUsr.objRelay = --status_Relay;
                                              
                                      }break;
                                              
                                      default:{}break;
                              }
                              
                              swCommand_fromUsr.actMethod = relay_OnOff;
                              
              //#elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)               
              //#elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)            
              #else
 418   2                      statusPad = statusPad;
 419   2      #endif
 420   2              }
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 8   

 421   1      }
 422          
 423          u8 touchPadScan_oneShoot(void){
 424   1      
 425   1              u8 valKey_Temp = 0;
 426   1              
 427   1              if(!touchPad_1)valKey_Temp |= 0x01;
 428   1              if(!touchPad_2)valKey_Temp |= 0x02;
 429   1              if(!touchPad_3)valKey_Temp |= 0x04;
 430   1              
 431   1              return valKey_Temp;
 432   1      }
 433          
 434          void touchPad_Scan(void){
 435   1      
 436   1              static u8 touchPad_temp = 0;
 437   1              static bit keyPress_FLG = 0;
 438   1              
 439   1              static bit funTrigFLG_LongA = 0;
 440   1              static bit funTrigFLG_LongB = 0;
 441   1              
 442   1              code    u16     touchCfrmLoop_Short     = timeDef_touchPressCfm,        //短按消抖时间
 443   1                                      touchCfrmLoop_LongA     = timeDef_touchPressLongA,      //长按A时间
 444   1                                      touchCfrmLoop_LongB     = timeDef_touchPressLongB,      //长按B时间
 445   1                                      touchCfrmLoop_MAX               = 60000;//计时封顶
 446   1              
 447   1              static u8 pressContinueGet = 0;
 448   1                     u8 pressContinueCfm = 0;
 449   1              
 450   1              u16 conterTemp = 0; //按下计时差值计算缓存
 451   1              
 452   1              if(!combinationFunFLG_3S5S_cancel_counter)memset(&param_combinationFunTrigger_3S5S, 0, sizeof(param_combi
             -nationFunPreTrig)); //<3短5短>特殊组合按键衔接时间超时检测业务，超时则将对应标志复位、参数清空
 453   1              
 454   1              if(touchPadScan_oneShoot()){
 455   2                      
 456   2                      if(!keyPress_FLG){
 457   3                      
 458   3                              keyPress_FLG = 1;
 459   3                              touchPadActCounter = touchCfrmLoop_MAX;
 460   3                              touchPadContinueCnt = timeDef_touchPressContinue;  //连按间隔判断时间
 461   3                              touchPad_temp = touchPadScan_oneShoot();
 462   3                      }
 463   2                      else{
 464   3                              
 465   3                              if(touchPad_temp == touchPadScan_oneShoot()){ //等值核对
 466   4                                      
 467   4                                      conterTemp = touchCfrmLoop_MAX - touchPadActCounter;
 468   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 469   4      //                              
 470   4      //                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 471   4      //                                      sprintf(log_buf, "conut:%d.\n", (int)conterTemp);
 472   4      //                                      PrintString1_logOut(log_buf);
 473   4      //                              }
 474   4                                      
 475   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 476   4      //                              
 477   4      //                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 478   4      //                                      sprintf(log_buf, "current kVal:%d.\n", (int)touchPad_temp);
 479   4      //                                      PrintString1_logOut(log_buf);
 480   4      //                              }
 481   4                              
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 9   

 482   4                                      if(conterTemp > touchCfrmLoop_LongA && conterTemp <= touchCfrmLoop_LongB){
 483   5                                      
 484   5                                              normalBussiness_longA_touchKeepTrig(touchPad_temp); //持续性触发业务
 485   5                                              
 486   5                                              if(!funTrigFLG_LongA){
 487   6                                              
 488   6                                                      funTrigFLG_LongA = 1;
 489   6                                                      touchPad_functionTrigNormal(touchPad_temp, press_LongA);
 490   6                                              }
 491   5                                      }
 492   4                                      if(conterTemp > touchCfrmLoop_LongB && conterTemp <= touchCfrmLoop_MAX){
 493   5                                      
 494   5                                              if(!funTrigFLG_LongB){
 495   6                                              
 496   6                                                      funTrigFLG_LongB = 1;
 497   6                                                      touchPad_functionTrigNormal(touchPad_temp, press_LongB);
 498   6                                              }
 499   5                                      }
 500   4                                      
 501   4                              }else{
 502   4                                      
 503   4                                      if((touchCfrmLoop_MAX - touchPadActCounter) < touchCfrmLoop_Short){ //短按消抖时间内随时可做键值变更，
             -否则禁止
 504   5                                      
 505   5                                              touchPadActCounter = touchCfrmLoop_MAX;
 506   5                                              touchPadContinueCnt = timeDef_touchPressContinue;  //连按间隔判断时间
 507   5                                              touchPad_temp = touchPadScan_oneShoot();
 508   5                                      }
 509   4                              }
 510   3                      }
 511   2                      
 512   2              }else{
 513   2                      
 514   2                      if(keyPress_FLG){
 515   3                      
 516   3                              conterTemp = touchCfrmLoop_MAX - touchPadActCounter;
 517   3                              if(conterTemp > touchCfrmLoop_Short && conterTemp <= touchCfrmLoop_LongA){
 518   4                              
 519   4                                      if(touchPadContinueCnt)pressContinueGet ++;
 520   4                                      if(pressContinueGet <= 1)touchPad_functionTrigNormal(touchPad_temp, press_Short); //非连按短按触发互控
             -同步，若为连按则最后一次触发同步
 521   4                                      else touchPad_functionTrigNormal(touchPad_temp, press_ShortCnt);
 522   4                              }
 523   3                      }
 524   2              
 525   2                      if(!touchPadContinueCnt && pressContinueGet){
 526   3                      
 527   3                              pressContinueCfm = pressContinueGet;
 528   3                              pressContinueGet = 0;
 529   3                              
 530   3                              if(pressContinueCfm >= 2){
 531   4      //#if(DEBUG_LOGOUT_EN == 1)
 532   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 533   4      //                              
 534   4      //                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 535   4      //                                      sprintf(log_buf, "conut:%d.\n", (int)pressContinueCfm);
 536   4      //                                      PrintString1_logOut(log_buf);
 537   4      //                              }                       
 538   4      //#endif
 539   4                                      touchPad_functionTrigContinue(touchPad_temp, pressContinueCfm);
 540   4                                      pressContinueCfm = 0;
 541   4                              }
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 10  

 542   3                              
 543   3                              touchPad_temp = 0;
 544   3                      }
 545   2      
 546   2                      if(funTrigFLG_LongA){
 547   3                      
 548   3                              funTrigFLG_LongA = 0;
 549   3                              
 550   3      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                                              
                                      statusRelay_saveEn = 1; //存储使能，连续调光弹起后进行存储，调光类型不进行自动存储，所以进行主动存储
                                      EACHCTRL_realesFLG = 1; //有效互控触发
                                      
              //#elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
              //#elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              //#else
              #endif
 559   3                      }
 560   2                      
 561   2                      if(funTrigFLG_LongB){funTrigFLG_LongB = 0;}
 562   2                              
 563   2                      touchPadActCounter = 0;
 564   2                      keyPress_FLG = 0;
 565   2              }
 566   1      }       
 567          
 568          static void normalBussiness_shortTouchTrig(u8 statusPad, bit shortPressCnt_IF){
 569   1              
 570   1              bit idata tipsBeep_IF = 0;
 571   1              
 572   1      #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
                      
                      shortPressCnt_IF = shortPressCnt_IF; //去警告 ^.^
                      
                      switch(statusPad){
                              
                              case 1:{
                                      
                                      (status_Relay < 3)?(swCommand_fromUsr.objRelay = ++status_Relay):(swCommand_fromUsr.objRelay = 3);
                              
                              }break;
                              
                              case 2:{
                              
                                      (status_Relay)?(swCommand_fromUsr.objRelay = 0):(swCommand_fromUsr.objRelay = 3);
                                              
                              }break;
                              
                              case 4:{
                      
                                      if(status_Relay > 0)swCommand_fromUsr.objRelay = --status_Relay;
                                      
                              }break;
                                      
                              default:{}break;
                      }
                      
               #if(DEBUG_LOGOUT_EN == 1)
                      { //输出打印，谨记 用后注释，否则占用大量代码空间
                              
                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                              sprintf(log_buf, ">>>relayStatus sby:%d.\n", (int)swCommand_fromUsr.objRelay);
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 11  

                              PrintString1_logOut(log_buf);
                      }                       
               #endif
                      
                      swCommand_fromUsr.actMethod = relay_OnOff;
                      devActionPush_IF.push_IF = 1; //推送使能
                      tipsBeep_IF = 1;
                      if(tipsBeep_IF)beeps_usrActive(3, 50, 1); //触摸可用才tips
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
                      switch(statusPad){
                              
                              case 1:{
                                      
                                      (status_Relay < 100)?(swCommand_fromUsr.objRelay = status_Relay + 5):(swCommand_fromUsr.objRelay = 100)
             -;
                              
                              }break;
                              
                              case 2:{
                              
                                      (status_Relay)?(swCommand_fromUsr.objRelay = 0):(swCommand_fromUsr.objRelay = 100);
                                              
                              }break;
                              
                              case 4:{
                      
                                      if(status_Relay > 0){
                                      
                                              (status_Relay >= 5)?(swCommand_fromUsr.objRelay = status_Relay - 5):(swCommand_fromUsr.objRelay = 0);
                                      }
                                      
                              }break;
                                      
                              default:{}break;
                      }
                      
              //      if(!shortPressCnt_IF)EACHCTRL_realesFLG = 1; //有效互控触发（非连按才触发互控）
                      shortPressCnt_IF = shortPressCnt_IF; //去警告 ^.^
                      EACHCTRL_realesFLG = 1; //有效互控触发（互控方式已改变，可以进行连续触发）
                      
               #if(DEBUG_LOGOUT_EN == 1)
                      { //输出打印，谨记 用后注释，否则占用大量代码空间
                              
                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                              sprintf(log_buf, ">>>relayStatus sby:%d.\n", (int)swCommand_fromUsr.objRelay);
                              PrintString1_logOut(log_buf);
                      }                       
               #endif
                      
                      swCommand_fromUsr.actMethod = relay_OnOff;
                      statusRelay_saveEn = 1; //存储使能，调光类型不进行自动存储，所以进行主动存储
                      devActionPush_IF.push_IF = 1; //推送使能
                      tipsBeep_IF = 1;
                      if(tipsBeep_IF)beeps_usrActive(3, 50, 1); //触摸可用才tips
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
                      
                      shortPressCnt_IF = shortPressCnt_IF; //去警告 ^.^
                      
                      switch(statusPad){
                      
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 12  

                              case 1:
                              case 2:
                              case 4:{
                              
                                      swCommand_fromUsr.objRelay = statusPad;
                                      swCommand_fromUsr.actMethod = relay_OnOff;
                                      tipsBeep_IF = 1;
                              
                              }break;
                                      
                              default:{};
                      }
                      
                      devActionPush_IF.push_IF = 1; //推送使能
                      tipsBeep_IF = 1;
                      if(tipsBeep_IF)beeps_usrActive(3, 50, 1); //触摸可用才tips
                      
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
                      
                      shortPressCnt_IF = shortPressCnt_IF; //去警告 ^.^
                      
                      switch(statusPad){
                      
                              case 2:{ //和一位开关一样，中间按键才有效
                              
                                      if(heater_ActParam.touchAction_defineJustSwitch_IF){
                                      
                                              (heaterActMode_swClose == heater_ActParam.heater_currentActMode)?(heater_ActParam.heater_currentActMod
             -e = heaterActMode_swKeepOpen):(heater_ActParam.heater_currentActMode = heaterActMode_swClose); //一位开关，逻辑直接开关
                                      
                                      }else{
                                      
                                              (heaterActMode_swCloseDelay60min == heater_ActParam.heater_currentActMode)?(heater_ActParam.heater_cur
             -rentActMode = heaterActMode_swClose):(heater_ActParam.heater_currentActMode ++); //热水器开关，逻辑模式循环
                                      }
                                      
                                      devHeater_actOpeartionExecute(heater_ActParam.heater_currentActMode);
                                      
                                      tipsBeep_IF = 1;
                                      devActionPush_IF.push_IF = 1; //推送使能
                                      if(tipsBeep_IF)beeps_usrActive(3, 50, 1);
                              
                              }break;
                              
                              default:{}break;
                      }
                      
              #else
 711   1              switch(statusPad){
 712   2                      
 713   2                      case 1:{
 714   3                              
 715   3                              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1){
 716   4                              
 717   4                                      swCommand_fromUsr.objRelay = 0;
 718   4                              }
 719   3                              else if(SWITCH_TYPE == SWITCH_TYPE_CURTAIN){
 720   4                              
 721   4                              #if(CURTAIN_RELAY_UPSIDE_DOWN)
 722   4                                      swCommand_fromUsr.objRelay = 1;
 723   4                              #else
                                              swCommand_fromUsr.objRelay = 4;
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 13  

                                      #endif
 726   4                                      
 727   4                              }
 728   3                              else if(SWITCH_TYPE == SWITCH_TYPE_FANS){
 729   4                              
 730   4                                      if(status_Relay < 3)swCommand_fromUsr.objRelay ++;
 731   4                              }
 732   3                              else{
 733   4                              
 734   4                                      swCommand_fromUsr.objRelay = statusPad;
 735   4                              }
 736   3                              
 737   3                              if(DEV_actReserve & 0x01)tipsBeep_IF = 1;
 738   3                      
 739   3                      }break;
 740   2                      
 741   2                      case 2:{
 742   3                      
 743   3                              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1){
 744   4                              
 745   4                                      swCommand_fromUsr.objRelay = 1;
 746   4                              }
 747   3                              else if(SWITCH_TYPE == SWITCH_TYPE_SWBIT2){
 748   4                              
 749   4                                      swCommand_fromUsr.objRelay = 0;
 750   4                              }
 751   3                              else if(SWITCH_TYPE == SWITCH_TYPE_CURTAIN){
 752   4                              
 753   4                                      swCommand_fromUsr.objRelay = 2;
 754   4                              }
 755   3                              else if(SWITCH_TYPE == SWITCH_TYPE_FANS){
 756   4                              
 757   4                                      (status_Relay)?(swCommand_fromUsr.objRelay = 0):(swCommand_fromUsr.objRelay = 3);
 758   4                              }
 759   3                              else{
 760   4                              
 761   4                                      swCommand_fromUsr.objRelay = statusPad;
 762   4                              }
 763   3                              
 764   3                              if(DEV_actReserve & 0x02)tipsBeep_IF = 1;
 765   3                      
 766   3                      }break;
 767   2                      
 768   2                      case 4:{
 769   3              
 770   3                              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT2){
 771   4                                      
 772   4                                      swCommand_fromUsr.objRelay = 2;
 773   4                              }
 774   3                              else if(SWITCH_TYPE == SWITCH_TYPE_CURTAIN){
 775   4                              
 776   4                              #if(CURTAIN_RELAY_UPSIDE_DOWN)
 777   4                                      swCommand_fromUsr.objRelay = 4;
 778   4                              #else
                                              swCommand_fromUsr.objRelay = 1;
                                      #endif
 781   4                              }
 782   3                              else if(SWITCH_TYPE == SWITCH_TYPE_FANS){
 783   4                              
 784   4                                      if(status_Relay > 0)swCommand_fromUsr.objRelay --;
 785   4                              }
 786   3                              else{
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 14  

 787   4                              
 788   4                                      swCommand_fromUsr.objRelay = statusPad;
 789   4                              }
 790   3                              
 791   3                              if(DEV_actReserve & 0x04)tipsBeep_IF = 1;
 792   3                              
 793   3                      }break;
 794   2                              
 795   2                      default:{
 796   3                      
 797   3                              switch(SWITCH_TYPE){ //针对多位开关，多个按键可同时触发
 798   4                              
 799   4                                      case SWITCH_TYPE_SWBIT1:{
 800   5                                      
 801   5                                              if(statusPad & 0x02)swCommand_fromUsr.objRelay |= 0x01;
 802   5                                              if(DEV_actReserve & 0x02)tipsBeep_IF = 1;
 803   5                                              
 804   5                                      }break;
 805   4                                              
 806   4                                      case SWITCH_TYPE_SWBIT2:{
 807   5                                      
 808   5                                              if(statusPad & 0x01)swCommand_fromUsr.objRelay |= 0x01;
 809   5                                              if(statusPad & 0x04)swCommand_fromUsr.objRelay |= 0x02;
 810   5                                              
 811   5                                              if(DEV_actReserve & 0x05)tipsBeep_IF = 1;
 812   5                                              
 813   5                                      }break;
 814   4                                              
 815   4                                      case SWITCH_TYPE_SWBIT3:{
 816   5                                      
 817   5                                              if(statusPad & 0x01)swCommand_fromUsr.objRelay |= 0x01;
 818   5                                              if(statusPad & 0x02)swCommand_fromUsr.objRelay |= 0x02;
 819   5                                              if(statusPad & 0x04)swCommand_fromUsr.objRelay |= 0x04;
 820   5                                              
 821   5                                              if(DEV_actReserve & 0x07)tipsBeep_IF = 1;
 822   5                                              
 823   5                                      }break;
 824   4                                              
 825   4                                      default:{
 826   5                                      
 827   5                                              return; //其他开关不支持多位按键同时触发，若有多位按键同时触发则判定为误操作，动作不执行
 828   5                                      
 829   5                                      }break;
 830   4                              }
 831   3                      
 832   3                      }break;
 833   2              }
 834   1              
 835   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1 || SWITCH_TYPE == SWITCH_TYPE_SWBIT2 || SWITCH_TYPE == SWITCH_TYPE_S
             -WBIT3){
 836   2              
 837   2                      swCommand_fromUsr.actMethod = relay_flip;
 838   2                      
 839   2              }else{
 840   2               
 841   2                      swCommand_fromUsr.actMethod = relay_OnOff;
 842   2              }
 843   1              
 844   1      //      if(!shortPressCnt_IF){ //非连按才触发互控
 845   1      //      
 846   1      //              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1 || SWITCH_TYPE == SWITCH_TYPE_SWBIT2 || SWITCH_TYPE == SWITCH_TYP
             -E_SWBIT3)EACHCTRL_realesFLG = swCommand_fromUsr.objRelay; //有效互控触发(直接触发触摸对应键互控)
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 15  

 847   1      //              else
 848   1      //              if(SWITCH_TYPE == SWITCH_TYPE_CURTAIN)EACHCTRL_realesFLG = 1; //有效互控触发
 849   1      //      }
 850   1              
 851   1              //有效互控触发（互控方式已改变，可以进行连续触发）
 852   1              shortPressCnt_IF = shortPressCnt_IF; //去警告 ^.^
 853   1              if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1 || SWITCH_TYPE == SWITCH_TYPE_SWBIT2 || SWITCH_TYPE == SWITCH_TYPE_S
             -WBIT3)EACHCTRL_realesFLG = swCommand_fromUsr.objRelay; 
 854   1              else
 855   1              if(SWITCH_TYPE == SWITCH_TYPE_CURTAIN)EACHCTRL_realesFLG = 1; 
 856   1              
 857   1              if(swCommand_fromUsr.objRelay)devActionPush_IF.push_IF = 1; //推送使能
 858   1              if(tipsBeep_IF)beeps_usrActive(3, 50, 1); //触摸可用才tips
 859   1      #endif
 860   1      }
 861          
 862          void touchPad_functionTrigNormal(u8 statusPad, keyCfrm_Type statusCfm){ //普通触摸触发
 863   1      
 864   1              switch(statusCfm){
 865   2              
 866   2                      case press_Short:{
 867   3                              
 868   3                              bit idata tipsBeep_IF = 0;
 869   3                              
 870   3      #if(DEBUG_LOGOUT_EN == 1)                               
                                      { //输出打印，谨记 用后注释，否则占用大量代码空间
                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                              sprintf(log_buf, "touchPad:%02X, shortPress.\n", (int)statusPad);
                                              PrintString1_logOut(log_buf);
                                      }
              #endif  
 877   3                              normalBussiness_shortTouchTrig(statusPad, 0); //普通短按业务触发
 878   3                              
 879   3                      }break;
 880   2                      
 881   2                      case press_ShortCnt:{
 882   3                              
 883   3      #if(DEBUG_LOGOUT_EN == 1)                               
                                      { //输出打印，谨记 用后注释，否则占用大量代码空间
                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                              sprintf(log_buf, "touchPad:%02X, cntPress.\n", (int)statusPad);
                                              PrintString1_logOut(log_buf);
                                      }
              #endif  
 890   3                              touchKeepCnt_record ++; //连按进行时计数变量更新
 891   3                              
 892   3                              if(touchKeepCnt_record == 3){
 893   4                              
 894   4                                      param_combinationFunTrigger_3S1L.param_combinationFunPreTrig_standBy_FLG = 1; //特殊组合动作预触发<3短
             -1长>
 895   4                                      param_combinationFunTrigger_3S1L.param_combinationFunPreTrig_standBy_keyVal = statusPad; //特殊组合动
             -髟ごシ⒍员燃值更新<3短1长>
 896   4                                      
 897   4                              }else{
 898   4                              
 899   4                                      memset(&param_combinationFunTrigger_3S1L, 0, sizeof(param_combinationFunPreTrig)); //标志复位、参数清
             -<3短1长>
 900   4                              } 
 901   3                              
 902   3                              normalBussiness_shortTouchTrig(statusPad, 1); //连按短按业务触发
 903   3                              
 904   3                      }break;
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 16  

 905   2                      
 906   2                      case press_LongA:{
 907   3                              
 908   3                              if(param_combinationFunTrigger_3S1L.param_combinationFunPreTrig_standBy_FLG && (statusPad == param_comb
             -inationFunTrigger_3S1L.param_combinationFunPreTrig_standBy_keyVal)){ //特殊组合按键动作业务触发<3短1长>
 909   4                              
 910   4                                      memset(&param_combinationFunTrigger_3S1L, 0, sizeof(param_combinationFunPreTrig)); //标志复位、参数清
             -
 911   4                                      
 912   4                                      usrKeyFun_zigbNwkRejoin();
 913   4                                      
 914   4      #if(DEBUG_LOGOUT_EN == 1)                               
                                              { //输出打印，谨记 用后注释，否则占用大量代码空间
                                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                                      sprintf(log_buf, "combination fun<3S1L> trig!\n");
                                                      PrintString1_logOut(log_buf);
                                              }
              #endif  
 921   4                              }else{  //禁止 特殊组合动作触发 与 结束动作（长按） 产生触发重叠
 922   4                                      
 923   4      #if(DEBUG_LOGOUT_EN == 1)                               
                                              { //输出打印，谨记 用后注释，否则占用大量代码空间
                                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                                      sprintf(log_buf, "touchPad:%02X, longPress_A.\n", (int)statusPad);
                                                      PrintString1_logOut(log_buf);
                                              }
              #endif  
 930   4                                      switch(statusPad){ //若不是特殊组合动作，则进行实际长按触发
 931   5                                      
 932   5                                              case 1:{
 933   6                                                      
 934   6                                              
 935   6                                              }break;
 936   5                                                      
 937   5                                              case 2:{
 938   6                                              
 939   6                                              
 940   6                                              }break;
 941   5                                                      
 942   5                                              case 4:{
 943   6                                                      
 944   6                                              
 945   6                                              }break;
 946   5                                                      
 947   5                                              default:{}break;
 948   5                                      }
 949   4                              }
 950   3                      
 951   3                      }break;
 952   2                              
 953   2                      case press_LongB:{
 954   3                              
 955   3      #if(DEBUG_LOGOUT_EN == 1)                               
                                      { //输出打印，谨记 用后注释，否则占用大量代码空间
                                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                              sprintf(log_buf, "touchPad:%02X, longPress_B.\n", (int)statusPad);
                                              PrintString1_logOut(log_buf);
                                      }
              #endif  
 962   3                              devStatusChangeTo_devHold(1); //设备网络挂起，任意键长按B
 963   3                      
 964   3                              switch(statusPad){
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 17  

 965   4                              
 966   4                                      case 1:{}break;
 967   4                                              
 968   4                                      case 2:{}break;
 969   4                                              
 970   4                                      case 4:{}break;
 971   4                                              
 972   4                                      default:{}break;
 973   4                              }
 974   3                              
 975   3                      }break;
 976   2                              
 977   2                      default:{}break;
 978   2              }
 979   1              
 980   1              { //特殊动作组合键相关标志及变量清空
 981   2              
 982   2                      if(statusCfm != press_ShortCnt){
 983   3      
 984   3                              touchKeepCnt_record = 1; //连按进行时计数变量复原
 985   3                              memset(&param_combinationFunTrigger_3S1L, 0, sizeof(param_combinationFunPreTrig)); //特殊组合动作预触发
             -标志复位、参数清空<3短1长>
 986   3                              
 987   3                              if(statusCfm != press_Short)memset(&param_combinationFunTrigger_3S5S, 0, sizeof(param_combinationFunPre
             -Trig)); //非短按及非连续短按，特殊组合动作标志复位、参数清空<3短5短>
 988   3                      }
 989   2              }
 990   1      }
 991          
 992          void touchPad_functionTrigContinue(u8 statusPad, u8 loopCount){ //触摸连按触发
 993   1              
 994   1              //（互控方式已改变，可以进行连续触发）
 995   1              
 996   1      //      if(SWITCH_TYPE == SWITCH_TYPE_SWBIT1 || SWITCH_TYPE == SWITCH_TYPE_SWBIT2 || SWITCH_TYPE == SWITCH_TYPE
             -_SWBIT3)EACHCTRL_realesFLG = swCommand_fromUsr.objRelay; //有效互控触发，最后一次连按触发互控同步
 997   1      //      else
 998   1      //      if(SWITCH_TYPE == SWITCH_TYPE_CURTAIN)EACHCTRL_realesFLG = 1; //有效互控触发，最后一次连按触发互控同步
 999   1              
1000   1              devActionPush_IF.push_IF = 1; //最后一次连按触发推送使能
1001   1              
1002   1      #if(DEBUG_LOGOUT_EN == 1)                               
                      { //输出打印，谨记 用后注释，否则占用大量代码空间
                              memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                              sprintf(log_buf, "touchPad:%02X, %02Xtime pressOver.\n", (int)statusPad, (int)loopCount);
                              PrintString1_logOut(log_buf);
                      }
              #endif  
1009   1              
1010   1              switch(loopCount){
1011   2              
1012   2                      case 2:{
1013   3                      
1014   3                              switch(statusPad){
1015   4                              
1016   4                                      case 1:{
1017   5                                      
1018   5                                              
1019   5                                      }break;
1020   4                                              
1021   4                                      case 2:{
1022   5                                      
1023   5                                              
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 18  

1024   5                                      }break;
1025   4                                              
1026   4                                      case 4:{
1027   5      
1028   5                                              
1029   5                                      }break;
1030   4                                              
1031   4                                      default:{}break;
1032   4                              }
1033   3                              
1034   3                      }break;
1035   2                      
1036   2                      case 3:{
1037   3                      
1038   3                              param_combinationFunTrigger_3S5S.param_combinationFunPreTrig_standBy_FLG = 1; //特殊组合动作预触发标志
             -梦<3短5短>
1039   3                              param_combinationFunTrigger_3S5S.param_combinationFunPreTrig_standBy_keyVal = statusPad;  //特殊组合动
             -髟ごシ⒍员燃值更新<3短5短>
1040   3                              combinationFunFLG_3S5S_cancel_counter = 3000;  //特殊组合动作预触发衔接时间计时开始<3短5短>
1041   3                              
1042   3                      }break;
1043   2                      
1044   2                      case 5:{
1045   3                      
1046   3                              if(param_combinationFunTrigger_3S5S.param_combinationFunPreTrig_standBy_FLG && (statusPad == param_comb
             -inationFunTrigger_3S5S.param_combinationFunPreTrig_standBy_keyVal)){ //特殊组合动作对应业务响应<3短5短>
1047   4                              
1048   4                                      memset(&param_combinationFunTrigger_3S5S, 0, sizeof(param_combinationFunPreTrig)); //标志复位、参数清
             -
1049   4                                      
1050   4                                      usrZigbNwkOpen(); //网络开放
1051   4                                      
1052   4      #if(DEBUG_LOGOUT_EN == 1)                               
                                              { //输出打印，谨记 用后注释，否则占用大量代码空间
                                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
                                                      sprintf(log_buf, "combination fun<3S5S> trig!\n");
                                                      PrintString1_logOut(log_buf);
                                              }
              #endif
1059   4                              }
1060   3                              
1061   3                      }break;
1062   2                      
1063   2                      case 6:{
1064   3                      
1065   3                      
1066   3                      }break;
1067   2                      
1068   2                      case 10:{
1069   3                      
1070   3                              devHoldStop_makeInAdvance(); //设备网络挂起停止
1071   3                      
1072   3                      }break;
1073   2                      
1074   2                      default:{}break;
1075   2              }
1076   1              
1077   1              { //特殊组合键相关标志及变量清空
1078   2              
1079   2                      touchKeepCnt_record = 1; //连按进行时计数变量复原
1080   2                      memset(&param_combinationFunTrigger_3S1L, 0, sizeof(param_combinationFunPreTrig)); //特殊组合动作预触发
             -曛靖次弧⒉问清空<3短1长>
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 19  

1081   2                      if(loopCount != 3){ //非3短
1082   3                      
1083   3                              memset(&param_combinationFunTrigger_3S5S, 0, sizeof(param_combinationFunPreTrig)); //标志复位、参数清空
             -<3短5短>
1084   3                      }
1085   2              }
1086   1      }
1087          
1088          #endif
1089          
1090          #if(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_FANS)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_dIMMER)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SOCKETS)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_INFRARED)
              void fun_Test(void){
              
                      
              }
              
              void fun_Test_short(void){
              
              //      static idata bit k_flg = 0;
              //      
              //      k_flg = !k_flg;
              //      
              //      infraredOpreatAct_Stop();
              //      (k_flg)?(infraredOpreatAct_learnningStart(3)):(infraredOpreatAct_remoteControlStart(3));
                      
                      infraredOpreatAct_Stop();
                      infraredOpreatAct_remoteControlStart(3);
              }
              
              void fun_Test_longA(void){
              
                      infraredOpreatAct_Stop();
                      infraredOpreatAct_learnningStart(3);
              }
              
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_SCENARIO)
              #elif(SWITCH_TYPE_FORCEDEF == SWITCH_TYPE_HEATER)
              void devHeater_actOpeartionExecute(enumDevHeater_ActMode opreatParam){
              
                      switch(opreatParam){
                      
                              case heaterActMode_swClose:{
                              
                                      swCommand_fromUsr.objRelay = 0;
                                      swCommand_fromUsr.actMethod = relay_OnOff;
                              
                              }break;
                                      
                              case heaterActMode_swKeepOpen:{
                              
                                      swCommand_fromUsr.objRelay = 1;
                                      swCommand_fromUsr.actMethod = relay_OnOff;
                                      
                              }break;
                                      
                              case heaterActMode_swCloseDelay30min:{
                              
                                      swCommand_fromUsr.objRelay = 1;
                                      swCommand_fromUsr.actMethod = relay_OnOff;
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 20  

                                      heater_ActParam.timerClose_counter = 60 * 30;
                              
                              }break;
                                      
                              case heaterActMode_swCloseDelay60min:{
                              
                                      swCommand_fromUsr.objRelay = 1;
                                      swCommand_fromUsr.actMethod = relay_OnOff;
                                      heater_ActParam.timerClose_counter = 60 * 60;
                              
                              }break;
                                      
                              default:{}break;
                      }
              }
              
              #else
1159          void fun_Test(void){
1160   1      
1161   1              
1162   1      }
1163          
1164          #endif
1165          
1166          void fun_touchReset(void){
1167   1      
1168   1              touchPad_resetOpreat(TOUCHRESETTIME_DEFAULT);
1169   1              tips_statusChangeToTouchReset(TOUCHRESETTIME_DEFAULT);
1170   1      }
1171          
1172          void usrKeyFun_relayOpreation(void){
1173   1      
1174   1              swCommand_fromUsr.objRelay = 1;
1175   1              swCommand_fromUsr.actMethod = relay_flip;
1176   1              
1177   1              devActionPush_IF.dats_Push = 0;
1178   1              devActionPush_IF.push_IF = 1;
1179   1              
1180   1              beeps_usrActive(3, 50, 1);
1181   1      }
1182          
1183          void usrKeyFun_zigbNwkRejoin(void){
1184   1              
1185   1              u8 deviceLock_IF = 0; //操作字节缓存
1186   1              
1187   1              //重新入网情况下，开关解锁
1188   1              deviceLock_flag = deviceLock_IF = 0; //运行缓存更新，解锁
1189   1              coverEEPROM_write_n(EEPROM_ADDR_deviceLockFLAG, &deviceLock_IF, 1); //直接更新eeprom数据，解锁
1190   1              
1191   1              if(countEN_ifTipsFree)countEN_ifTipsFree = 0; //触摸释放计时失能
1192   1      
1193   1              devStatus_switch.statusChange_standBy = status_nwkREQ;
1194   1              devStatus_switch.statusChange_IF = 1;
1195   1              
1196   1              statusSave_zigbNwk_nwkExistIF(0); //网络存在本地存储判断值更新为不存在
1197   1              
1198   1              tips_statusChangeToZigbNwkFind(); //tips更新
1199   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1564    ----
C51 COMPILER V9.54   USRKIN                                                                05/13/2019 08:24:11 PAGE 21  

   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      19
   IDATA SIZE       =      5    ----
   BIT SIZE         =     10       2
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
