C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE USRKIN
OBJECT MODULE PLACED IN .\Output\usrKin.obj
COMPILER INVOKED BY: E:\KEIL\MDK_5.18&C51_v9.54a\Software\C51\BIN\C51.EXE Sensor\usrKin.c OMF2 ROM(COMPACT) OPTIMIZE(8,S
                    -PEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\std_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\usrKin.
                    -lst) OBJECT(.\Output\usrKin.obj)

line level    source

   1          #include "usrKin.h"
   2          
   3          #include "Tips.h"
   4          #include "dataTrans.h"
   5          #include "dataManage.h"
   6          #include "Relay.h"
   7          
   8          #include "delay.h"
   9          #include "USART.h"
  10          
  11          #include "stdio.h"
  12          #include "string.h"
  13          
  14          /**********************本地文件变量定义区**********************/
  15          u8 idata val_DcodeCfm                   = 0;  //拨码值
  16          bit              ledBackground_method   = 1;  //背景灯颜色方案 //为1时：开-绿 关-蓝   为0时：开-蓝 关-绿
  17          
  18          bit              usrKeyCount_EN                 = 0;  //用户按键计数
  19          u16              usrKeyCount                    = 0;
  20          
  21          u16     xdata touchPadActCounter        = 0;  //触摸盘按键计时
  22          u16     xdata touchPadContinueCnt       = 0;  //触摸盘连按计时
  23          
  24          //***************Tips变量引用区***************************/
  25          extern tips_Status devTips_status;
  26          
  27          
  28          static void touchPad_functionTrigNormal(u8 statusPad, keyCfrm_Type statusCfm);
  29          static void touchPad_functionTrigContinue(u8 statusPad, u8 loopCount);
  30          
  31          void usrKin_pinInit(void){
  32   1      
  33   1              P1M1 &= ~(0xE0);
  34   1              P1M0 &= ~(0xE0);
  35   1      
  36   1              P0M1 &= ~(0x04);
  37   1              P0M0 &= ~(0x04);
  38   1              
  39   1              if(!Dcode2)relayStatus_ifSave = statusSave_enable;
  40   1      }
  41          
  42          u8 DcodeScan_oneShoot(void){
  43   1      
  44   1              u8 val_Dcode = 0;
  45   1              
  46   1              if(!Dcode0)val_Dcode |= 1 << 0;
  47   1              else val_Dcode &= ~(1 << 0);
  48   1              
  49   1              if(!Dcode1)val_Dcode |= 1 << 1;
  50   1              else val_Dcode &= ~(1 << 1);
  51   1              
  52   1              if(!Dcode2)val_Dcode |= 1 << 2;
  53   1              else val_Dcode &= ~(1 << 2);
C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 2   

  54   1              
  55   1              if(!Dcode3)val_Dcode |= 1 << 3;
  56   1              else val_Dcode &= ~(1 << 3);
  57   1              
  58   1              if(!Dcode4)val_Dcode |= 1 << 4;
  59   1              else val_Dcode &= ~(1 << 4);
  60   1              
  61   1              if(!Dcode5)val_Dcode |= 1 << 5;
  62   1              else val_Dcode &= ~(1 << 5);
  63   1              
  64   1              return val_Dcode;
  65   1      }
  66          
  67          bit UsrKEYScan_oneShoot(void){
  68   1      
  69   1              return Usr_key;
  70   1      }
  71          
  72          u8 touchPadScan_oneShoot(void){
  73   1      
  74   1              u8 valKey_Temp = 0;
  75   1              
  76   1              if(!touchPad_1)valKey_Temp |= 0x01;
  77   1              if(!touchPad_2)valKey_Temp |= 0x02;
  78   1              if(!touchPad_3)valKey_Temp |= 0x04;
  79   1              
  80   1              return valKey_Temp;
  81   1      }
  82          
  83          void DcodeScan(void){
  84   1      
  85   1              static u8       val_Dcode_Local         = 0,
  86   1                                      comfirm_Cnt                     = 0;
  87   1              const  u8       comfirm_Period          = 200;  //消抖时间因数――取决于主线程调度周期
  88   1                      
  89   1                         u8   val_Dcode_differ        = 0;
  90   1              
  91   1                         bit  val_CHG                         = 0;
  92   1              
  93   1              val_DcodeCfm = DcodeScan_oneShoot();
  94   1              
  95   1              DEV_actReserve = switchTypeReserve_GET(); //当前开关类型对应有效操作位刷新
  96   1              
  97   1              if(val_Dcode_Local != val_DcodeCfm){
  98   2              
  99   2                      if(comfirm_Cnt < comfirm_Period)comfirm_Cnt ++;
 100   2                      else{
 101   3                      
 102   3                              comfirm_Cnt = 0;
 103   3                              val_CHG         = 1;
 104   3                      }
 105   2              }
 106   1              
 107   1              if(val_CHG){
 108   2                      
 109   2                      val_CHG                         = 0;
 110   2              
 111   2                      val_Dcode_differ        = val_Dcode_Local ^ val_DcodeCfm;
 112   2                      val_Dcode_Local         = val_DcodeCfm;
 113   2      
 114   2                      if(val_Dcode_differ & Dcode_FLG_ifAP){
 115   3                      
C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 3   

 116   3                              if(val_Dcode_Local & Dcode_FLG_ifAP){
 117   4                              
 118   4      
 119   4                              }else{
 120   4                              
 121   4      
 122   4                              }
 123   3                      }
 124   2                      
 125   2                      if(val_Dcode_differ & Dcode_FLG_ifLED){
 126   3                      
 127   3                              if(val_Dcode_Local & Dcode_FLG_ifLED){
 128   4      
 129   4                                      
 130   4                              }else{
 131   4                              
 132   4      
 133   4                              }
 134   3                      }
 135   2                      
 136   2                      if(val_Dcode_differ & Dcode_FLG_ifMemory){
 137   3                      
 138   3                              if(val_Dcode_Local & Dcode_FLG_ifMemory){
 139   4      
 140   4                                      relayStatus_ifSave = statusSave_enable;
 141   4                                      
 142   4                              }else{
 143   4                              
 144   4                                      relayStatus_ifSave = statusSave_disable;
 145   4                              }
 146   3                      }
 147   2                      
 148   2                      if(val_Dcode_differ & Dcode_FLG_bitReserve){
 149   3                      
 150   3                              switch(Dcode_bitReserve(val_Dcode_Local)){
 151   4                              
 152   4                                      case 0:{
 153   5                                      
 154   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT3;       
 155   5                                              
 156   5                                      }break;
 157   4                                              
 158   4                                      case 1:{
 159   5                                      
 160   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT1;       
 161   5      
 162   5                                      }break;
 163   4                                              
 164   4                                      case 2:{
 165   5                                      
 166   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT2;       
 167   5      
 168   5                                      }break;
 169   4                                              
 170   4                                      case 3:{
 171   5                                              
 172   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT3;       
 173   5      
 174   5                                      }break;
 175   4                                              
 176   4                                      default:break;
 177   4                              }
C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 4   

 178   3                      }
 179   2              }
 180   1      }
 181          
 182          void UsrKEYScan(funKey_Callback funCB_Short, funKey_Callback funCB_LongA, funKey_Callback funCB_LongB){
 183   1              
 184   1              code    u16     keyCfrmLoop_Short       = 10,   //短按消抖时间,据大循环而定
 185   1                                      keyCfrmLoop_LongA       = 3000, //长按A时间,据大循环而定
 186   1                                      keyCfrmLoop_LongB       = 10000,//长按B时间,据大循环而定
 187   1                                      keyCfrmLoop_MAX         = 60000;//计时封顶
 188   1              
 189   1              static  bit LongA_FLG = 0;
 190   1              static  bit LongB_FLG = 0;
 191   1              
 192   1              static  bit keyPress_FLG = 0;
 193   1      
 194   1              if(!UsrKEYScan_oneShoot()){             
 195   2                      
 196   2                      keyPress_FLG = 1;
 197   2                      
 198   2      //              tips_statusChangeToNormal();
 199   2              
 200   2                      if(!usrKeyCount_EN) usrKeyCount_EN= 1;  //计时
 201   2                      
 202   2                      if((usrKeyCount >= keyCfrmLoop_LongA) && (usrKeyCount <= keyCfrmLoop_LongB) && !LongA_FLG){
 203   3                      
 204   3                              funCB_LongA();
 205   3                              
 206   3                              LongA_FLG = 1;
 207   3                      }       
 208   2                      
 209   2                      if((usrKeyCount >= keyCfrmLoop_LongB) && (usrKeyCount <= keyCfrmLoop_MAX) && !LongB_FLG){
 210   3                      
 211   3                              funCB_LongB();
 212   3                              
 213   3                              LongB_FLG = 1;
 214   3                      }
 215   2                      
 216   2              }else{          
 217   2                      
 218   2                      usrKeyCount_EN = 0;
 219   2                      
 220   2                      if(keyPress_FLG){
 221   3                      
 222   3                              keyPress_FLG = 0;
 223   3                              
 224   3                              if(usrKeyCount < keyCfrmLoop_LongA && usrKeyCount > keyCfrmLoop_Short){
 225   4                              
 226   4      //                              static bit tipsFLG = 0;
 227   4      //                               
 228   4      //                              tipsFLG = !tipsFLG;
 229   4      //                              (tipsFLG)?(tipsLED_colorSet(obj_zigbNwk, 5, 0, 0)):(tipsLED_colorSet(obj_zigbNwk, 0, 5, 0));
 230   4                                      
 231   4                                      funCB_Short();
 232   4                              }
 233   3                              
 234   3                              usrKeyCount = 0;
 235   3                              LongA_FLG       = 0;
 236   3                              LongB_FLG       = 0;
 237   3                      }
 238   2              }
 239   1      }
C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 5   

 240          
 241          void touchPad_Scan(void){
 242   1      
 243   1              static u8 touchPad_temp = 0;
 244   1              static bit keyPress_FLG = 0;
 245   1              
 246   1              static bit funTrigFLG_LongA = 0;
 247   1              static bit funTrigFLG_LongB = 0;
 248   1              
 249   1              code    u16     touchCfrmLoop_Short     = timeDef_touchPressCfm,        //短按消抖时间
 250   1                                      touchCfrmLoop_LongA     = timeDef_touchPressLongA,      //长按A时间
 251   1                                      touchCfrmLoop_LongB     = timeDef_touchPressLongB,      //长按B时间
 252   1                                      touchCfrmLoop_MAX               = 60000;//计时封顶
 253   1              
 254   1              static u8 pressContinueGet = 0;
 255   1                     u8 pressContinueCfm = 0;
 256   1              
 257   1              u16 conterTemp = 0; //按下计时差值计算缓存
 258   1              
 259   1              if(touchPadScan_oneShoot()){
 260   2                      
 261   2                      if(!keyPress_FLG){
 262   3                      
 263   3                              keyPress_FLG = 1;
 264   3                              touchPadActCounter = touchCfrmLoop_MAX;
 265   3                              touchPadContinueCnt = timeDef_touchPressContinue;  //连按间隔判断时间
 266   3                              touchPad_temp = touchPadScan_oneShoot();
 267   3                      }
 268   2                      else{
 269   3                              
 270   3                              if(touchPad_temp == touchPadScan_oneShoot()){
 271   4                                      
 272   4                                      conterTemp = touchCfrmLoop_MAX - touchPadActCounter;
 273   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 274   4      //                                      u8 xdata log_buf[64];
 275   4      //                                      
 276   4      //                                      sprintf(log_buf, "conut:%d.\n", (int)conterTemp);
 277   4      //                                      PrintString1_logOut(log_buf);
 278   4      //                              }
 279   4                              
 280   4                                      if(conterTemp > touchCfrmLoop_LongA && conterTemp <= touchCfrmLoop_LongB){
 281   5                                      
 282   5                                              if(!funTrigFLG_LongA){
 283   6                                              
 284   6                                                      funTrigFLG_LongA = 1;
 285   6                                                      touchPad_functionTrigNormal(touchPad_temp, press_LongA);
 286   6                                              }
 287   5                                      }
 288   4                                      if(conterTemp > touchCfrmLoop_LongB && conterTemp <= touchCfrmLoop_MAX){
 289   5                                      
 290   5                                              if(!funTrigFLG_LongB){
 291   6                                              
 292   6                                                      funTrigFLG_LongB = 1;
 293   6                                                      touchPad_functionTrigNormal(touchPad_temp, press_LongB);
 294   6                                              }
 295   5                                      }
 296   4                              }
 297   3                      }
 298   2              }else{
 299   2                      
 300   2                      if(keyPress_FLG){
 301   3                      
C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 6   

 302   3                              conterTemp = touchCfrmLoop_MAX - touchPadActCounter;
 303   3                              if(conterTemp > touchCfrmLoop_Short && conterTemp <= touchCfrmLoop_LongA){
 304   4                              
 305   4                                      if(touchPadContinueCnt)pressContinueGet ++;
 306   4                                      if(pressContinueGet <= 1)touchPad_functionTrigNormal(touchPad_temp, press_Short); //非连按短按触发互控
             -同步，若为连按则最后一次触发同步
 307   4                                      else touchPad_functionTrigNormal(touchPad_temp, press_ShortCnt);
 308   4                                      beeps_usrActive(3, 50, 3);
 309   4                              }
 310   3                      }
 311   2              
 312   2                      if(!touchPadContinueCnt && pressContinueGet){
 313   3                      
 314   3                              pressContinueCfm = pressContinueGet;
 315   3                              pressContinueGet = 0;
 316   3                              
 317   3                              if(pressContinueCfm >= 2){
 318   4      #if(DEBUG_LOGOUT_EN == 1)
 319   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 320   4      //                                      u8 xdata log_buf[64];
 321   4      //                                      
 322   4      //                                      sprintf(log_buf, "conut:%d.\n", (int)pressContinueCfm);
 323   4      //                                      PrintString1_logOut(log_buf);
 324   4      //                              }                       
 325   4      #endif
 326   4                                      touchPad_functionTrigContinue(touchPad_temp, pressContinueCfm);
 327   4                                      pressContinueCfm = 0;
 328   4                              }
 329   3                              
 330   3                              touchPad_temp = 0;
 331   3                      }
 332   2      
 333   2                      funTrigFLG_LongA = 0;
 334   2                      funTrigFLG_LongB = 0;
 335   2                              
 336   2                      touchPadActCounter = 0;
 337   2                      keyPress_FLG = 0;
 338   2              }
 339   1      }
 340          
 341          void touchPad_functionTrigNormal(u8 statusPad, keyCfrm_Type statusCfm){ //普通触摸触发
 342   1      
 343   1              switch(statusCfm){
 344   2              
 345   2                      case press_Short:{
 346   3                      
 347   3                              switch(statusPad){
 348   4                                      
 349   4                                      case 1:
 350   4                                      case 2:
 351   4                                      case 4:{
 352   5                                              
 353   5                                              swCommand_fromUsr.actMethod = relay_flip;
 354   5                                              swCommand_fromUsr.objRelay = statusPad;
 355   5                                              EACHCTRL_realesFLG = statusPad; //互控
 356   5                                              
 357   5                                      }break;
 358   4                                              
 359   4                                      default:{}break;
 360   4                              }
 361   3                              
 362   3                      }break;
C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 7   

 363   2                      
 364   2                      case press_ShortCnt:{
 365   3                              
 366   3                              switch(statusPad){
 367   4                                      
 368   4                                      case 1:
 369   4                                      case 2:
 370   4                                      case 4:{
 371   5                                              
 372   5                                              swCommand_fromUsr.actMethod = relay_flip;
 373   5                                              swCommand_fromUsr.objRelay = statusPad;
 374   5                                              
 375   5                                      }break;
 376   4                                              
 377   4                                      default:{}break;
 378   4                              }
 379   3                              
 380   3                      }break;
 381   2                      
 382   2                      case press_LongA:{
 383   3                      
 384   3                              switch(statusPad){
 385   4                              
 386   4                                      case 1:{
 387   5                                              
 388   5      //                                      PrintString1_logOut("touch mark: longA.\n"); //输出打印，谨记 用后注释，否则占用大量代码空间
 389   5                                      
 390   5                                      }break;
 391   4                                              
 392   4                                      case 2:{}break;
 393   4                                              
 394   4                                      case 4:{}break;
 395   4                                              
 396   4                                      default:{}break;
 397   4                              }
 398   3                              
 399   3                      }break;
 400   2                              
 401   2                      case press_LongB:{
 402   3                      
 403   3                              switch(statusPad){
 404   4                              
 405   4                                      case 1:{}break;
 406   4                                              
 407   4                                      case 2:{}break;
 408   4                                              
 409   4                                      case 4:{}break;
 410   4                                              
 411   4                                      default:{}break;
 412   4                              }
 413   3                              
 414   3                      }break;
 415   2                              
 416   2                      default:{}break;
 417   2              }
 418   1      }
 419          
 420          void touchPad_functionTrigContinue(u8 statusPad, u8 loopCount){ //触摸连按触发
 421   1              
 422   1              EACHCTRL_realesFLG = statusPad; //最后一次连按触发互控同步
 423   1      
 424   1              switch(statusPad){
C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 8   

 425   2              
 426   2                      case 1:{
 427   3                      
 428   3                              switch(loopCount){
 429   4                              
 430   4                                      case 3:{
 431   5      #if(DEBUG_LOGOUT_EN == 1)                               
 432   5                                              {
 433   6                                              
 434   6      //                                              PrintString1_logOut("continue 3.\n");
 435   6                                              }
 436   5      #endif                                  
 437   5                                      }break;
 438   4                                      
 439   4                                      case 4:{
 440   5                                      
 441   5                                              ZigB_nwkOpen(1, 5);
 442   5                                              devTips_status = status_tipsNwkOpen;
 443   5                                              
 444   5                                      }break;
 445   4                                              
 446   4                                      default:{}break;
 447   4                              }
 448   3                              
 449   3                      }break;
 450   2                              
 451   2                      case 2:{
 452   3                      
 453   3                              switch(loopCount){
 454   4                              
 455   4                                      case 3:{}break;
 456   4                                              
 457   4                                      default:{}break;
 458   4                              }
 459   3                              
 460   3                      }break;
 461   2                              
 462   2                      case 4:{
 463   3                      
 464   3                              switch(loopCount){
 465   4                              
 466   4                                      case 3:{}break;
 467   4                                              
 468   4                                      default:{}break;
 469   4                              }
 470   3                              
 471   3                      }break;
 472   2                              
 473   2                      default:{}break;
 474   2              }
 475   1      }
 476          
 477          void fun_Test(void){
 478   1      
 479   1              ;
 480   1      }
 481          
 482          void usrKeyFun_zigbNwkRejoin(void){
 483   1              
 484   1              devTips_status = status_tipsNwkFind;
 485   1      
 486   1              devStatus_switch.statusChange_standBy = status_nwkREQ;
C51 COMPILER V9.54   USRKIN                                                                09/02/2018 12:30:13 PAGE 9   

 487   1              devStatus_switch.statusChange_IF = 1;
 488   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    825    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      15
   IDATA SIZE       =      1    ----
   BIT SIZE         =      8       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
