C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE USRKIN
OBJECT MODULE PLACED IN .\Output\usrKin.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Sensor\usrKin.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Usr;.\Usr_lib;.\s
                    -td_Lib;.\dataTrans;.\Actuator;.\Sensor;.\hwDriver) DEBUG PRINT(.\Listings\usrKin.lst) OBJECT(.\Output\usrKin.obj)

line level    source

   1          #include "usrKin.h"
   2          
   3          #include "Tips.h"
   4          #include "dataTrans.h"
   5          #include "dataManage.h"
   6          #include "Relay.h"
   7          
   8          #include "delay.h"
   9          #include "USART.h"
  10          
  11          #include "stdio.h"
  12          #include "string.h"
  13          
  14          /**********************本地文件变量定义区**********************/
  15          u8 idata val_DcodeCfm                   = 0;  //拨码值
  16          bit              ledBackground_method   = 1;  //背景灯颜色方案 //为1时：开-绿 关-蓝   为0时：开-蓝 关-绿
  17          
  18          bit              usrKeyCount_EN                 = 0;  //用户按键计数
  19          u16              usrKeyCount                    = 0;
  20          
  21          u16     xdata touchPadActCounter        = 0;  //触摸盘按键计时
  22          u16     xdata touchPadContinueCnt       = 0;  //触摸盘连按计时
  23          
  24          //***************Tips变量引用区***************************/
  25          extern tips_Status devTips_status;
  26          
  27          /*--------------------------------------------------------------------------------------------------------
             -----*/
  28          ///*按键回调函数缓存*///为减少代码冗余，此段弃用
  29          //static fun_KeyTrigger xdata funTrig_keyTouch_1 = {0}; //连按可用 
  30          //static fun_KeyTrigger xdata funTrig_keyTouch_2 = {0}; //连按可用
  31          //static fun_KeyTrigger xdata funTrig_keyTouch_3 = {0}; //连按可用
  32          //static fun_KeyTrigger xdata funTrig_keyButton  = {0}; //连按不可用
  33          
  34          static void touchPad_functionTrigNormal(u8 statusPad, keyCfrm_Type statusCfm);
  35          static void touchPad_functionTrigContinue(u8 statusPad, u8 loopCount);
  36          
  37          ///*按键触发回调函数注册*///为减少代码冗余，此函数弃用
  38          //void funKeyTrigger_register(funKey_Callback funTrigger, objKey key, trig_Method mTrig, u8 pressCnt_num){
             - //回调函数，按键对象，触发方式，连按次数（大于2且 触发方式为连按 有效）
  39          
  40          //      switch(key){
  41          //      
  42          //              case kinObj_touch_1:{
  43          //              
  44          //                      switch(mTrig){
  45          //                      
  46          //                              case method_pressShort: funTrig_keyTouch_1.press_Short = funTrigger;break;
  47          //                              case method_pressCnt:   if(pressCnt_num >= 2)funTrig_keyTouch_1.press_Continue[pressCnt_num] = funTrig
             -ger;break;
  48          //                              case method_pressLong_A:funTrig_keyTouch_1.press_Long_A = funTrigger;break;
  49          //                              case method_pressLong_B:funTrig_keyTouch_1.press_Long_B = funTrigger;break;
  50          //                                      
  51          //                              default:break;
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 2   

  52          //                      }
  53          //              }break;
  54          //                      
  55          //              case kinObj_touch_2:{
  56          //                      
  57          //                      switch(mTrig){
  58          //                      
  59          //                              case method_pressShort: funTrig_keyTouch_2.press_Short = funTrigger;break;
  60          //                              case method_pressCnt:   if(pressCnt_num >= 2)funTrig_keyTouch_2.press_Continue[pressCnt_num] = funTrig
             -ger;break;
  61          //                              case method_pressLong_A:funTrig_keyTouch_2.press_Long_A = funTrigger;break;
  62          //                              case method_pressLong_B:funTrig_keyTouch_2.press_Long_B = funTrigger;break;
  63          //                                      
  64          //                              default:break;
  65          //                      }
  66          //              }break;
  67          //                      
  68          //              case kinObj_touch_3:{
  69          //                      
  70          //                      switch(mTrig){
  71          //                      
  72          //                              case method_pressShort: funTrig_keyButton.press_Short = funTrigger;break;
  73          //                              case method_pressLong_A:funTrig_keyButton.press_Long_A = funTrigger;break;
  74          //                              case method_pressLong_B:funTrig_keyButton.press_Long_B = funTrigger;break;
  75          //                              
  76          //                              case method_pressCnt: //连按不可用
  77          //                              default:break;
  78          //                      }
  79          //              }break;
  80          //                      
  81          //              case kinObj_button:{
  82          //              
  83          //                      switch(mTrig){
  84          //                      
  85          //                              case method_pressShort: funTrig_keyTouch_3.press_Short = funTrigger;break;
  86          //                              case method_pressCnt:   if(pressCnt_num >= 2)funTrig_keyTouch_3.press_Continue[pressCnt_num] = funTrig
             -ger;break;
  87          //                              case method_pressLong_A:funTrig_keyTouch_3.press_Long_A = funTrigger;break;
  88          //                              case method_pressLong_B:funTrig_keyTouch_3.press_Long_B = funTrigger;break;
  89          //                                      
  90          //                              default:break;
  91          //                      }
  92          //              }break;
  93          //                      
  94          //              default:break;
  95          //      }
  96          //}
  97          
  98          void usrZigbNwkOpen(void){
  99   1      
 100   1              ZigB_nwkOpen(1, ZIGBNWK_OPNETIME_DEFAULT); //功能触发
 101   1              tips_statusChangeToZigbNwkOpen(ZIGBNWK_OPNETIME_DEFAULT); //tips触发
 102   1      #if(DEBUG_LOGOUT_EN == 1)
 103   1              { //输出打印，谨记 用后注释，否则占用大量代码空间
 104   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 105   2                      sprintf(log_buf, "touchPad special trig:nwkOpen:%02ds.\n", (int)ZIGBNWK_OPNETIME_DEFAULT);
 106   2                      PrintString1_logOut(log_buf);
 107   2              }                       
 108   1      #endif  
 109   1      }
 110          
 111          void usrKin_pinInit(void){
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 3   

 112   1      
 113   1              P1M1 &= ~(0xE0);
 114   1              P1M0 &= ~(0xE0);
 115   1      
 116   1              P0M1 &= ~(0x04);
 117   1              P0M0 &= ~(0x04);
 118   1              
 119   1              if(!Dcode2)relayStatus_ifSave = statusSave_enable;
 120   1      }
 121          
 122          u8 DcodeScan_oneShoot(void){
 123   1      
 124   1              u8 val_Dcode = 0;
 125   1              
 126   1              if(!Dcode0)val_Dcode |= 1 << 0;
 127   1              else val_Dcode &= ~(1 << 0);
 128   1              
 129   1              if(!Dcode1)val_Dcode |= 1 << 1;
 130   1              else val_Dcode &= ~(1 << 1);
 131   1              
 132   1              if(!Dcode2)val_Dcode |= 1 << 2;
 133   1              else val_Dcode &= ~(1 << 2);
 134   1              
 135   1              if(!Dcode3)val_Dcode |= 1 << 3;
 136   1              else val_Dcode &= ~(1 << 3);
 137   1              
 138   1              if(!Dcode4)val_Dcode |= 1 << 4;
 139   1              else val_Dcode &= ~(1 << 4);
 140   1              
 141   1              if(!Dcode5)val_Dcode |= 1 << 5;
 142   1              else val_Dcode &= ~(1 << 5);
 143   1              
 144   1              return val_Dcode;
 145   1      }
 146          
 147          bit UsrKEYScan_oneShoot(void){
 148   1      
 149   1              return Usr_key;
 150   1      }
 151          
 152          u8 touchPadScan_oneShoot(void){
 153   1      
 154   1              u8 valKey_Temp = 0;
 155   1              
 156   1              if(!touchPad_1)valKey_Temp |= 0x01;
 157   1              if(!touchPad_2)valKey_Temp |= 0x02;
 158   1              if(!touchPad_3)valKey_Temp |= 0x04;
 159   1              
 160   1              return valKey_Temp;
 161   1      }
 162          
 163          void DcodeScan(void){
 164   1      
 165   1              static u8       val_Dcode_Local         = 0,
 166   1                                      comfirm_Cnt                     = 0;
 167   1              const  u8       comfirm_Period          = 200;  //消抖时间因数――取决于主线程调度周期
 168   1                      
 169   1                         u8   val_Dcode_differ        = 0;
 170   1              
 171   1                         bit  val_CHG                         = 0;
 172   1              
 173   1              val_DcodeCfm = DcodeScan_oneShoot();
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 4   

 174   1              
 175   1              DEV_actReserve = switchTypeReserve_GET(); //当前开关类型对应有效操作位刷新
 176   1              
 177   1              if(val_Dcode_Local != val_DcodeCfm){
 178   2              
 179   2                      if(comfirm_Cnt < comfirm_Period)comfirm_Cnt ++;
 180   2                      else{
 181   3                      
 182   3                              comfirm_Cnt = 0;
 183   3                              val_CHG         = 1;
 184   3                      }
 185   2              }
 186   1              
 187   1              if(val_CHG){
 188   2                      
 189   2                      val_CHG                         = 0;
 190   2              
 191   2                      val_Dcode_differ        = val_Dcode_Local ^ val_DcodeCfm;
 192   2                      val_Dcode_Local         = val_DcodeCfm;
 193   2      
 194   2                      if(val_Dcode_differ & Dcode_FLG_ifAP){
 195   3                      
 196   3                              if(val_Dcode_Local & Dcode_FLG_ifAP){
 197   4                              
 198   4      
 199   4                              }else{
 200   4                              
 201   4      
 202   4                              }
 203   3                      }
 204   2                      
 205   2                      if(val_Dcode_differ & Dcode_FLG_ifLED){
 206   3                      
 207   3                              if(val_Dcode_Local & Dcode_FLG_ifLED){
 208   4      
 209   4                                      
 210   4                              }else{
 211   4                              
 212   4      
 213   4                              }
 214   3                      }
 215   2                      
 216   2                      if(val_Dcode_differ & Dcode_FLG_ifMemory){
 217   3                      
 218   3                              if(val_Dcode_Local & Dcode_FLG_ifMemory){
 219   4      
 220   4                                      relayStatus_ifSave = statusSave_enable;
 221   4                                      
 222   4                              }else{
 223   4                              
 224   4                                      relayStatus_ifSave = statusSave_disable;
 225   4                              }
 226   3                      }
 227   2                      
 228   2                      if(val_Dcode_differ & Dcode_FLG_bitReserve){
 229   3                      
 230   3                              switch(Dcode_bitReserve(val_Dcode_Local)){
 231   4                              
 232   4                                      case 0:{
 233   5                                      
 234   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT3;       
 235   5                                              
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 5   

 236   5                                      }break;
 237   4                                              
 238   4                                      case 1:{
 239   5                                      
 240   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT1;       
 241   5      
 242   5                                      }break;
 243   4                                              
 244   4                                      case 2:{
 245   5                                      
 246   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT2;       
 247   5      
 248   5                                      }break;
 249   4                                              
 250   4                                      case 3:{
 251   5                                              
 252   5                                              SWITCH_TYPE = SWITCH_TYPE_SWBIT3;       
 253   5      
 254   5                                      }break;
 255   4                                              
 256   4                                      default:break;
 257   4                              }
 258   3                      }
 259   2              }
 260   1      }
 261          
 262          void UsrKEYScan(funKey_Callback funCB_Short, funKey_Callback funCB_LongA, funKey_Callback funCB_LongB){
 263   1              
 264   1              code    u16     keyCfrmLoop_Short       = 10,   //短按消抖时间,据大循环而定
 265   1                                      keyCfrmLoop_LongA       = 3000, //长按A时间,据大循环而定
 266   1                                      keyCfrmLoop_LongB       = 10000,//长按B时间,据大循环而定
 267   1                                      keyCfrmLoop_MAX         = 60000;//计时封顶
 268   1              
 269   1              static  bit LongA_FLG = 0;
 270   1              static  bit LongB_FLG = 0;
 271   1              
 272   1              static  bit keyPress_FLG = 0;
 273   1      
 274   1              if(!UsrKEYScan_oneShoot()){             
 275   2                      
 276   2                      keyPress_FLG = 1;
 277   2                      
 278   2      //              tips_statusChangeToNormal();
 279   2              
 280   2                      if(!usrKeyCount_EN) usrKeyCount_EN= 1;  //计时
 281   2                      
 282   2                      if((usrKeyCount >= keyCfrmLoop_LongA) && (usrKeyCount <= keyCfrmLoop_LongB) && !LongA_FLG){
 283   3                      
 284   3                              funCB_LongA();
 285   3                              
 286   3                              LongA_FLG = 1;
 287   3                      }       
 288   2                      
 289   2                      if((usrKeyCount >= keyCfrmLoop_LongB) && (usrKeyCount <= keyCfrmLoop_MAX) && !LongB_FLG){
 290   3                      
 291   3                              funCB_LongB();
 292   3                              
 293   3                              LongB_FLG = 1;
 294   3                      }
 295   2                      
 296   2              }else{          
 297   2                      
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 6   

 298   2                      usrKeyCount_EN = 0;
 299   2                      
 300   2                      if(keyPress_FLG){
 301   3                      
 302   3                              keyPress_FLG = 0;
 303   3                              
 304   3                              if(usrKeyCount < keyCfrmLoop_LongA && usrKeyCount > keyCfrmLoop_Short){
 305   4                              
 306   4      //                              static bit tipsFLG = 0;
 307   4      //                               
 308   4      //                              tipsFLG = !tipsFLG;
 309   4      //                              (tipsFLG)?(tipsLED_colorSet(obj_zigbNwk, 5, 0, 0)):(tipsLED_colorSet(obj_zigbNwk, 0, 5, 0));
 310   4                                      
 311   4                                      funCB_Short();
 312   4                              }
 313   3                              
 314   3                              usrKeyCount = 0;
 315   3                              LongA_FLG       = 0;
 316   3                              LongB_FLG       = 0;
 317   3                      }
 318   2              }
 319   1      }
 320          
 321          void touchPad_Scan(void){
 322   1      
 323   1              static u8 touchPad_temp = 0;
 324   1              static bit keyPress_FLG = 0;
 325   1              
 326   1              static bit funTrigFLG_LongA = 0;
 327   1              static bit funTrigFLG_LongB = 0;
 328   1              
 329   1              code    u16     touchCfrmLoop_Short     = timeDef_touchPressCfm,        //短按消抖时间
 330   1                                      touchCfrmLoop_LongA     = timeDef_touchPressLongA,      //长按A时间
 331   1                                      touchCfrmLoop_LongB     = timeDef_touchPressLongB,      //长按B时间
 332   1                                      touchCfrmLoop_MAX               = 60000;//计时封顶
 333   1              
 334   1              static u8 pressContinueGet = 0;
 335   1                     u8 pressContinueCfm = 0;
 336   1              
 337   1              u16 conterTemp = 0; //按下计时差值计算缓存
 338   1              
 339   1              if(touchPadScan_oneShoot()){
 340   2                      
 341   2                      if(!keyPress_FLG){
 342   3                      
 343   3                              keyPress_FLG = 1;
 344   3                              touchPadActCounter = touchCfrmLoop_MAX;
 345   3                              touchPadContinueCnt = timeDef_touchPressContinue;  //连按间隔判断时间
 346   3                              touchPad_temp = touchPadScan_oneShoot();
 347   3                      }
 348   2                      else{
 349   3                              
 350   3                              if(touchPad_temp == touchPadScan_oneShoot()){
 351   4                                      
 352   4                                      conterTemp = touchCfrmLoop_MAX - touchPadActCounter;
 353   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 354   4      //                                      u8 xdata log_buf[64];
 355   4      //                                      
 356   4      //                                      sprintf(log_buf, "conut:%d.\n", (int)conterTemp);
 357   4      //                                      PrintString1_logOut(log_buf);
 358   4      //                              }
 359   4                              
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 7   

 360   4                                      if(conterTemp > touchCfrmLoop_LongA && conterTemp <= touchCfrmLoop_LongB){
 361   5                                      
 362   5                                              if(!funTrigFLG_LongA){
 363   6                                              
 364   6                                                      funTrigFLG_LongA = 1;
 365   6                                                      touchPad_functionTrigNormal(touchPad_temp, press_LongA);
 366   6                                              }
 367   5                                      }
 368   4                                      if(conterTemp > touchCfrmLoop_LongB && conterTemp <= touchCfrmLoop_MAX){
 369   5                                      
 370   5                                              if(!funTrigFLG_LongB){
 371   6                                              
 372   6                                                      funTrigFLG_LongB = 1;
 373   6                                                      touchPad_functionTrigNormal(touchPad_temp, press_LongB);
 374   6                                              }
 375   5                                      }
 376   4                              }
 377   3                      }
 378   2              }else{
 379   2                      
 380   2                      if(keyPress_FLG){
 381   3                      
 382   3                              conterTemp = touchCfrmLoop_MAX - touchPadActCounter;
 383   3                              if(conterTemp > touchCfrmLoop_Short && conterTemp <= touchCfrmLoop_LongA){
 384   4                              
 385   4                                      if(touchPadContinueCnt)pressContinueGet ++;
 386   4                                      if(pressContinueGet <= 1)touchPad_functionTrigNormal(touchPad_temp, press_Short); //非连按短按触发互控
             -同步，若为连按则最后一次触发同步
 387   4                                      else touchPad_functionTrigNormal(touchPad_temp, press_ShortCnt);
 388   4                                      beeps_usrActive(3, 50, 2);
 389   4                              }
 390   3                      }
 391   2              
 392   2                      if(!touchPadContinueCnt && pressContinueGet){
 393   3                      
 394   3                              pressContinueCfm = pressContinueGet;
 395   3                              pressContinueGet = 0;
 396   3                              
 397   3                              if(pressContinueCfm >= 2){
 398   4      #if(DEBUG_LOGOUT_EN == 1)
 399   4      //                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 400   4      //                                      u8 xdata log_buf[64];
 401   4      //                                      
 402   4      //                                      sprintf(log_buf, "conut:%d.\n", (int)pressContinueCfm);
 403   4      //                                      PrintString1_logOut(log_buf);
 404   4      //                              }                       
 405   4      #endif
 406   4                                      touchPad_functionTrigContinue(touchPad_temp, pressContinueCfm);
 407   4                                      pressContinueCfm = 0;
 408   4                              }
 409   3                              
 410   3                              touchPad_temp = 0;
 411   3                      }
 412   2      
 413   2                      funTrigFLG_LongA = 0;
 414   2                      funTrigFLG_LongB = 0;
 415   2                              
 416   2                      touchPadActCounter = 0;
 417   2                      keyPress_FLG = 0;
 418   2              }
 419   1      }
 420          
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 8   

 421          void touchPad_functionTrigNormal(u8 statusPad, keyCfrm_Type statusCfm){ //普通触摸触发
 422   1      
 423   1              switch(statusCfm){
 424   2              
 425   2                      case press_Short:{
 426   3                              
 427   3      #if(DEBUG_LOGOUT_EN == 1)                               
 428   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 429   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 430   4                                      sprintf(log_buf, "touchPad:%02X, shortPress.\n", (int)statusPad);
 431   4                                      PrintString1_logOut(log_buf);
 432   4                              }
 433   3      #endif  
 434   3                              switch(statusPad){
 435   4                                      
 436   4                                      case 1:
 437   4                                      case 2:
 438   4                                      case 4:{
 439   5                                              
 440   5                                              swCommand_fromUsr.actMethod = relay_flip;
 441   5                                              swCommand_fromUsr.objRelay = statusPad;
 442   5                                              EACHCTRL_realesFLG = statusPad; //互控
 443   5                                              devActionPush_IF.push_IF = 1; //推送使能
 444   5                                              
 445   5                                      }break;
 446   4                                              
 447   4                                      default:{}break;
 448   4                              }
 449   3                              
 450   3                      }break;
 451   2                      
 452   2                      case press_ShortCnt:{
 453   3                              
 454   3      #if(DEBUG_LOGOUT_EN == 1)                               
 455   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 456   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 457   4                                      sprintf(log_buf, "touchPad:%02X, cntPress.\n", (int)statusPad);
 458   4                                      PrintString1_logOut(log_buf);
 459   4                              }
 460   3      #endif  
 461   3                              
 462   3                              switch(statusPad){
 463   4                                      
 464   4                                      case 1:
 465   4                                      case 2:
 466   4                                      case 4:{
 467   5                                              
 468   5                                              swCommand_fromUsr.actMethod = relay_flip;
 469   5                                              swCommand_fromUsr.objRelay = statusPad;
 470   5                                              
 471   5                                      }break;
 472   4                                              
 473   4                                      default:{}break;
 474   4                              }
 475   3                              
 476   3                      }break;
 477   2                      
 478   2                      case press_LongA:{
 479   3                              
 480   3      #if(DEBUG_LOGOUT_EN == 1)                               
 481   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 482   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 9   

 483   4                                      sprintf(log_buf, "touchPad:%02X, longPress_A.\n", (int)statusPad);
 484   4                                      PrintString1_logOut(log_buf);
 485   4                              }
 486   3      #endif  
 487   3                      
 488   3                              switch(statusPad){
 489   4                              
 490   4                                      case 1:{
 491   5                                              
 492   5                                      
 493   5                                      }break;
 494   4                                              
 495   4                                      case 2:{}break;
 496   4                                              
 497   4                                      case 4:{
 498   5                                      
 499   5                                              devStatusChangeTo_devHold(1); //设备网络挂起
 500   5                                      
 501   5                                      }break;
 502   4                                              
 503   4                                      default:{}break;
 504   4                              }
 505   3                              
 506   3                      }break;
 507   2                              
 508   2                      case press_LongB:{
 509   3                              
 510   3      #if(DEBUG_LOGOUT_EN == 1)                               
 511   3                              { //输出打印，谨记 用后注释，否则占用大量代码空间
 512   4                                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 513   4                                      sprintf(log_buf, "touchPad:%02X, longPress_B.\n", (int)statusPad);
 514   4                                      PrintString1_logOut(log_buf);
 515   4                              }
 516   3      #endif  
 517   3                      
 518   3                              switch(statusPad){
 519   4                              
 520   4                                      case 1:{}break;
 521   4                                              
 522   4                                      case 2:{}break;
 523   4                                              
 524   4                                      case 4:{}break;
 525   4                                              
 526   4                                      default:{}break;
 527   4                              }
 528   3                              
 529   3                      }break;
 530   2                              
 531   2                      default:{}break;
 532   2              }
 533   1      }
 534          
 535          void touchPad_functionTrigContinue(u8 statusPad, u8 loopCount){ //触摸连按触发
 536   1              
 537   1              EACHCTRL_realesFLG = statusPad; //最后一次连按触发互控同步
 538   1              devActionPush_IF.push_IF = 1; //最后一次连按触发推送使能
 539   1              
 540   1      #if(DEBUG_LOGOUT_EN == 1)                               
 541   1              { //输出打印，谨记 用后注释，否则占用大量代码空间
 542   2                      memset(log_buf, 0, LOGBUFF_LEN * sizeof(u8));
 543   2                      sprintf(log_buf, "touchPad:%02X, %02Xtime pressOver.\n", (int)statusPad, (int)loopCount);
 544   2                      PrintString1_logOut(log_buf);
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 10  

 545   2              }
 546   1      #endif  
 547   1      
 548   1              switch(statusPad){
 549   2              
 550   2                      case 1:{
 551   3                      
 552   3                              switch(loopCount){
 553   4                              
 554   4                                      case 3:{
 555   5                                      
 556   5                                      }break;
 557   4                                      
 558   4                                      case 4:{
 559   5                                      
 560   5                                              usrZigbNwkOpen(); //网络开放
 561   5                                              
 562   5                                      }break;
 563   4                                              
 564   4                                      default:{}break;
 565   4                              }
 566   3                              
 567   3                      }break;
 568   2                              
 569   2                      case 2:{
 570   3                      
 571   3                              switch(loopCount){
 572   4                              
 573   4                                      case 3:{}break;
 574   4                                              
 575   4                                      default:{}break;
 576   4                              }
 577   3                              
 578   3                      }break;
 579   2                              
 580   2                      case 4:{
 581   3                      
 582   3                              switch(loopCount){
 583   4                              
 584   4                                      case 3:{}break;
 585   4                                              
 586   4                                      case 4:{
 587   5                                      
 588   5                                              devHoldStop_makeInAdvance(); //设备网络挂起停止
 589   5                                      
 590   5                                      }break;
 591   4                                              
 592   4                                      default:{}break;
 593   4                              }
 594   3                              
 595   3                      }break;
 596   2                              
 597   2                      default:{}break;
 598   2              }
 599   1      }
 600          
 601          void fun_Test(void){
 602   1      
 603   1              ;
 604   1      }
 605          
 606          void usrKeyFun_zigbNwkRejoin(void){
C51 COMPILER V9.54   USRKIN                                                                11/02/2018 15:47:41 PAGE 11  

 607   1      
 608   1              devStatus_switch.statusChange_standBy = status_nwkREQ;
 609   1              devStatus_switch.statusChange_IF = 1;
 610   1              
 611   1              tips_statusChangeToZigbNwkFind(); //tips更新
 612   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1196    ----
   CONSTANT SIZE    =    202    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      17
   IDATA SIZE       =      1    ----
   BIT SIZE         =      8       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
